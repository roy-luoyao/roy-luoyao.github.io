{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"source/resume.pdf","path":"resume.pdf","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/Tools/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1751954625323},{"_id":"source/_posts/iOS/classVStruct.md","hash":"3c379ba5fc329d289806dc93f078da40056a949c","modified":1751958395277},{"_id":"source/_posts/iOS/closure闭包block的区别.md","hash":"7864c1d3984f78ef1b8148754a25ad749a5a5fe9","modified":1751958395279},{"_id":"source/_posts/iOS/Open-Public-Internal关键字.md","hash":"7ef5408123727e42c72735e00a017409e2e2cbd7","modified":1751958395284},{"_id":"source/_posts/iOS/存储属性和计算属性的区别.md","hash":"fa9abdabdaa3babf2852333030b657e15833ba6e","modified":1751958395263},{"_id":"source/_posts/iOS/mutating关键字的作用.md","hash":"ad31b173c01b8be516d04eeff34f9413f080dc85","modified":1751958395281},{"_id":"source/_posts/iOS/泛型Generics.md","hash":"f312912e447895ff092f79034ab4ed7263fb68f5","modified":1751958395267},{"_id":"themes/landscape/.gitignore","hash":"4c78c751a5bbca6b54ad06922947573c967d51c8","modified":1751958776617},{"_id":"themes/landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1751958776617},{"_id":"themes/landscape/.npmignore","hash":"4c40eab00f24304ca400313319c58d461788ff5e","modified":1751958776617},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1751958776617},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1751958776617},{"_id":"themes/landscape/languages/de-DE.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1751958776617},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/languages/en-US.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/languages/en-GB.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1751958776622},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1751958776618},{"_id":"themes/landscape/languages/es-ES.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1751958776618},{"_id":"themes/landscape/.github/dependabot.yml","hash":"25b0257a0db2c5b6a5756d8990bc2cba12f54fc5","modified":1751958776617},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1751958776618},{"_id":"themes/landscape/languages/fr-FR.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1751958776618},{"_id":"themes/landscape/languages/it-IT.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1751958776618},{"_id":"themes/landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1751958776618},{"_id":"themes/landscape/languages/hu-HU.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1751958776618},{"_id":"themes/landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1751958776618},{"_id":"themes/landscape/languages/ja-JP.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1751958776618},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1751958776618},{"_id":"themes/landscape/_config.yml","hash":"44a77e5f86de4e86ecca3902c51ee86bed89a204","modified":1751958855108},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1751958776618},{"_id":"themes/landscape/languages/ko-KR.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1751958776618},{"_id":"themes/landscape/languages/mn-MN.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1751958776618},{"_id":"themes/landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1751958776618},{"_id":"themes/landscape/languages/nl-NL.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1751958776619},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1751958776619},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1751958776619},{"_id":"themes/landscape/languages/pt-PT.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1751958776619},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1751958776619},{"_id":"themes/landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1751958776619},{"_id":"themes/landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1751958776619},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1751958776620},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1751958776619},{"_id":"themes/landscape/languages/ru-RU.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1751958776619},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1751958776619},{"_id":"themes/landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1751958776619},{"_id":"themes/landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1751958776622},{"_id":"themes/landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1751958776622},{"_id":"themes/landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1751958776622},{"_id":"themes/landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1751958776622},{"_id":"themes/landscape/.github/workflows/deploy.yml","hash":"509fdb4fff2078485a2765a1b685312c21e84e5b","modified":1751958776617},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1751958776622},{"_id":"themes/landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1751958776622},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1751958776622},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1751958776620},{"_id":"themes/landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1751958776623},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1751958776621},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1751958776621},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1751958776621},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1751958776621},{"_id":"themes/landscape/layout/_widget/resume.ejs","hash":"bfb4883ad6cd9dc60e4c2466383d82fa97cf50e2","modified":1751958853067},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1751958776622},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1751958776622},{"_id":"themes/landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1751958776624},{"_id":"themes/landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1751958776625},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1751958776623},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1751958776626},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1751958776621},{"_id":"themes/landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1751958776626},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1751958776624},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1751958776624},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1751958776624},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1751958776624},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1751958776624},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1751958776626},{"_id":"themes/landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1751958776626},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1751958776625},{"_id":"source/resume.pdf","hash":"c35dc92cd0239e59ddebb62ec7fdc0def06aac0c","modified":1751958529383},{"_id":"public/2025/07/08/Tools/hello-world/index.html","hash":"7152772ea20c7cfe3c47e45a3a0972c691b2707a","modified":1751958964957},{"_id":"public/2025/07/08/iOS/classVStruct/index.html","hash":"2198b93585d29cc818e18c7b171820c22905fc57","modified":1751958964957},{"_id":"public/2025/07/08/iOS/closure闭包block的区别/index.html","hash":"fc523d87d48b7a5e2338e53cfc94703b50a44747","modified":1751958964957},{"_id":"public/2025/07/08/iOS/Open-Public-Internal关键字/index.html","hash":"906f153e47d9fb0e72b373d3f0243ac08433b8a2","modified":1751958964957},{"_id":"public/2025/07/08/iOS/存储属性和计算属性的区别/index.html","hash":"ed083fd51f97b83d7d6ca752b48b9977dacc3fc8","modified":1751958964957},{"_id":"public/2025/07/08/iOS/mutating关键字的作用/index.html","hash":"5c661e95cddb3d0006e7efa8b863517143a342ab","modified":1751958964957},{"_id":"public/2025/07/02/iOS/泛型Generics/index.html","hash":"743fa1e3ee1b2191db0ea3b0043fc1c81d967968","modified":1751958964957},{"_id":"public/archives/index.html","hash":"ba0fccec7f5f54d6a0d573806621925d7411b753","modified":1751958964957},{"_id":"public/archives/2025/index.html","hash":"c54c7e21427a119147776a0fe29a940bd4b63f69","modified":1751958964957},{"_id":"public/archives/2025/07/index.html","hash":"00451c8974a6ad13f87fab30482e7484a9e340a6","modified":1751958964957},{"_id":"public/index.html","hash":"f06c49941bf179d4ba149601d4469ceda1208da2","modified":1751958964957},{"_id":"public/css/style.css","hash":"ecc329be740a220cc188ff49b02da4847cb7ee5e","modified":1751958964957},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1751958964957},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1751958964957},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1751958964957},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1751958964957},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1751958964957},{"_id":"public/resume.pdf","hash":"c35dc92cd0239e59ddebb62ec7fdc0def06aac0c","modified":1751958964957}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/Tools/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"Tools/hello-world","published":1,"date":"2025-07-08T06:01:08.230Z","updated":"2025-07-08T06:03:45.323Z","comments":1,"layout":"post","photos":[],"_id":"cmcu74t530000d9k71z1b7r4u","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"_content":"\n\n```markdown\n在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢\n# 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别\n\n## 使用 `class` 定义 `ListNode`\n\n```swift\npublic class ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 引用类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。\n\n• 修改一个引用的值会影响所有引用该实例的变量。\n\n\n• 链表操作：\n\n• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，并将其链接到当前节点的`next`属性上。\n\n\n使用`struct`定义`ListNode`\n\n\n```swift\npublic struct ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 值类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上会创建一个新的副本。\n\n• 修改一个副本的值不会影响其他副本。\n\n\n• 链表操作：\n\n• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，但`curr`本身是一个值类型，因此`curr`的修改不会影响原来的链表结构。\n\n\n示例对比\n\n\n使用`class`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 3\n```\n\n\n\n• `node1.next`和`node2`指向同一个实例，因此修改`node2.val`会影响`node1.next?.val`。\n\n\n使用`struct`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 2\n```\n\n\n\n• `node1.next`和`node2`是两个独立的副本，因此修改`node2.val`不会影响`node1.next?.val`。\n\n\n为什么链表通常使用`class`而不是`struct`？\n\n\n• 链表的特性：\n\n• 链表是一种动态数据结构，节点之间通过指针连接。\n\n• 引用类型（`class`）更适合这种场景，因为引用类型允许节点之间共享相同的实例。\n\n\n• 性能和内存管理：\n\n• 使用`class`时，节点的连接和操作只需要调整指针，而不需要复制整个对象。\n\n• 使用`struct`时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。\n\n\n• 链表操作的复杂性：\n\n• 在链表操作中，经常需要修改节点的`next`指针。\n\n• 使用`class`时，这些操作是直接的，因为`next`指针指向的是同一个实例。\n\n• 使用`struct`时，每次修改`next`指针都需要创建新的副本，这会使代码变得复杂且难以维护。\n\n\n总结\n\n• 使用`class`：\n\n• 适合链表这种需要通过指针连接和操作的动态数据结构。\n\n• 引用类型允许节点之间共享相同的实例，操作效率高。\n\n\n• 使用`struct`：\n\n• 适合值类型，例如简单的数据结构或不可变对象。\n\n• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。\n\n因此，在实现链表时，推荐使用`class`而不是`struct`。\n","source":"_posts/iOS/classVStruct.md","raw":"\n\n```markdown\n在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢\n# 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别\n\n## 使用 `class` 定义 `ListNode`\n\n```swift\npublic class ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 引用类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。\n\n• 修改一个引用的值会影响所有引用该实例的变量。\n\n\n• 链表操作：\n\n• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，并将其链接到当前节点的`next`属性上。\n\n\n使用`struct`定义`ListNode`\n\n\n```swift\npublic struct ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 值类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上会创建一个新的副本。\n\n• 修改一个副本的值不会影响其他副本。\n\n\n• 链表操作：\n\n• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，但`curr`本身是一个值类型，因此`curr`的修改不会影响原来的链表结构。\n\n\n示例对比\n\n\n使用`class`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 3\n```\n\n\n\n• `node1.next`和`node2`指向同一个实例，因此修改`node2.val`会影响`node1.next?.val`。\n\n\n使用`struct`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 2\n```\n\n\n\n• `node1.next`和`node2`是两个独立的副本，因此修改`node2.val`不会影响`node1.next?.val`。\n\n\n为什么链表通常使用`class`而不是`struct`？\n\n\n• 链表的特性：\n\n• 链表是一种动态数据结构，节点之间通过指针连接。\n\n• 引用类型（`class`）更适合这种场景，因为引用类型允许节点之间共享相同的实例。\n\n\n• 性能和内存管理：\n\n• 使用`class`时，节点的连接和操作只需要调整指针，而不需要复制整个对象。\n\n• 使用`struct`时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。\n\n\n• 链表操作的复杂性：\n\n• 在链表操作中，经常需要修改节点的`next`指针。\n\n• 使用`class`时，这些操作是直接的，因为`next`指针指向的是同一个实例。\n\n• 使用`struct`时，每次修改`next`指针都需要创建新的副本，这会使代码变得复杂且难以维护。\n\n\n总结\n\n• 使用`class`：\n\n• 适合链表这种需要通过指针连接和操作的动态数据结构。\n\n• 引用类型允许节点之间共享相同的实例，操作效率高。\n\n\n• 使用`struct`：\n\n• 适合值类型，例如简单的数据结构或不可变对象。\n\n• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。\n\n因此，在实现链表时，推荐使用`class`而不是`struct`。\n","slug":"iOS/classVStruct","published":1,"date":"2025-07-08T03:59:12.730Z","updated":"2025-07-08T07:06:35.277Z","title":"","comments":1,"layout":"post","photos":[],"_id":"cmcu74t550001d9k7ea60b6ix","content":"<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢</span><br><span class=\"line\"><span class=\"section\"># 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 使用 `class` 定义 `ListNode`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">```swift</span></span><br><span class=\"line\"><span class=\"code\">public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"code\">    public var val: Int</span></span><br><span class=\"line\"><span class=\"code\">    public var next: ListNode?</span></span><br><span class=\"line\"><span class=\"code\">    public init(_ val: Int) &#123; self.val = val; self.next = nil &#125;</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 引用类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。</p>\n<p>• 修改一个引用的值会影响所有引用该实例的变量。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，并将其链接到当前节点的<code>next</code>属性上。</p>\n<p>使用<code>struct</code>定义<code>ListNode</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> val: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> next: <span class=\"type\">ListNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> <span class=\"params\">val</span>: <span class=\"type\">Int</span>) &#123; <span class=\"keyword\">self</span>.val <span class=\"operator\">=</span> val; <span class=\"keyword\">self</span>.next <span class=\"operator\">=</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 值类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上会创建一个新的副本。</p>\n<p>• 修改一个副本的值不会影响其他副本。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，但<code>curr</code>本身是一个值类型，因此<code>curr</code>的修改不会影响原来的链表结构。</p>\n<p>示例对比</p>\n<p>使用<code>class</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>指向同一个实例，因此修改<code>node2.val</code>会影响<code>node1.next?.val</code>。</p>\n<p>使用<code>struct</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>是两个独立的副本，因此修改<code>node2.val</code>不会影响<code>node1.next?.val</code>。</p>\n<p>为什么链表通常使用<code>class</code>而不是<code>struct</code>？</p>\n<p>• 链表的特性：</p>\n<p>• 链表是一种动态数据结构，节点之间通过指针连接。</p>\n<p>• 引用类型（<code>class</code>）更适合这种场景，因为引用类型允许节点之间共享相同的实例。</p>\n<p>• 性能和内存管理：</p>\n<p>• 使用<code>class</code>时，节点的连接和操作只需要调整指针，而不需要复制整个对象。</p>\n<p>• 使用<code>struct</code>时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。</p>\n<p>• 链表操作的复杂性：</p>\n<p>• 在链表操作中，经常需要修改节点的<code>next</code>指针。</p>\n<p>• 使用<code>class</code>时，这些操作是直接的，因为<code>next</code>指针指向的是同一个实例。</p>\n<p>• 使用<code>struct</code>时，每次修改<code>next</code>指针都需要创建新的副本，这会使代码变得复杂且难以维护。</p>\n<p>总结</p>\n<p>• 使用<code>class</code>：</p>\n<p>• 适合链表这种需要通过指针连接和操作的动态数据结构。</p>\n<p>• 引用类型允许节点之间共享相同的实例，操作效率高。</p>\n<p>• 使用<code>struct</code>：</p>\n<p>• 适合值类型，例如简单的数据结构或不可变对象。</p>\n<p>• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。</p>\n<p>因此，在实现链表时，推荐使用<code>class</code>而不是<code>struct</code>。</p>\n","excerpt":"","more":"<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢</span><br><span class=\"line\"><span class=\"section\"># 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 使用 `class` 定义 `ListNode`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">```swift</span></span><br><span class=\"line\"><span class=\"code\">public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"code\">    public var val: Int</span></span><br><span class=\"line\"><span class=\"code\">    public var next: ListNode?</span></span><br><span class=\"line\"><span class=\"code\">    public init(_ val: Int) &#123; self.val = val; self.next = nil &#125;</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 引用类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。</p>\n<p>• 修改一个引用的值会影响所有引用该实例的变量。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，并将其链接到当前节点的<code>next</code>属性上。</p>\n<p>使用<code>struct</code>定义<code>ListNode</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> val: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> next: <span class=\"type\">ListNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> <span class=\"params\">val</span>: <span class=\"type\">Int</span>) &#123; <span class=\"keyword\">self</span>.val <span class=\"operator\">=</span> val; <span class=\"keyword\">self</span>.next <span class=\"operator\">=</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 值类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上会创建一个新的副本。</p>\n<p>• 修改一个副本的值不会影响其他副本。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，但<code>curr</code>本身是一个值类型，因此<code>curr</code>的修改不会影响原来的链表结构。</p>\n<p>示例对比</p>\n<p>使用<code>class</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>指向同一个实例，因此修改<code>node2.val</code>会影响<code>node1.next?.val</code>。</p>\n<p>使用<code>struct</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>是两个独立的副本，因此修改<code>node2.val</code>不会影响<code>node1.next?.val</code>。</p>\n<p>为什么链表通常使用<code>class</code>而不是<code>struct</code>？</p>\n<p>• 链表的特性：</p>\n<p>• 链表是一种动态数据结构，节点之间通过指针连接。</p>\n<p>• 引用类型（<code>class</code>）更适合这种场景，因为引用类型允许节点之间共享相同的实例。</p>\n<p>• 性能和内存管理：</p>\n<p>• 使用<code>class</code>时，节点的连接和操作只需要调整指针，而不需要复制整个对象。</p>\n<p>• 使用<code>struct</code>时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。</p>\n<p>• 链表操作的复杂性：</p>\n<p>• 在链表操作中，经常需要修改节点的<code>next</code>指针。</p>\n<p>• 使用<code>class</code>时，这些操作是直接的，因为<code>next</code>指针指向的是同一个实例。</p>\n<p>• 使用<code>struct</code>时，每次修改<code>next</code>指针都需要创建新的副本，这会使代码变得复杂且难以维护。</p>\n<p>总结</p>\n<p>• 使用<code>class</code>：</p>\n<p>• 适合链表这种需要通过指针连接和操作的动态数据结构。</p>\n<p>• 引用类型允许节点之间共享相同的实例，操作效率高。</p>\n<p>• 使用<code>struct</code>：</p>\n<p>• 适合值类型，例如简单的数据结构或不可变对象。</p>\n<p>• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。</p>\n<p>因此，在实现链表时，推荐使用<code>class</code>而不是<code>struct</code>。</p>\n"},{"title":"closure闭包是什么-使用场景-与OC中block的区别","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **闭包（Closure）定义**\n   - 闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。\n   - Swift 中的函数本质上也是特殊的闭包。\n   - 闭包可作为变量、参数、返回值传递和使用。\n\n2. **闭包的语法**\n   - 基本语法：\n     ```swift\n     let closure = { (参数) -> 返回类型 in\n         // 代码体\n     }\n     ```\n   - 支持类型推断、参数简写、尾随闭包等特性。\n\n## 1.2 为什么要用闭包？\n- 提升代码复用性和灵活性，支持函数式编程。\n- 可作为回调、异步处理、事件响应等，简化代码结构。\n- 捕获上下文变量，便于状态管理和数据流传递。\n\n## 1.3 实际项目使用场景\n1. **异步回调**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       // 网络请求结束后回调\n       completion(data)\n   }\n   ```\n2. **集合操作**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 } // 闭包作为参数\n   ```\n3. **动画、事件响应**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **自定义排序、过滤**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 1.4 与 Objective-C 中 Block 的区别\n1. **语法与类型系统**\n   - Swift 闭包语法更简洁，类型推断更强。\n   - Block 语法繁琐，需显式声明参数和返回值类型。\n2. **内存管理**\n   - Swift 闭包默认捕获变量为强引用，需用 `[weak self]`/`[unowned self]` 避免循环引用。\n   - OC Block 分为全局、栈、堆三种类型，需用 `__weak`/`__block` 修饰符管理引用。\n3. **捕获机制**\n   - Swift 闭包自动捕获上下文变量。\n   - OC Block 需用 `__block` 修饰变量才能在 Block 内修改。\n4. **语法特性**\n   - Swift 支持尾随闭包、参数简写、自动推断。\n   - OC Block 语法固定，灵活性较低。\n\n## 1.5 用户体验与业务价值\n- 闭包让 API 更加简洁、易用，提升开发效率。\n- 便于实现响应式、链式调用，提升产品交互体验。\n- 合理管理闭包内存，避免内存泄漏，保障 App 稳定性。\n\n## 1.6 问题拆解与调试建议\n- 遇到内存泄漏，优先排查闭包的循环引用，使用 `[weak self]` 或 `[unowned self]`。\n- 调试异步回调时，关注闭包是否正确捕获和释放上下文。\n- 对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。\n\n## 1.7 易混淆概念区分\n- **闭包 vs Block**：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。\n- **逃逸闭包（@escaping）**：闭包在函数返回后才被调用，需显式标记。\n- **自动闭包（@autoclosure）**：延迟求值，常用于断言、短路等场景。\n\n---\n\n# 2. English Answer\n\n## 2.1 What is a Closure?\n- A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.\n- Functions in Swift are special cases of closures.\n- Closures can be assigned to variables, passed as parameters, and returned from functions.\n\n## 2.2 Why use closures?\n- Improve code reusability and flexibility, support functional programming.\n- Used for callbacks, async handling, event response, etc.\n- Capture context for state management and data flow.\n\n## 2.3 Practical Usage Scenarios\n1. **Async Callbacks**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       completion(data)\n   }\n   ```\n2. **Collection Operations**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 }\n   ```\n3. **Animation/Event Handling**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **Custom Sorting/Filtering**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 2.4 Difference from Objective-C Block\n1. **Syntax & Type System**\n   - Swift closures are more concise, with strong type inference.\n   - Block syntax is verbose, requires explicit type declaration.\n2. **Memory Management**\n   - Swift closures capture variables strongly by default; use `[weak self]`/`[unowned self]` to avoid retain cycles.\n   - OC Blocks have global, stack, and heap types; use `__weak`/`__block` for reference management.\n3. **Capture Mechanism**\n   - Swift closures automatically capture context variables.\n   - OC Blocks require `__block` to modify captured variables.\n4. **Syntax Features**\n   - Swift supports trailing closures, shorthand arguments, and type inference.\n   - OC Block syntax is fixed and less flexible.\n\n## 2.5 User Experience & Business Value\n- Closures make APIs cleaner and easier to use, improving development efficiency.\n- Enable reactive and chainable calls, enhancing product interactivity.\n- Proper memory management avoids leaks and ensures app stability.\n\n## 2.6 Debugging & Troubleshooting\n- For memory leaks, check for retain cycles in closures and use `[weak self]` or `[unowned self]`.\n- When debugging async callbacks, ensure closures capture and release context correctly.\n- Compare Block and closure capture/release mechanisms to choose the best fit for your scenario.\n\n## 2.7 Related Concepts\n- **Closure vs Block**: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C's function object implementation.\n- **Escaping Closures (@escaping)**: Closure is called after the function returns, must be marked explicitly.\n- **Autoclosure (@autoclosure)**: Delays evaluation, often used in assertions and short-circuiting.\n","source":"_posts/iOS/closure闭包block的区别.md","raw":"---\ntitle: closure闭包是什么-使用场景-与OC中block的区别\ndate: 2025-07-08\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **闭包（Closure）定义**\n   - 闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。\n   - Swift 中的函数本质上也是特殊的闭包。\n   - 闭包可作为变量、参数、返回值传递和使用。\n\n2. **闭包的语法**\n   - 基本语法：\n     ```swift\n     let closure = { (参数) -> 返回类型 in\n         // 代码体\n     }\n     ```\n   - 支持类型推断、参数简写、尾随闭包等特性。\n\n## 1.2 为什么要用闭包？\n- 提升代码复用性和灵活性，支持函数式编程。\n- 可作为回调、异步处理、事件响应等，简化代码结构。\n- 捕获上下文变量，便于状态管理和数据流传递。\n\n## 1.3 实际项目使用场景\n1. **异步回调**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       // 网络请求结束后回调\n       completion(data)\n   }\n   ```\n2. **集合操作**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 } // 闭包作为参数\n   ```\n3. **动画、事件响应**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **自定义排序、过滤**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 1.4 与 Objective-C 中 Block 的区别\n1. **语法与类型系统**\n   - Swift 闭包语法更简洁，类型推断更强。\n   - Block 语法繁琐，需显式声明参数和返回值类型。\n2. **内存管理**\n   - Swift 闭包默认捕获变量为强引用，需用 `[weak self]`/`[unowned self]` 避免循环引用。\n   - OC Block 分为全局、栈、堆三种类型，需用 `__weak`/`__block` 修饰符管理引用。\n3. **捕获机制**\n   - Swift 闭包自动捕获上下文变量。\n   - OC Block 需用 `__block` 修饰变量才能在 Block 内修改。\n4. **语法特性**\n   - Swift 支持尾随闭包、参数简写、自动推断。\n   - OC Block 语法固定，灵活性较低。\n\n## 1.5 用户体验与业务价值\n- 闭包让 API 更加简洁、易用，提升开发效率。\n- 便于实现响应式、链式调用，提升产品交互体验。\n- 合理管理闭包内存，避免内存泄漏，保障 App 稳定性。\n\n## 1.6 问题拆解与调试建议\n- 遇到内存泄漏，优先排查闭包的循环引用，使用 `[weak self]` 或 `[unowned self]`。\n- 调试异步回调时，关注闭包是否正确捕获和释放上下文。\n- 对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。\n\n## 1.7 易混淆概念区分\n- **闭包 vs Block**：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。\n- **逃逸闭包（@escaping）**：闭包在函数返回后才被调用，需显式标记。\n- **自动闭包（@autoclosure）**：延迟求值，常用于断言、短路等场景。\n\n---\n\n# 2. English Answer\n\n## 2.1 What is a Closure?\n- A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.\n- Functions in Swift are special cases of closures.\n- Closures can be assigned to variables, passed as parameters, and returned from functions.\n\n## 2.2 Why use closures?\n- Improve code reusability and flexibility, support functional programming.\n- Used for callbacks, async handling, event response, etc.\n- Capture context for state management and data flow.\n\n## 2.3 Practical Usage Scenarios\n1. **Async Callbacks**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       completion(data)\n   }\n   ```\n2. **Collection Operations**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 }\n   ```\n3. **Animation/Event Handling**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **Custom Sorting/Filtering**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 2.4 Difference from Objective-C Block\n1. **Syntax & Type System**\n   - Swift closures are more concise, with strong type inference.\n   - Block syntax is verbose, requires explicit type declaration.\n2. **Memory Management**\n   - Swift closures capture variables strongly by default; use `[weak self]`/`[unowned self]` to avoid retain cycles.\n   - OC Blocks have global, stack, and heap types; use `__weak`/`__block` for reference management.\n3. **Capture Mechanism**\n   - Swift closures automatically capture context variables.\n   - OC Blocks require `__block` to modify captured variables.\n4. **Syntax Features**\n   - Swift supports trailing closures, shorthand arguments, and type inference.\n   - OC Block syntax is fixed and less flexible.\n\n## 2.5 User Experience & Business Value\n- Closures make APIs cleaner and easier to use, improving development efficiency.\n- Enable reactive and chainable calls, enhancing product interactivity.\n- Proper memory management avoids leaks and ensures app stability.\n\n## 2.6 Debugging & Troubleshooting\n- For memory leaks, check for retain cycles in closures and use `[weak self]` or `[unowned self]`.\n- When debugging async callbacks, ensure closures capture and release context correctly.\n- Compare Block and closure capture/release mechanisms to choose the best fit for your scenario.\n\n## 2.7 Related Concepts\n- **Closure vs Block**: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C's function object implementation.\n- **Escaping Closures (@escaping)**: Closure is called after the function returns, must be marked explicitly.\n- **Autoclosure (@autoclosure)**: Delays evaluation, often used in assertions and short-circuiting.\n","slug":"iOS/closure闭包block的区别","published":1,"updated":"2025-07-08T07:06:35.279Z","comments":1,"layout":"post","photos":[],"_id":"cmcu74t550002d9k71d7m1wt5","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>闭包（Closure）定义</strong></p>\n<ul>\n<li>闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。</li>\n<li>Swift 中的函数本质上也是特殊的闭包。</li>\n<li>闭包可作为变量、参数、返回值传递和使用。</li>\n</ul>\n</li>\n<li><p><strong>闭包的语法</strong></p>\n<ul>\n<li>基本语法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> closure <span class=\"operator\">=</span> &#123; (参数) -&gt; 返回类型 <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// 代码体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>支持类型推断、参数简写、尾随闭包等特性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要用闭包？\"><a href=\"#1-2-为什么要用闭包？\" class=\"headerlink\" title=\"1.2 为什么要用闭包？\"></a>1.2 为什么要用闭包？</h2><ul>\n<li>提升代码复用性和灵活性，支持函数式编程。</li>\n<li>可作为回调、异步处理、事件响应等，简化代码结构。</li>\n<li>捕获上下文变量，便于状态管理和数据流传递。</li>\n</ul>\n<h2 id=\"1-3-实际项目使用场景\"><a href=\"#1-3-实际项目使用场景\" class=\"headerlink\" title=\"1.3 实际项目使用场景\"></a>1.3 实际项目使用场景</h2><ol>\n<li><strong>异步回调</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求结束后回调</span></span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>集合操作</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125; <span class=\"comment\">// 闭包作为参数</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>动画、事件响应</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>自定义排序、过滤</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-4-与-Objective-C-中-Block-的区别\"><a href=\"#1-4-与-Objective-C-中-Block-的区别\" class=\"headerlink\" title=\"1.4 与 Objective-C 中 Block 的区别\"></a>1.4 与 Objective-C 中 Block 的区别</h2><ol>\n<li><strong>语法与类型系统</strong><ul>\n<li>Swift 闭包语法更简洁，类型推断更强。</li>\n<li>Block 语法繁琐，需显式声明参数和返回值类型。</li>\n</ul>\n</li>\n<li><strong>内存管理</strong><ul>\n<li>Swift 闭包默认捕获变量为强引用，需用 <code>[weak self]</code>&#x2F;<code>[unowned self]</code> 避免循环引用。</li>\n<li>OC Block 分为全局、栈、堆三种类型，需用 <code>__weak</code>&#x2F;<code>__block</code> 修饰符管理引用。</li>\n</ul>\n</li>\n<li><strong>捕获机制</strong><ul>\n<li>Swift 闭包自动捕获上下文变量。</li>\n<li>OC Block 需用 <code>__block</code> 修饰变量才能在 Block 内修改。</li>\n</ul>\n</li>\n<li><strong>语法特性</strong><ul>\n<li>Swift 支持尾随闭包、参数简写、自动推断。</li>\n<li>OC Block 语法固定，灵活性较低。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-5-用户体验与业务价值\"><a href=\"#1-5-用户体验与业务价值\" class=\"headerlink\" title=\"1.5 用户体验与业务价值\"></a>1.5 用户体验与业务价值</h2><ul>\n<li>闭包让 API 更加简洁、易用，提升开发效率。</li>\n<li>便于实现响应式、链式调用，提升产品交互体验。</li>\n<li>合理管理闭包内存，避免内存泄漏，保障 App 稳定性。</li>\n</ul>\n<h2 id=\"1-6-问题拆解与调试建议\"><a href=\"#1-6-问题拆解与调试建议\" class=\"headerlink\" title=\"1.6 问题拆解与调试建议\"></a>1.6 问题拆解与调试建议</h2><ul>\n<li>遇到内存泄漏，优先排查闭包的循环引用，使用 <code>[weak self]</code> 或 <code>[unowned self]</code>。</li>\n<li>调试异步回调时，关注闭包是否正确捕获和释放上下文。</li>\n<li>对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。</li>\n</ul>\n<h2 id=\"1-7-易混淆概念区分\"><a href=\"#1-7-易混淆概念区分\" class=\"headerlink\" title=\"1.7 易混淆概念区分\"></a>1.7 易混淆概念区分</h2><ul>\n<li><strong>闭包 vs Block</strong>：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。</li>\n<li><strong>逃逸闭包（@escaping）</strong>：闭包在函数返回后才被调用，需显式标记。</li>\n<li><strong>自动闭包（@autoclosure）</strong>：延迟求值，常用于断言、短路等场景。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-What-is-a-Closure\"><a href=\"#2-1-What-is-a-Closure\" class=\"headerlink\" title=\"2.1 What is a Closure?\"></a>2.1 What is a Closure?</h2><ul>\n<li>A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.</li>\n<li>Functions in Swift are special cases of closures.</li>\n<li>Closures can be assigned to variables, passed as parameters, and returned from functions.</li>\n</ul>\n<h2 id=\"2-2-Why-use-closures\"><a href=\"#2-2-Why-use-closures\" class=\"headerlink\" title=\"2.2 Why use closures?\"></a>2.2 Why use closures?</h2><ul>\n<li>Improve code reusability and flexibility, support functional programming.</li>\n<li>Used for callbacks, async handling, event response, etc.</li>\n<li>Capture context for state management and data flow.</li>\n</ul>\n<h2 id=\"2-3-Practical-Usage-Scenarios\"><a href=\"#2-3-Practical-Usage-Scenarios\" class=\"headerlink\" title=\"2.3 Practical Usage Scenarios\"></a>2.3 Practical Usage Scenarios</h2><ol>\n<li><strong>Async Callbacks</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Collection Operations</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Animation&#x2F;Event Handling</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Custom Sorting&#x2F;Filtering</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-4-Difference-from-Objective-C-Block\"><a href=\"#2-4-Difference-from-Objective-C-Block\" class=\"headerlink\" title=\"2.4 Difference from Objective-C Block\"></a>2.4 Difference from Objective-C Block</h2><ol>\n<li><strong>Syntax &amp; Type System</strong><ul>\n<li>Swift closures are more concise, with strong type inference.</li>\n<li>Block syntax is verbose, requires explicit type declaration.</li>\n</ul>\n</li>\n<li><strong>Memory Management</strong><ul>\n<li>Swift closures capture variables strongly by default; use <code>[weak self]</code>&#x2F;<code>[unowned self]</code> to avoid retain cycles.</li>\n<li>OC Blocks have global, stack, and heap types; use <code>__weak</code>&#x2F;<code>__block</code> for reference management.</li>\n</ul>\n</li>\n<li><strong>Capture Mechanism</strong><ul>\n<li>Swift closures automatically capture context variables.</li>\n<li>OC Blocks require <code>__block</code> to modify captured variables.</li>\n</ul>\n</li>\n<li><strong>Syntax Features</strong><ul>\n<li>Swift supports trailing closures, shorthand arguments, and type inference.</li>\n<li>OC Block syntax is fixed and less flexible.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-5-User-Experience-Business-Value\"><a href=\"#2-5-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.5 User Experience &amp; Business Value\"></a>2.5 User Experience &amp; Business Value</h2><ul>\n<li>Closures make APIs cleaner and easier to use, improving development efficiency.</li>\n<li>Enable reactive and chainable calls, enhancing product interactivity.</li>\n<li>Proper memory management avoids leaks and ensures app stability.</li>\n</ul>\n<h2 id=\"2-6-Debugging-Troubleshooting\"><a href=\"#2-6-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.6 Debugging &amp; Troubleshooting\"></a>2.6 Debugging &amp; Troubleshooting</h2><ul>\n<li>For memory leaks, check for retain cycles in closures and use <code>[weak self]</code> or <code>[unowned self]</code>.</li>\n<li>When debugging async callbacks, ensure closures capture and release context correctly.</li>\n<li>Compare Block and closure capture&#x2F;release mechanisms to choose the best fit for your scenario.</li>\n</ul>\n<h2 id=\"2-7-Related-Concepts\"><a href=\"#2-7-Related-Concepts\" class=\"headerlink\" title=\"2.7 Related Concepts\"></a>2.7 Related Concepts</h2><ul>\n<li><strong>Closure vs Block</strong>: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C’s function object implementation.</li>\n<li><strong>Escaping Closures (@escaping)</strong>: Closure is called after the function returns, must be marked explicitly.</li>\n<li><strong>Autoclosure (@autoclosure)</strong>: Delays evaluation, often used in assertions and short-circuiting.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>闭包（Closure）定义</strong></p>\n<ul>\n<li>闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。</li>\n<li>Swift 中的函数本质上也是特殊的闭包。</li>\n<li>闭包可作为变量、参数、返回值传递和使用。</li>\n</ul>\n</li>\n<li><p><strong>闭包的语法</strong></p>\n<ul>\n<li>基本语法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> closure <span class=\"operator\">=</span> &#123; (参数) -&gt; 返回类型 <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// 代码体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>支持类型推断、参数简写、尾随闭包等特性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要用闭包？\"><a href=\"#1-2-为什么要用闭包？\" class=\"headerlink\" title=\"1.2 为什么要用闭包？\"></a>1.2 为什么要用闭包？</h2><ul>\n<li>提升代码复用性和灵活性，支持函数式编程。</li>\n<li>可作为回调、异步处理、事件响应等，简化代码结构。</li>\n<li>捕获上下文变量，便于状态管理和数据流传递。</li>\n</ul>\n<h2 id=\"1-3-实际项目使用场景\"><a href=\"#1-3-实际项目使用场景\" class=\"headerlink\" title=\"1.3 实际项目使用场景\"></a>1.3 实际项目使用场景</h2><ol>\n<li><strong>异步回调</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求结束后回调</span></span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>集合操作</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125; <span class=\"comment\">// 闭包作为参数</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>动画、事件响应</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>自定义排序、过滤</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-4-与-Objective-C-中-Block-的区别\"><a href=\"#1-4-与-Objective-C-中-Block-的区别\" class=\"headerlink\" title=\"1.4 与 Objective-C 中 Block 的区别\"></a>1.4 与 Objective-C 中 Block 的区别</h2><ol>\n<li><strong>语法与类型系统</strong><ul>\n<li>Swift 闭包语法更简洁，类型推断更强。</li>\n<li>Block 语法繁琐，需显式声明参数和返回值类型。</li>\n</ul>\n</li>\n<li><strong>内存管理</strong><ul>\n<li>Swift 闭包默认捕获变量为强引用，需用 <code>[weak self]</code>&#x2F;<code>[unowned self]</code> 避免循环引用。</li>\n<li>OC Block 分为全局、栈、堆三种类型，需用 <code>__weak</code>&#x2F;<code>__block</code> 修饰符管理引用。</li>\n</ul>\n</li>\n<li><strong>捕获机制</strong><ul>\n<li>Swift 闭包自动捕获上下文变量。</li>\n<li>OC Block 需用 <code>__block</code> 修饰变量才能在 Block 内修改。</li>\n</ul>\n</li>\n<li><strong>语法特性</strong><ul>\n<li>Swift 支持尾随闭包、参数简写、自动推断。</li>\n<li>OC Block 语法固定，灵活性较低。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-5-用户体验与业务价值\"><a href=\"#1-5-用户体验与业务价值\" class=\"headerlink\" title=\"1.5 用户体验与业务价值\"></a>1.5 用户体验与业务价值</h2><ul>\n<li>闭包让 API 更加简洁、易用，提升开发效率。</li>\n<li>便于实现响应式、链式调用，提升产品交互体验。</li>\n<li>合理管理闭包内存，避免内存泄漏，保障 App 稳定性。</li>\n</ul>\n<h2 id=\"1-6-问题拆解与调试建议\"><a href=\"#1-6-问题拆解与调试建议\" class=\"headerlink\" title=\"1.6 问题拆解与调试建议\"></a>1.6 问题拆解与调试建议</h2><ul>\n<li>遇到内存泄漏，优先排查闭包的循环引用，使用 <code>[weak self]</code> 或 <code>[unowned self]</code>。</li>\n<li>调试异步回调时，关注闭包是否正确捕获和释放上下文。</li>\n<li>对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。</li>\n</ul>\n<h2 id=\"1-7-易混淆概念区分\"><a href=\"#1-7-易混淆概念区分\" class=\"headerlink\" title=\"1.7 易混淆概念区分\"></a>1.7 易混淆概念区分</h2><ul>\n<li><strong>闭包 vs Block</strong>：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。</li>\n<li><strong>逃逸闭包（@escaping）</strong>：闭包在函数返回后才被调用，需显式标记。</li>\n<li><strong>自动闭包（@autoclosure）</strong>：延迟求值，常用于断言、短路等场景。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-What-is-a-Closure\"><a href=\"#2-1-What-is-a-Closure\" class=\"headerlink\" title=\"2.1 What is a Closure?\"></a>2.1 What is a Closure?</h2><ul>\n<li>A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.</li>\n<li>Functions in Swift are special cases of closures.</li>\n<li>Closures can be assigned to variables, passed as parameters, and returned from functions.</li>\n</ul>\n<h2 id=\"2-2-Why-use-closures\"><a href=\"#2-2-Why-use-closures\" class=\"headerlink\" title=\"2.2 Why use closures?\"></a>2.2 Why use closures?</h2><ul>\n<li>Improve code reusability and flexibility, support functional programming.</li>\n<li>Used for callbacks, async handling, event response, etc.</li>\n<li>Capture context for state management and data flow.</li>\n</ul>\n<h2 id=\"2-3-Practical-Usage-Scenarios\"><a href=\"#2-3-Practical-Usage-Scenarios\" class=\"headerlink\" title=\"2.3 Practical Usage Scenarios\"></a>2.3 Practical Usage Scenarios</h2><ol>\n<li><strong>Async Callbacks</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Collection Operations</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Animation&#x2F;Event Handling</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Custom Sorting&#x2F;Filtering</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-4-Difference-from-Objective-C-Block\"><a href=\"#2-4-Difference-from-Objective-C-Block\" class=\"headerlink\" title=\"2.4 Difference from Objective-C Block\"></a>2.4 Difference from Objective-C Block</h2><ol>\n<li><strong>Syntax &amp; Type System</strong><ul>\n<li>Swift closures are more concise, with strong type inference.</li>\n<li>Block syntax is verbose, requires explicit type declaration.</li>\n</ul>\n</li>\n<li><strong>Memory Management</strong><ul>\n<li>Swift closures capture variables strongly by default; use <code>[weak self]</code>&#x2F;<code>[unowned self]</code> to avoid retain cycles.</li>\n<li>OC Blocks have global, stack, and heap types; use <code>__weak</code>&#x2F;<code>__block</code> for reference management.</li>\n</ul>\n</li>\n<li><strong>Capture Mechanism</strong><ul>\n<li>Swift closures automatically capture context variables.</li>\n<li>OC Blocks require <code>__block</code> to modify captured variables.</li>\n</ul>\n</li>\n<li><strong>Syntax Features</strong><ul>\n<li>Swift supports trailing closures, shorthand arguments, and type inference.</li>\n<li>OC Block syntax is fixed and less flexible.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-5-User-Experience-Business-Value\"><a href=\"#2-5-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.5 User Experience &amp; Business Value\"></a>2.5 User Experience &amp; Business Value</h2><ul>\n<li>Closures make APIs cleaner and easier to use, improving development efficiency.</li>\n<li>Enable reactive and chainable calls, enhancing product interactivity.</li>\n<li>Proper memory management avoids leaks and ensures app stability.</li>\n</ul>\n<h2 id=\"2-6-Debugging-Troubleshooting\"><a href=\"#2-6-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.6 Debugging &amp; Troubleshooting\"></a>2.6 Debugging &amp; Troubleshooting</h2><ul>\n<li>For memory leaks, check for retain cycles in closures and use <code>[weak self]</code> or <code>[unowned self]</code>.</li>\n<li>When debugging async callbacks, ensure closures capture and release context correctly.</li>\n<li>Compare Block and closure capture&#x2F;release mechanisms to choose the best fit for your scenario.</li>\n</ul>\n<h2 id=\"2-7-Related-Concepts\"><a href=\"#2-7-Related-Concepts\" class=\"headerlink\" title=\"2.7 Related Concepts\"></a>2.7 Related Concepts</h2><ul>\n<li><strong>Closure vs Block</strong>: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C’s function object implementation.</li>\n<li><strong>Escaping Closures (@escaping)</strong>: Closure is called after the function returns, must be marked explicitly.</li>\n<li><strong>Autoclosure (@autoclosure)</strong>: Delays evaluation, often used in assertions and short-circuiting.</li>\n</ul>\n"},{"title":"Open-Public-Internal-File-private-Private权限修饰符详解","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\nSwift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：\n\n1. **open**\n   - 最高级别，仅适用于类和类成员。\n   - 允许在模块外被继承和重写。\n   - 典型场景：第三方库/框架对外暴露可扩展 API。\n   - 例：\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - 允许在模块外访问，但不能被继承或重写。\n   - 适合对外暴露 API，但不希望被扩展。\n   - 例：\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal**（默认）\n   - 仅在同一模块内可见，模块外不可访问。\n   - 适合项目内部逻辑，默认不写就是 internal。\n   - 例：\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - 仅在当前 Swift 文件内可见。\n   - 适合同文件内多个类型协作，隐藏实现细节。\n   - 例：\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - 仅在当前声明作用域（如类/结构体/扩展）内可见。\n   - 适合封装最细粒度的实现细节。\n   - 例：\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 1.2 为什么要这样设计？\n- 提高代码安全性，防止外部误用或依赖内部实现。\n- 明确 API 边界，便于团队协作和模块解耦。\n- 支持灵活的封装和扩展策略。\n\n## 1.3 实际项目代码示例\n```swift\n// FrameworkA\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 1.4 用户体验与业务价值\n- 合理使用访问控制，API 更安全、易用，减少误用和维护成本。\n- 便于团队分工，隐藏实现细节，提升代码可维护性。\n\n## 1.5 问题拆解与调试建议\n- 如果外部无法访问某成员，优先检查访问修饰符。\n- 框架开发时，优先用 public，需支持继承/重写时用 open。\n- 内部工具类、辅助方法建议用 internal、fileprivate 或 private。\n\n## 1.6 易混淆点与对比\n- **open vs public**：open 可被继承/重写，public 只能访问不能继承。\n- **fileprivate vs private**：fileprivate 跨类型同文件可见，private 仅限当前作用域。\n- **internal** 是默认级别，不写就是 internal。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts & Principles\nSwift provides five access control levels to manage the visibility and accessibility of entities:\n\n1. **open**\n   - Highest level, only for classes and class members.\n   - Can be subclassed/overridden outside the module.\n   - Example:\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - Accessible outside the module, but cannot be subclassed/overridden.\n   - Example:\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal** (default)\n   - Accessible only within the same module.\n   - Example:\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - Accessible only within the same Swift file.\n   - Example:\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - Accessible only within the enclosing declaration.\n   - Example:\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 2.2 Why this design?\n- Improves code safety, prevents misuse, and clarifies API boundaries.\n- Facilitates team collaboration and modularization.\n- Supports flexible encapsulation and extension strategies.\n\n## 2.3 Practical Example\n```swift\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 2.4 User Experience & Business Value\n- Proper access control makes APIs safer and easier to use, reducing maintenance costs.\n- Hides implementation details, improving maintainability and team collaboration.\n\n## 2.5 Debugging & Troubleshooting\n- If a member is inaccessible, check its access modifier first.\n- Use public for APIs, open for extensible frameworks, internal/fileprivate/private for internal logic.\n\n## 2.6 Key Distinctions\n- **open vs public**: open allows subclassing/overriding, public does not.\n- **fileprivate vs private**: fileprivate is visible within the same file, private only within the enclosing scope.\n- **internal** is the default level.\n","source":"_posts/iOS/Open-Public-Internal关键字.md","raw":"---\ntitle: Open-Public-Internal-File-private-Private权限修饰符详解\ndate: 2025-07-08\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\nSwift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：\n\n1. **open**\n   - 最高级别，仅适用于类和类成员。\n   - 允许在模块外被继承和重写。\n   - 典型场景：第三方库/框架对外暴露可扩展 API。\n   - 例：\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - 允许在模块外访问，但不能被继承或重写。\n   - 适合对外暴露 API，但不希望被扩展。\n   - 例：\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal**（默认）\n   - 仅在同一模块内可见，模块外不可访问。\n   - 适合项目内部逻辑，默认不写就是 internal。\n   - 例：\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - 仅在当前 Swift 文件内可见。\n   - 适合同文件内多个类型协作，隐藏实现细节。\n   - 例：\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - 仅在当前声明作用域（如类/结构体/扩展）内可见。\n   - 适合封装最细粒度的实现细节。\n   - 例：\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 1.2 为什么要这样设计？\n- 提高代码安全性，防止外部误用或依赖内部实现。\n- 明确 API 边界，便于团队协作和模块解耦。\n- 支持灵活的封装和扩展策略。\n\n## 1.3 实际项目代码示例\n```swift\n// FrameworkA\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 1.4 用户体验与业务价值\n- 合理使用访问控制，API 更安全、易用，减少误用和维护成本。\n- 便于团队分工，隐藏实现细节，提升代码可维护性。\n\n## 1.5 问题拆解与调试建议\n- 如果外部无法访问某成员，优先检查访问修饰符。\n- 框架开发时，优先用 public，需支持继承/重写时用 open。\n- 内部工具类、辅助方法建议用 internal、fileprivate 或 private。\n\n## 1.6 易混淆点与对比\n- **open vs public**：open 可被继承/重写，public 只能访问不能继承。\n- **fileprivate vs private**：fileprivate 跨类型同文件可见，private 仅限当前作用域。\n- **internal** 是默认级别，不写就是 internal。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts & Principles\nSwift provides five access control levels to manage the visibility and accessibility of entities:\n\n1. **open**\n   - Highest level, only for classes and class members.\n   - Can be subclassed/overridden outside the module.\n   - Example:\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - Accessible outside the module, but cannot be subclassed/overridden.\n   - Example:\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal** (default)\n   - Accessible only within the same module.\n   - Example:\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - Accessible only within the same Swift file.\n   - Example:\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - Accessible only within the enclosing declaration.\n   - Example:\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 2.2 Why this design?\n- Improves code safety, prevents misuse, and clarifies API boundaries.\n- Facilitates team collaboration and modularization.\n- Supports flexible encapsulation and extension strategies.\n\n## 2.3 Practical Example\n```swift\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 2.4 User Experience & Business Value\n- Proper access control makes APIs safer and easier to use, reducing maintenance costs.\n- Hides implementation details, improving maintainability and team collaboration.\n\n## 2.5 Debugging & Troubleshooting\n- If a member is inaccessible, check its access modifier first.\n- Use public for APIs, open for extensible frameworks, internal/fileprivate/private for internal logic.\n\n## 2.6 Key Distinctions\n- **open vs public**: open allows subclassing/overriding, public does not.\n- **fileprivate vs private**: fileprivate is visible within the same file, private only within the enclosing scope.\n- **internal** is the default level.\n","slug":"iOS/Open-Public-Internal关键字","published":1,"updated":"2025-07-08T07:06:35.284Z","comments":1,"layout":"post","photos":[],"_id":"cmcu74t560003d9k7amap0tmx","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p>Swift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>最高级别，仅适用于类和类成员。</li>\n<li>允许在模块外被继承和重写。</li>\n<li>典型场景：第三方库&#x2F;框架对外暴露可扩展 API。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>允许在模块外访问，但不能被继承或重写。</li>\n<li>适合对外暴露 API，但不希望被扩展。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong>（默认）</p>\n<ul>\n<li>仅在同一模块内可见，模块外不可访问。</li>\n<li>适合项目内部逻辑，默认不写就是 internal。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>仅在当前 Swift 文件内可见。</li>\n<li>适合同文件内多个类型协作，隐藏实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>仅在当前声明作用域（如类&#x2F;结构体&#x2F;扩展）内可见。</li>\n<li>适合封装最细粒度的实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>提高代码安全性，防止外部误用或依赖内部实现。</li>\n<li>明确 API 边界，便于团队协作和模块解耦。</li>\n<li>支持灵活的封装和扩展策略。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FrameworkA</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>合理使用访问控制，API 更安全、易用，减少误用和维护成本。</li>\n<li>便于团队分工，隐藏实现细节，提升代码可维护性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果外部无法访问某成员，优先检查访问修饰符。</li>\n<li>框架开发时，优先用 public，需支持继承&#x2F;重写时用 open。</li>\n<li>内部工具类、辅助方法建议用 internal、fileprivate 或 private。</li>\n</ul>\n<h2 id=\"1-6-易混淆点与对比\"><a href=\"#1-6-易混淆点与对比\" class=\"headerlink\" title=\"1.6 易混淆点与对比\"></a>1.6 易混淆点与对比</h2><ul>\n<li><strong>open vs public</strong>：open 可被继承&#x2F;重写，public 只能访问不能继承。</li>\n<li><strong>fileprivate vs private</strong>：fileprivate 跨类型同文件可见，private 仅限当前作用域。</li>\n<li><strong>internal</strong> 是默认级别，不写就是 internal。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts-Principles\"><a href=\"#2-1-Concepts-Principles\" class=\"headerlink\" title=\"2.1 Concepts &amp; Principles\"></a>2.1 Concepts &amp; Principles</h2><p>Swift provides five access control levels to manage the visibility and accessibility of entities:</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>Highest level, only for classes and class members.</li>\n<li>Can be subclassed&#x2F;overridden outside the module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>Accessible outside the module, but cannot be subclassed&#x2F;overridden.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong> (default)</p>\n<ul>\n<li>Accessible only within the same module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>Accessible only within the same Swift file.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>Accessible only within the enclosing declaration.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Improves code safety, prevents misuse, and clarifies API boundaries.</li>\n<li>Facilitates team collaboration and modularization.</li>\n<li>Supports flexible encapsulation and extension strategies.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Proper access control makes APIs safer and easier to use, reducing maintenance costs.</li>\n<li>Hides implementation details, improving maintainability and team collaboration.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If a member is inaccessible, check its access modifier first.</li>\n<li>Use public for APIs, open for extensible frameworks, internal&#x2F;fileprivate&#x2F;private for internal logic.</li>\n</ul>\n<h2 id=\"2-6-Key-Distinctions\"><a href=\"#2-6-Key-Distinctions\" class=\"headerlink\" title=\"2.6 Key Distinctions\"></a>2.6 Key Distinctions</h2><ul>\n<li><strong>open vs public</strong>: open allows subclassing&#x2F;overriding, public does not.</li>\n<li><strong>fileprivate vs private</strong>: fileprivate is visible within the same file, private only within the enclosing scope.</li>\n<li><strong>internal</strong> is the default level.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p>Swift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>最高级别，仅适用于类和类成员。</li>\n<li>允许在模块外被继承和重写。</li>\n<li>典型场景：第三方库&#x2F;框架对外暴露可扩展 API。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>允许在模块外访问，但不能被继承或重写。</li>\n<li>适合对外暴露 API，但不希望被扩展。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong>（默认）</p>\n<ul>\n<li>仅在同一模块内可见，模块外不可访问。</li>\n<li>适合项目内部逻辑，默认不写就是 internal。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>仅在当前 Swift 文件内可见。</li>\n<li>适合同文件内多个类型协作，隐藏实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>仅在当前声明作用域（如类&#x2F;结构体&#x2F;扩展）内可见。</li>\n<li>适合封装最细粒度的实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>提高代码安全性，防止外部误用或依赖内部实现。</li>\n<li>明确 API 边界，便于团队协作和模块解耦。</li>\n<li>支持灵活的封装和扩展策略。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FrameworkA</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>合理使用访问控制，API 更安全、易用，减少误用和维护成本。</li>\n<li>便于团队分工，隐藏实现细节，提升代码可维护性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果外部无法访问某成员，优先检查访问修饰符。</li>\n<li>框架开发时，优先用 public，需支持继承&#x2F;重写时用 open。</li>\n<li>内部工具类、辅助方法建议用 internal、fileprivate 或 private。</li>\n</ul>\n<h2 id=\"1-6-易混淆点与对比\"><a href=\"#1-6-易混淆点与对比\" class=\"headerlink\" title=\"1.6 易混淆点与对比\"></a>1.6 易混淆点与对比</h2><ul>\n<li><strong>open vs public</strong>：open 可被继承&#x2F;重写，public 只能访问不能继承。</li>\n<li><strong>fileprivate vs private</strong>：fileprivate 跨类型同文件可见，private 仅限当前作用域。</li>\n<li><strong>internal</strong> 是默认级别，不写就是 internal。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts-Principles\"><a href=\"#2-1-Concepts-Principles\" class=\"headerlink\" title=\"2.1 Concepts &amp; Principles\"></a>2.1 Concepts &amp; Principles</h2><p>Swift provides five access control levels to manage the visibility and accessibility of entities:</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>Highest level, only for classes and class members.</li>\n<li>Can be subclassed&#x2F;overridden outside the module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>Accessible outside the module, but cannot be subclassed&#x2F;overridden.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong> (default)</p>\n<ul>\n<li>Accessible only within the same module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>Accessible only within the same Swift file.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>Accessible only within the enclosing declaration.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Improves code safety, prevents misuse, and clarifies API boundaries.</li>\n<li>Facilitates team collaboration and modularization.</li>\n<li>Supports flexible encapsulation and extension strategies.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Proper access control makes APIs safer and easier to use, reducing maintenance costs.</li>\n<li>Hides implementation details, improving maintainability and team collaboration.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If a member is inaccessible, check its access modifier first.</li>\n<li>Use public for APIs, open for extensible frameworks, internal&#x2F;fileprivate&#x2F;private for internal logic.</li>\n</ul>\n<h2 id=\"2-6-Key-Distinctions\"><a href=\"#2-6-Key-Distinctions\" class=\"headerlink\" title=\"2.6 Key Distinctions\"></a>2.6 Key Distinctions</h2><ul>\n<li><strong>open vs public</strong>: open allows subclassing&#x2F;overriding, public does not.</li>\n<li><strong>fileprivate vs private</strong>: fileprivate is visible within the same file, private only within the enclosing scope.</li>\n<li><strong>internal</strong> is the default level.</li>\n</ul>\n"},{"title":"存储属性和计算属性的区别","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **存储属性（Stored Property）**\n   - 直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。\n   - 语法：`var` 或 `let` 声明，系统自动分配内存。\n   - 例：\n     ```swift\n     struct User {\n         var name: String // 存储属性\n         let id: Int      // 存储属性\n     }\n     ```\n\n2. **计算属性（Computed Property）**\n   - 不直接存储值，而是通过 getter（和可选的 setter）动态计算。\n   - 每次访问时都会执行代码逻辑，通常依赖其他属性。\n   - 语法：必须有 `get`，可选 `set`。\n   - 例：\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // 计算属性\n             get { width * height }\n         }\n     }\n     ```\n\n## 1.2 为什么要区分？\n- 存储属性用于保存实际数据，适合需要持久化的状态。\n- 计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Product {\n    var price: Double      // 存储属性\n    var quantity: Int      // 存储属性\n    var total: Double {    // 计算属性\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // 输出 30\n```\n\n## 1.4 用户体验与业务价值\n- 存储属性保证数据一致性和性能，适合频繁读写。\n- 计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。\n\n## 1.5 问题拆解与调试建议\n- 如果属性只依赖其他属性且无需持久化，优先用计算属性。\n- 若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。\n- 调试时关注 getter/setter 是否有副作用，避免死循环或性能问题。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts\n1. **Stored Property**\n   - Stores actual data in memory for each instance.\n   - Declared with `var` or `let`.\n   - Example:\n     ```swift\n     struct User {\n         var name: String // stored property\n         let id: Int      // stored property\n     }\n     ```\n\n2. **Computed Property**\n   - Does not store a value; computes it on access via `get` (and optionally `set`).\n   - Example:\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // computed property\n             get { width * height }\n         }\n     }\n     ```\n\n## 2.2 Why distinguish?\n- Stored properties are for persistent state.\n- Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.\n\n## 2.3 Practical Example\n```swift\nstruct Product {\n    var price: Double      // stored property\n    var quantity: Int      // stored property\n    var total: Double {    // computed property\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // prints 30\n```\n\n## 2.4 User Experience & Business Value\n- Stored properties ensure data consistency and performance.\n- Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.\n\n## 2.5 Debugging & Optimization\n- Use computed properties for logic based on other properties.\n- Cache computed values as stored properties if performance is critical.\n- Watch for side effects in getters/setters to avoid infinite loops or performance issues.\n","source":"_posts/iOS/存储属性和计算属性的区别.md","raw":"---\ntitle: 存储属性和计算属性的区别\ndate: 2025-07-08\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **存储属性（Stored Property）**\n   - 直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。\n   - 语法：`var` 或 `let` 声明，系统自动分配内存。\n   - 例：\n     ```swift\n     struct User {\n         var name: String // 存储属性\n         let id: Int      // 存储属性\n     }\n     ```\n\n2. **计算属性（Computed Property）**\n   - 不直接存储值，而是通过 getter（和可选的 setter）动态计算。\n   - 每次访问时都会执行代码逻辑，通常依赖其他属性。\n   - 语法：必须有 `get`，可选 `set`。\n   - 例：\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // 计算属性\n             get { width * height }\n         }\n     }\n     ```\n\n## 1.2 为什么要区分？\n- 存储属性用于保存实际数据，适合需要持久化的状态。\n- 计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Product {\n    var price: Double      // 存储属性\n    var quantity: Int      // 存储属性\n    var total: Double {    // 计算属性\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // 输出 30\n```\n\n## 1.4 用户体验与业务价值\n- 存储属性保证数据一致性和性能，适合频繁读写。\n- 计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。\n\n## 1.5 问题拆解与调试建议\n- 如果属性只依赖其他属性且无需持久化，优先用计算属性。\n- 若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。\n- 调试时关注 getter/setter 是否有副作用，避免死循环或性能问题。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts\n1. **Stored Property**\n   - Stores actual data in memory for each instance.\n   - Declared with `var` or `let`.\n   - Example:\n     ```swift\n     struct User {\n         var name: String // stored property\n         let id: Int      // stored property\n     }\n     ```\n\n2. **Computed Property**\n   - Does not store a value; computes it on access via `get` (and optionally `set`).\n   - Example:\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // computed property\n             get { width * height }\n         }\n     }\n     ```\n\n## 2.2 Why distinguish?\n- Stored properties are for persistent state.\n- Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.\n\n## 2.3 Practical Example\n```swift\nstruct Product {\n    var price: Double      // stored property\n    var quantity: Int      // stored property\n    var total: Double {    // computed property\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // prints 30\n```\n\n## 2.4 User Experience & Business Value\n- Stored properties ensure data consistency and performance.\n- Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.\n\n## 2.5 Debugging & Optimization\n- Use computed properties for logic based on other properties.\n- Cache computed values as stored properties if performance is critical.\n- Watch for side effects in getters/setters to avoid infinite loops or performance issues.\n","slug":"iOS/存储属性和计算属性的区别","published":1,"updated":"2025-07-08T07:06:35.263Z","comments":1,"layout":"post","photos":[],"_id":"cmcu74t560004d9k7gpszb7rk","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>存储属性（Stored Property）</strong></p>\n<ul>\n<li>直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。</li>\n<li>语法：<code>var</code> 或 <code>let</code> 声明，系统自动分配内存。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>计算属性（Computed Property）</strong></p>\n<ul>\n<li>不直接存储值，而是通过 getter（和可选的 setter）动态计算。</li>\n<li>每次访问时都会执行代码逻辑，通常依赖其他属性。</li>\n<li>语法：必须有 <code>get</code>，可选 <code>set</code>。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要区分？\"><a href=\"#1-2-为什么要区分？\" class=\"headerlink\" title=\"1.2 为什么要区分？\"></a>1.2 为什么要区分？</h2><ul>\n<li>存储属性用于保存实际数据，适合需要持久化的状态。</li>\n<li>计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// 输出 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>存储属性保证数据一致性和性能，适合频繁读写。</li>\n<li>计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果属性只依赖其他属性且无需持久化，优先用计算属性。</li>\n<li>若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。</li>\n<li>调试时关注 getter&#x2F;setter 是否有副作用，避免死循环或性能问题。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts\"><a href=\"#2-1-Concepts\" class=\"headerlink\" title=\"2.1 Concepts\"></a>2.1 Concepts</h2><ol>\n<li><p><strong>Stored Property</strong></p>\n<ul>\n<li>Stores actual data in memory for each instance.</li>\n<li>Declared with <code>var</code> or <code>let</code>.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>Computed Property</strong></p>\n<ul>\n<li>Does not store a value; computes it on access via <code>get</code> (and optionally <code>set</code>).</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-distinguish\"><a href=\"#2-2-Why-distinguish\" class=\"headerlink\" title=\"2.2 Why distinguish?\"></a>2.2 Why distinguish?</h2><ul>\n<li>Stored properties are for persistent state.</li>\n<li>Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// prints 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Stored properties ensure data consistency and performance.</li>\n<li>Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Optimization\"><a href=\"#2-5-Debugging-Optimization\" class=\"headerlink\" title=\"2.5 Debugging &amp; Optimization\"></a>2.5 Debugging &amp; Optimization</h2><ul>\n<li>Use computed properties for logic based on other properties.</li>\n<li>Cache computed values as stored properties if performance is critical.</li>\n<li>Watch for side effects in getters&#x2F;setters to avoid infinite loops or performance issues.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>存储属性（Stored Property）</strong></p>\n<ul>\n<li>直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。</li>\n<li>语法：<code>var</code> 或 <code>let</code> 声明，系统自动分配内存。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>计算属性（Computed Property）</strong></p>\n<ul>\n<li>不直接存储值，而是通过 getter（和可选的 setter）动态计算。</li>\n<li>每次访问时都会执行代码逻辑，通常依赖其他属性。</li>\n<li>语法：必须有 <code>get</code>，可选 <code>set</code>。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要区分？\"><a href=\"#1-2-为什么要区分？\" class=\"headerlink\" title=\"1.2 为什么要区分？\"></a>1.2 为什么要区分？</h2><ul>\n<li>存储属性用于保存实际数据，适合需要持久化的状态。</li>\n<li>计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// 输出 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>存储属性保证数据一致性和性能，适合频繁读写。</li>\n<li>计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果属性只依赖其他属性且无需持久化，优先用计算属性。</li>\n<li>若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。</li>\n<li>调试时关注 getter&#x2F;setter 是否有副作用，避免死循环或性能问题。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts\"><a href=\"#2-1-Concepts\" class=\"headerlink\" title=\"2.1 Concepts\"></a>2.1 Concepts</h2><ol>\n<li><p><strong>Stored Property</strong></p>\n<ul>\n<li>Stores actual data in memory for each instance.</li>\n<li>Declared with <code>var</code> or <code>let</code>.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>Computed Property</strong></p>\n<ul>\n<li>Does not store a value; computes it on access via <code>get</code> (and optionally <code>set</code>).</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-distinguish\"><a href=\"#2-2-Why-distinguish\" class=\"headerlink\" title=\"2.2 Why distinguish?\"></a>2.2 Why distinguish?</h2><ul>\n<li>Stored properties are for persistent state.</li>\n<li>Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// prints 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Stored properties ensure data consistency and performance.</li>\n<li>Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Optimization\"><a href=\"#2-5-Debugging-Optimization\" class=\"headerlink\" title=\"2.5 Debugging &amp; Optimization\"></a>2.5 Debugging &amp; Optimization</h2><ul>\n<li>Use computed properties for logic based on other properties.</li>\n<li>Cache computed values as stored properties if performance is critical.</li>\n<li>Watch for side effects in getters&#x2F;setters to avoid infinite loops or performance issues.</li>\n</ul>\n"},{"title":"mutating关键字的作用","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **mutating 关键字**\n   - 用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。\n   - 表示该方法内部可以修改实例自身的属性或自身（即 self ）。\n   - 结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。\n\n## 1.2 为什么需要 mutating？\n- Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。\n- 只有明确声明 mutating，才允许方法内部修改属性或赋值 self。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1 // 允许修改属性\n    }\n    mutating func reset() {\n        self = Counter() // 允许重新赋值 self\n    }\n}\n\nvar c = Counter()\nc.increment() // value 变为 1\nc.reset()     // value 变为 0\n```\n\n## 1.4 用户体验与业务价值\n- 明确哪些方法会修改数据，便于团队协作和代码维护。\n- 避免无意副作用，提升代码健壮性。\n\n## 1.5 问题拆解与调试建议\n- 如果 struct 方法需要修改属性但未加 mutating，编译器会报错。\n- 调试时优先检查 mutating 关键字是否遗漏。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concept\n- The `mutating` keyword in Swift is used in methods of structs and enums.\n- It allows the method to modify properties of `self` or assign a new value to `self`.\n- By default, value types (struct/enum) methods cannot modify their own properties unless marked as `mutating`.\n\n## 2.2 Why is it needed?\n- Swift enforces immutability for value types by default for safety.\n- Only methods explicitly marked as `mutating` can change the instance's state.\n\n## 2.3 Practical Example\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1\n    }\n    mutating func reset() {\n        self = Counter()\n    }\n}\n\nvar c = Counter()\nc.increment() // value becomes 1\nc.reset()     // value becomes 0\n```\n\n## 2.4 User Experience & Business Value\n- Makes code intent clear, improves team collaboration and maintainability.\n- Prevents unintended side effects, increasing code robustness.\n\n## 2.5 Debugging & Troubleshooting\n- If you need to modify a property in a struct method but forget `mutating`, the compiler will throw an error.\n- Always check for missing `mutating` if you see such errors.\n","source":"_posts/iOS/mutating关键字的作用.md","raw":"---\ntitle: mutating关键字的作用\ndate: 2025-07-08\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **mutating 关键字**\n   - 用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。\n   - 表示该方法内部可以修改实例自身的属性或自身（即 self ）。\n   - 结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。\n\n## 1.2 为什么需要 mutating？\n- Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。\n- 只有明确声明 mutating，才允许方法内部修改属性或赋值 self。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1 // 允许修改属性\n    }\n    mutating func reset() {\n        self = Counter() // 允许重新赋值 self\n    }\n}\n\nvar c = Counter()\nc.increment() // value 变为 1\nc.reset()     // value 变为 0\n```\n\n## 1.4 用户体验与业务价值\n- 明确哪些方法会修改数据，便于团队协作和代码维护。\n- 避免无意副作用，提升代码健壮性。\n\n## 1.5 问题拆解与调试建议\n- 如果 struct 方法需要修改属性但未加 mutating，编译器会报错。\n- 调试时优先检查 mutating 关键字是否遗漏。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concept\n- The `mutating` keyword in Swift is used in methods of structs and enums.\n- It allows the method to modify properties of `self` or assign a new value to `self`.\n- By default, value types (struct/enum) methods cannot modify their own properties unless marked as `mutating`.\n\n## 2.2 Why is it needed?\n- Swift enforces immutability for value types by default for safety.\n- Only methods explicitly marked as `mutating` can change the instance's state.\n\n## 2.3 Practical Example\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1\n    }\n    mutating func reset() {\n        self = Counter()\n    }\n}\n\nvar c = Counter()\nc.increment() // value becomes 1\nc.reset()     // value becomes 0\n```\n\n## 2.4 User Experience & Business Value\n- Makes code intent clear, improves team collaboration and maintainability.\n- Prevents unintended side effects, increasing code robustness.\n\n## 2.5 Debugging & Troubleshooting\n- If you need to modify a property in a struct method but forget `mutating`, the compiler will throw an error.\n- Always check for missing `mutating` if you see such errors.\n","slug":"iOS/mutating关键字的作用","published":1,"updated":"2025-07-08T07:06:35.281Z","comments":1,"layout":"post","photos":[],"_id":"cmcu74t570005d9k729hocev7","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><strong>mutating 关键字</strong><ul>\n<li>用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。</li>\n<li>表示该方法内部可以修改实例自身的属性或自身（即 self ）。</li>\n<li>结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么需要-mutating？\"><a href=\"#1-2-为什么需要-mutating？\" class=\"headerlink\" title=\"1.2 为什么需要 mutating？\"></a>1.2 为什么需要 mutating？</h2><ul>\n<li>Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。</li>\n<li>只有明确声明 mutating，才允许方法内部修改属性或赋值 self。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span> <span class=\"comment\">// 允许修改属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>() <span class=\"comment\">// 允许重新赋值 self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value 变为 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value 变为 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>明确哪些方法会修改数据，便于团队协作和代码维护。</li>\n<li>避免无意副作用，提升代码健壮性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果 struct 方法需要修改属性但未加 mutating，编译器会报错。</li>\n<li>调试时优先检查 mutating 关键字是否遗漏。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ul>\n<li>The <code>mutating</code> keyword in Swift is used in methods of structs and enums.</li>\n<li>It allows the method to modify properties of <code>self</code> or assign a new value to <code>self</code>.</li>\n<li>By default, value types (struct&#x2F;enum) methods cannot modify their own properties unless marked as <code>mutating</code>.</li>\n</ul>\n<h2 id=\"2-2-Why-is-it-needed\"><a href=\"#2-2-Why-is-it-needed\" class=\"headerlink\" title=\"2.2 Why is it needed?\"></a>2.2 Why is it needed?</h2><ul>\n<li>Swift enforces immutability for value types by default for safety.</li>\n<li>Only methods explicitly marked as <code>mutating</code> can change the instance’s state.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value becomes 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value becomes 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Makes code intent clear, improves team collaboration and maintainability.</li>\n<li>Prevents unintended side effects, increasing code robustness.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If you need to modify a property in a struct method but forget <code>mutating</code>, the compiler will throw an error.</li>\n<li>Always check for missing <code>mutating</code> if you see such errors.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><strong>mutating 关键字</strong><ul>\n<li>用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。</li>\n<li>表示该方法内部可以修改实例自身的属性或自身（即 self ）。</li>\n<li>结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么需要-mutating？\"><a href=\"#1-2-为什么需要-mutating？\" class=\"headerlink\" title=\"1.2 为什么需要 mutating？\"></a>1.2 为什么需要 mutating？</h2><ul>\n<li>Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。</li>\n<li>只有明确声明 mutating，才允许方法内部修改属性或赋值 self。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span> <span class=\"comment\">// 允许修改属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>() <span class=\"comment\">// 允许重新赋值 self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value 变为 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value 变为 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>明确哪些方法会修改数据，便于团队协作和代码维护。</li>\n<li>避免无意副作用，提升代码健壮性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果 struct 方法需要修改属性但未加 mutating，编译器会报错。</li>\n<li>调试时优先检查 mutating 关键字是否遗漏。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ul>\n<li>The <code>mutating</code> keyword in Swift is used in methods of structs and enums.</li>\n<li>It allows the method to modify properties of <code>self</code> or assign a new value to <code>self</code>.</li>\n<li>By default, value types (struct&#x2F;enum) methods cannot modify their own properties unless marked as <code>mutating</code>.</li>\n</ul>\n<h2 id=\"2-2-Why-is-it-needed\"><a href=\"#2-2-Why-is-it-needed\" class=\"headerlink\" title=\"2.2 Why is it needed?\"></a>2.2 Why is it needed?</h2><ul>\n<li>Swift enforces immutability for value types by default for safety.</li>\n<li>Only methods explicitly marked as <code>mutating</code> can change the instance’s state.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value becomes 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value becomes 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Makes code intent clear, improves team collaboration and maintainability.</li>\n<li>Prevents unintended side effects, increasing code robustness.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If you need to modify a property in a struct method but forget <code>mutating</code>, the compiler will throw an error.</li>\n<li>Always check for missing <code>mutating</code> if you see such errors.</li>\n</ul>\n"},{"title":"泛型（Generics）","date":"2025-07-01T16:00:00.000Z","_content":"\n# 在 Swift 中，什么是泛型（Generics）？\n\n## 1. 概念与原理\n\n1.1 定义  \n泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。\n\n1.2 为什么需要泛型  \n- **代码复用**：避免重复实现相似逻辑。\n- **类型安全**：在编译期检查类型，减少运行时错误。\n- **灵活性**：支持多种数据类型，提升 API 设计的通用性。\n\n1.3 原理简述  \nSwift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。\n\n## 2. 语法与实现\n\n2.1 基本语法\n```swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temp = a\n    a = b\n    b = temp\n}\n```\n- `T` 是类型占位符，调用时由编译器推断。\n\n2.2 泛型类型\n```swift\nstruct Stack<Element> {\n    private var items = [Element]()\n    mutating func push(_ item: Element) { items.append(item) }\n    mutating func pop() -> Element? { items.popLast() }\n}\n```\n- `Element` 可为任意类型，提升了数据结构的通用性。\n\n2.3 泛型约束\n```swift\nfunc findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {\n    for (index, item) in array.enumerated() {\n        if item == value { return index }\n    }\n    return nil\n}\n```\n- 通过 `T: Equatable` 限定泛型类型必须实现等值比较。\n\n## 3. 实际项目中的应用场景\n\n3.1 网络层数据解析\n- 利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。\n```swift\nprotocol DecodableModel: Decodable {}\n\nfunc fetchData<T: DecodableModel>(from url: URL, completion: @escaping (Result<T, Error>) -> Void) {\n    // 网络请求与解析逻辑\n}\n```\n\n3.2 组件化 UI 设计\n- 通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。\n\n## 4. 用户体验与业务需求的结合\n- 泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。\n- 便于团队维护和扩展，降低后期 bug 率。\n- 通过类型安全，减少因类型不匹配导致的用户端崩溃。\n\n## 5. Debug 与排查能力\n\n5.1 常见问题\n- 泛型类型推断失败：需显式指定类型或增加约束。\n- 复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。\n\n5.2 排查流程\n- 检查泛型约束是否合理。\n- 利用 Xcode 的类型推断提示，定位类型不匹配点。\n- 通过单元测试覆盖泛型逻辑，及时发现边界问题。\n\n## 6. 总结\n泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。\n","source":"_posts/iOS/泛型Generics.md","raw":"---\ntitle: 泛型（Generics）\ndate: 2025-07-02\n---\n\n# 在 Swift 中，什么是泛型（Generics）？\n\n## 1. 概念与原理\n\n1.1 定义  \n泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。\n\n1.2 为什么需要泛型  \n- **代码复用**：避免重复实现相似逻辑。\n- **类型安全**：在编译期检查类型，减少运行时错误。\n- **灵活性**：支持多种数据类型，提升 API 设计的通用性。\n\n1.3 原理简述  \nSwift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。\n\n## 2. 语法与实现\n\n2.1 基本语法\n```swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temp = a\n    a = b\n    b = temp\n}\n```\n- `T` 是类型占位符，调用时由编译器推断。\n\n2.2 泛型类型\n```swift\nstruct Stack<Element> {\n    private var items = [Element]()\n    mutating func push(_ item: Element) { items.append(item) }\n    mutating func pop() -> Element? { items.popLast() }\n}\n```\n- `Element` 可为任意类型，提升了数据结构的通用性。\n\n2.3 泛型约束\n```swift\nfunc findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {\n    for (index, item) in array.enumerated() {\n        if item == value { return index }\n    }\n    return nil\n}\n```\n- 通过 `T: Equatable` 限定泛型类型必须实现等值比较。\n\n## 3. 实际项目中的应用场景\n\n3.1 网络层数据解析\n- 利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。\n```swift\nprotocol DecodableModel: Decodable {}\n\nfunc fetchData<T: DecodableModel>(from url: URL, completion: @escaping (Result<T, Error>) -> Void) {\n    // 网络请求与解析逻辑\n}\n```\n\n3.2 组件化 UI 设计\n- 通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。\n\n## 4. 用户体验与业务需求的结合\n- 泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。\n- 便于团队维护和扩展，降低后期 bug 率。\n- 通过类型安全，减少因类型不匹配导致的用户端崩溃。\n\n## 5. Debug 与排查能力\n\n5.1 常见问题\n- 泛型类型推断失败：需显式指定类型或增加约束。\n- 复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。\n\n5.2 排查流程\n- 检查泛型约束是否合理。\n- 利用 Xcode 的类型推断提示，定位类型不匹配点。\n- 通过单元测试覆盖泛型逻辑，及时发现边界问题。\n\n## 6. 总结\n泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。\n","slug":"iOS/泛型Generics","published":1,"updated":"2025-07-08T07:06:35.267Z","comments":1,"layout":"post","photos":[],"_id":"cmcu74t570006d9k7h8ukh16k","content":"<h1 id=\"在-Swift-中，什么是泛型（Generics）？\"><a href=\"#在-Swift-中，什么是泛型（Generics）？\" class=\"headerlink\" title=\"在 Swift 中，什么是泛型（Generics）？\"></a>在 Swift 中，什么是泛型（Generics）？</h1><h2 id=\"1-概念与原理\"><a href=\"#1-概念与原理\" class=\"headerlink\" title=\"1. 概念与原理\"></a>1. 概念与原理</h2><p>1.1 定义<br>泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。</p>\n<p>1.2 为什么需要泛型  </p>\n<ul>\n<li><strong>代码复用</strong>：避免重复实现相似逻辑。</li>\n<li><strong>类型安全</strong>：在编译期检查类型，减少运行时错误。</li>\n<li><strong>灵活性</strong>：支持多种数据类型，提升 API 设计的通用性。</li>\n</ul>\n<p>1.3 原理简述<br>Swift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。</p>\n<h2 id=\"2-语法与实现\"><a href=\"#2-语法与实现\" class=\"headerlink\" title=\"2. 语法与实现\"></a>2. 语法与实现</h2><p>2.1 基本语法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">swapTwoValues</span>&lt;<span class=\"type\">T</span>&gt;(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>, <span class=\"keyword\">_</span> <span class=\"params\">b</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp <span class=\"operator\">=</span> a</span><br><span class=\"line\">    a <span class=\"operator\">=</span> b</span><br><span class=\"line\">    b <span class=\"operator\">=</span> temp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>T</code> 是类型占位符，调用时由编译器推断。</li>\n</ul>\n<p>2.2 泛型类型</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Stack</span>&lt;<span class=\"type\">Element</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> items <span class=\"operator\">=</span> [<span class=\"type\">Element</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">push</span>(<span class=\"keyword\">_</span> <span class=\"params\">item</span>: <span class=\"type\">Element</span>) &#123; items.append(item) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">pop</span>() -&gt; <span class=\"type\">Element</span>? &#123; items.popLast() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Element</code> 可为任意类型，提升了数据结构的通用性。</li>\n</ul>\n<p>2.3 泛型约束</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">findIndex</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">Equatable</span>&gt;(<span class=\"params\">of</span> <span class=\"params\">value</span>: <span class=\"type\">T</span>, <span class=\"params\">in</span> <span class=\"params\">array</span>: [<span class=\"type\">T</span>]) -&gt; <span class=\"type\">Int</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index, item) <span class=\"keyword\">in</span> array.enumerated() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> item <span class=\"operator\">==</span> value &#123; <span class=\"keyword\">return</span> index &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 <code>T: Equatable</code> 限定泛型类型必须实现等值比较。</li>\n</ul>\n<h2 id=\"3-实际项目中的应用场景\"><a href=\"#3-实际项目中的应用场景\" class=\"headerlink\" title=\"3. 实际项目中的应用场景\"></a>3. 实际项目中的应用场景</h2><p>3.1 网络层数据解析</p>\n<ul>\n<li>利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">DecodableModel</span>: <span class=\"title class_ inherited__\">Decodable</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">DecodableModel</span>&gt;(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">Error</span>&gt;) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求与解析逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.2 组件化 UI 设计</p>\n<ul>\n<li>通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。</li>\n</ul>\n<h2 id=\"4-用户体验与业务需求的结合\"><a href=\"#4-用户体验与业务需求的结合\" class=\"headerlink\" title=\"4. 用户体验与业务需求的结合\"></a>4. 用户体验与业务需求的结合</h2><ul>\n<li>泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。</li>\n<li>便于团队维护和扩展，降低后期 bug 率。</li>\n<li>通过类型安全，减少因类型不匹配导致的用户端崩溃。</li>\n</ul>\n<h2 id=\"5-Debug-与排查能力\"><a href=\"#5-Debug-与排查能力\" class=\"headerlink\" title=\"5. Debug 与排查能力\"></a>5. Debug 与排查能力</h2><p>5.1 常见问题</p>\n<ul>\n<li>泛型类型推断失败：需显式指定类型或增加约束。</li>\n<li>复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。</li>\n</ul>\n<p>5.2 排查流程</p>\n<ul>\n<li>检查泛型约束是否合理。</li>\n<li>利用 Xcode 的类型推断提示，定位类型不匹配点。</li>\n<li>通过单元测试覆盖泛型逻辑，及时发现边界问题。</li>\n</ul>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。</p>\n","excerpt":"","more":"<h1 id=\"在-Swift-中，什么是泛型（Generics）？\"><a href=\"#在-Swift-中，什么是泛型（Generics）？\" class=\"headerlink\" title=\"在 Swift 中，什么是泛型（Generics）？\"></a>在 Swift 中，什么是泛型（Generics）？</h1><h2 id=\"1-概念与原理\"><a href=\"#1-概念与原理\" class=\"headerlink\" title=\"1. 概念与原理\"></a>1. 概念与原理</h2><p>1.1 定义<br>泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。</p>\n<p>1.2 为什么需要泛型  </p>\n<ul>\n<li><strong>代码复用</strong>：避免重复实现相似逻辑。</li>\n<li><strong>类型安全</strong>：在编译期检查类型，减少运行时错误。</li>\n<li><strong>灵活性</strong>：支持多种数据类型，提升 API 设计的通用性。</li>\n</ul>\n<p>1.3 原理简述<br>Swift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。</p>\n<h2 id=\"2-语法与实现\"><a href=\"#2-语法与实现\" class=\"headerlink\" title=\"2. 语法与实现\"></a>2. 语法与实现</h2><p>2.1 基本语法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">swapTwoValues</span>&lt;<span class=\"type\">T</span>&gt;(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>, <span class=\"keyword\">_</span> <span class=\"params\">b</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp <span class=\"operator\">=</span> a</span><br><span class=\"line\">    a <span class=\"operator\">=</span> b</span><br><span class=\"line\">    b <span class=\"operator\">=</span> temp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>T</code> 是类型占位符，调用时由编译器推断。</li>\n</ul>\n<p>2.2 泛型类型</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Stack</span>&lt;<span class=\"type\">Element</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> items <span class=\"operator\">=</span> [<span class=\"type\">Element</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">push</span>(<span class=\"keyword\">_</span> <span class=\"params\">item</span>: <span class=\"type\">Element</span>) &#123; items.append(item) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">pop</span>() -&gt; <span class=\"type\">Element</span>? &#123; items.popLast() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Element</code> 可为任意类型，提升了数据结构的通用性。</li>\n</ul>\n<p>2.3 泛型约束</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">findIndex</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">Equatable</span>&gt;(<span class=\"params\">of</span> <span class=\"params\">value</span>: <span class=\"type\">T</span>, <span class=\"params\">in</span> <span class=\"params\">array</span>: [<span class=\"type\">T</span>]) -&gt; <span class=\"type\">Int</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index, item) <span class=\"keyword\">in</span> array.enumerated() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> item <span class=\"operator\">==</span> value &#123; <span class=\"keyword\">return</span> index &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 <code>T: Equatable</code> 限定泛型类型必须实现等值比较。</li>\n</ul>\n<h2 id=\"3-实际项目中的应用场景\"><a href=\"#3-实际项目中的应用场景\" class=\"headerlink\" title=\"3. 实际项目中的应用场景\"></a>3. 实际项目中的应用场景</h2><p>3.1 网络层数据解析</p>\n<ul>\n<li>利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">DecodableModel</span>: <span class=\"title class_ inherited__\">Decodable</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">DecodableModel</span>&gt;(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">Error</span>&gt;) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求与解析逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.2 组件化 UI 设计</p>\n<ul>\n<li>通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。</li>\n</ul>\n<h2 id=\"4-用户体验与业务需求的结合\"><a href=\"#4-用户体验与业务需求的结合\" class=\"headerlink\" title=\"4. 用户体验与业务需求的结合\"></a>4. 用户体验与业务需求的结合</h2><ul>\n<li>泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。</li>\n<li>便于团队维护和扩展，降低后期 bug 率。</li>\n<li>通过类型安全，减少因类型不匹配导致的用户端崩溃。</li>\n</ul>\n<h2 id=\"5-Debug-与排查能力\"><a href=\"#5-Debug-与排查能力\" class=\"headerlink\" title=\"5. Debug 与排查能力\"></a>5. Debug 与排查能力</h2><p>5.1 常见问题</p>\n<ul>\n<li>泛型类型推断失败：需显式指定类型或增加约束。</li>\n<li>复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。</li>\n</ul>\n<p>5.2 排查流程</p>\n<ul>\n<li>检查泛型约束是否合理。</li>\n<li>利用 Xcode 的类型推断提示，定位类型不匹配点。</li>\n<li>通过单元测试覆盖泛型逻辑，及时发现边界问题。</li>\n</ul>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}