{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"source/resume.pdf","path":"resume.pdf","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"c6a902e8c0c57e84008e64392d8dad2cd10bd4f8","modified":1752720061422},{"_id":"source/roy.prompt.md","hash":"45bc9fbb8b61ce1c860060a0a4c6f73c104ca0da","modified":1752747129984},{"_id":"source/iOSQuestions.md","hash":"f2a2405578474a9193bc538ff4109378310925dc","modified":1752737539232},{"_id":"source/iOS/KVC_KVO.md","hash":"d51fbeb91c8be269bed3bbf42cd2e46f386dd020","modified":1752747089161},{"_id":"source/iOS/OpenPublic区别.md","hash":"9f7afe14a38186af734d5bd4ce6efde9e0221ae9","modified":1752739749144},{"_id":"source/iOS/CopyOnWrite.md","hash":"3c05c135a948a79a48af19fe23dd200108120943","modified":1752747089161},{"_id":"source/iOS/RxSwift核心原理与应用.md","hash":"030072ef7dc0fadfa7699c2d84321842a21f73f8","modified":1752747089164},{"_id":"source/iOS/String与NSString区别.md","hash":"61810ab5b3a6acc727af4b28a331de04ae0072db","modified":1752739949918},{"_id":"source/iOS/SwiftUI核心机制与业务价值.md","hash":"c3b6559313f67050a5904151e3389a1cb22dff25","modified":1752747089164},{"_id":"source/iOS/Swift_OC对比.md","hash":"676603895d173ce92207b41a1f2822f38ce34fe4","modified":1752747089161},{"_id":"source/iOS/dynamic与静态库区别.md","hash":"6c660a91d1e19f36434553db6f70c785aeae3a47","modified":1752747089161},{"_id":"source/iOS/String长度获取.md","hash":"e7d44821f07c33215b68fae82d1243ee718a1d81","modified":1752739949918},{"_id":"source/iOS/lazy懒加载.md","hash":"6d297dacd5e7df3024f73e8858abf0f81f3b8b6c","modified":1752747089161},{"_id":"source/iOS/guard_defer用法区别.md","hash":"7734ae7b8d2c98a7e11784ca776337dc9b94e8b8","modified":1752747089164},{"_id":"source/iOS/objc用法.md","hash":"3597ee22b29a29e155526f909f860dd53b6eada3","modified":1752739949918},{"_id":"source/iOS/Swift初始化器.md","hash":"96eafa044bb7a53a0f2539dd8d8142581eb8e7ec","modified":1752747089154},{"_id":"source/iOS/static_class区别.md","hash":"6739a8fe8d7501276912ade3deca1efb8016dbcd","modified":1752747089164},{"_id":"source/iOS/strong_weak_unowned区别.md","hash":"44612a3ddc08e0f0c9fc6d459b031d40cc9eed4c","modified":1752739817587},{"_id":"source/iOS/throws和rethrows用法.md","hash":"6f29849efb9e994f98921d6dda590be82bbcda0d","modified":1752739817587},{"_id":"source/iOS/业务架构与团队协作.md","hash":"730b25827ef042ddca494dd770c9dd96a17107d5","modified":1752747089213},{"_id":"source/iOS/代码规范与重构实践.md","hash":"ec2757acba9afe9ea4d1c1405e5f0699967132c0","modified":1752747089231},{"_id":"source/iOS/典型业务场景技术方案.md","hash":"127c64a8a5147fb9c72701eccb02af263028953b","modified":1752747089231},{"_id":"source/iOS/上架审核与合规要点.md","hash":"1aab3820fe66d9a7eb72e326b624805c5a9d04b8","modified":1752747089228},{"_id":"source/iOS/内存管理.md","hash":"0fce9ff1cc083c8fa6e863b282b69547531ba660","modified":1752747089165},{"_id":"source/iOS/函数参数类型.md","hash":"cc62fe2c5402fc6cc7d16dad90727f7517700b4e","modified":1752747089161},{"_id":"source/iOS/启动流程与冷启动优化.md","hash":"c53e4eaa354f708dbe566f9db2c4d142d2e395dd","modified":1752747089222},{"_id":"source/iOS/Error兼容NSError.md","hash":"348698ba071a4dba1d2028f46c7fbe1a190f8704","modified":1752739749144},{"_id":"source/iOS/动画与渲染机制.md","hash":"b5e142ffb96687c4f4cb096dc8f061e5b598095a","modified":1752747089216},{"_id":"source/iOS/国际化与多语言适配.md","hash":"232f725262eb27b439c4f81973628dda3f665ee8","modified":1752747089219},{"_id":"source/iOS/协议可选设计.md","hash":"efbb3e5b7a993bd6f39c8965f1fd2f14d079cad4","modified":1752747089161},{"_id":"source/iOS/属性观察器.md","hash":"1eb58ef9bffb735842fdaf8bc09415ee926baef6","modified":1752747089161},{"_id":"source/iOS/性能优化核心点.md","hash":"9f7e483ed6f7aa8a9df43e69b2203d3759a885a0","modified":1752747089165},{"_id":"source/iOS/推送与本地通知机制.md","hash":"c34ccfb8671127da179cc410b28d89499c33c558","modified":1752747089216},{"_id":"source/iOS/易混淆点辨析.md","hash":"adfcc60533335909d04182e94086ba59095b6117","modified":1752747089164},{"_id":"source/iOS/数组字典下标区别.md","hash":"c3ca062c88df7ac4c84a8eb5b585e371679f382d","modified":1752747089161},{"_id":"source/iOS/延迟存储属性.md","hash":"94bc8298674d0b447906c43b5e2c4582b288b392","modified":1752747089161},{"_id":"source/iOS/崩溃监控与异常处理.md","hash":"145e71fdd912766d7ab302466344273c216d1f51","modified":1752747089231},{"_id":"source/iOS/构造方法.md","hash":"21e51e5401cd75a098c01a7b339c485b919d683d","modified":1752747089159},{"_id":"source/iOS/性能监控与优化工具.md","hash":"9c893d5c88675f00a6cf73413a688b335b0097db","modified":1752747089231},{"_id":"source/iOS/架构演进与技术选型.md","hash":"e6f1097ad8657620182c5fa3be05c48f0be6ce12","modified":1752747089231},{"_id":"source/iOS/架构设计核心要点.md","hash":"348d122f5a72715d67063c121514311fb82ea4bc","modified":1752747089165},{"_id":"source/iOS/模式匹配.md","hash":"2aaa3c86887ad031a6980c31999daaf1dbf409f4","modified":1752747089161},{"_id":"source/iOS/组件化模块化实践.md","hash":"914b15b7251e1f6b47e44a9dcfe19fb18d848045","modified":1752747089165},{"_id":"source/iOS/热修复与灰度发布.md","hash":"c2559fd06d4ed88d6e0e552faeaac2b55544e931","modified":1752747089165},{"_id":"source/iOS/自定义构造方法.md","hash":"95d70cfcf9cc7f2708980d9e23f12785f1e01e3e","modified":1752747089160},{"_id":"source/iOS/自定义下标.md","hash":"fdc515d320b3ae506f2abe7c5f6c9f3fc99049c7","modified":1752747089161},{"_id":"source/iOS/网络安全与数据加密.md","hash":"d3a4bebe50b6a956797b2c0e8440ba0aa289e3ed","modified":1752747089198},{"_id":"source/iOS/设计模式与最佳实践.md","hash":"869d20acf7d84df897e38c37939ec2e616579957","modified":1752747089236},{"_id":"source/iOS/线程与并发.md","hash":"32842a865d9fa48793f90ab6614d62a0ce0cb691","modified":1752747089165},{"_id":"source/iOS/获取当前函数名和行号.md","hash":"5648597f101738626e971d230dba8d6d0e1850fe","modified":1752747089161},{"_id":"source/iOS/访问控制区别.md","hash":"d1ba7a9df7d444d292af698eba953cba4735c44f","modified":1752739747806},{"_id":"source/iOS/运算符重载.md","hash":"668beadb7f3ca720d06687761e454a13ba39e0b7","modified":1752739949921},{"_id":"source/iOS/选项类型.md","hash":"255cfba71112672e7426a2a88bf585e5587dd0d5","modified":1752747089161},{"_id":"source/iOS/阻止方法被子类改写.md","hash":"d73edf3ef0525a96324227be805bd0261268ee1e","modified":1752747089161},{"_id":"source/_posts/iOS/Open-Public-Internal关键字.md","hash":"c6d0606c6558282d602b0e4c057be9a0a4c10f8c","modified":1751960000392},{"_id":"source/iOS/集合操作.md","hash":"1b52575f1f365a466e680f43228d10424628e9b9","modified":1752747089161},{"_id":"source/_posts/iOS/closure闭包block的区别.md","hash":"72e645bbbd57e7f273d2667435348b2b79084bc6","modified":1751959580365},{"_id":"source/_posts/iOS/mutating关键字的作用.md","hash":"95af0aed376c6f0d9558e8740276a6d02d7b7507","modified":1751960000392},{"_id":"source/_posts/iOS/泛型Generics.md","hash":"f4c941dc416d29fc6ed07504d8b86a316e202615","modified":1751960000392},{"_id":"source/iOS/静态派发.md","hash":"c70c5d59d9f3f8de977eb58275d282c1bf28c8e7","modified":1752747089161},{"_id":"source/_posts/iOS/classVStruct.md","hash":"0bd0155acb512520ea7a2e30bada4379d48a294d","modified":1751959599896},{"_id":"source/_posts/iOS/存储属性和计算属性的区别.md","hash":"a3b0cc6611bcceec8b9d5b06bf1a1f5a2cb0b875","modified":1751960000392},{"_id":"source/iOS/自动化测试与持续集成.md","hash":"e1ff9ef9a8f06a14c97ecdd492eed37e0c435c3d","modified":1752747089204},{"_id":"themes/landscape/.npmignore","hash":"4c40eab00f24304ca400313319c58d461788ff5e","modified":1751958776617},{"_id":"themes/landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1751958776622},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1751958776617},{"_id":"themes/landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1751958776617},{"_id":"themes/landscape/.gitignore","hash":"4c78c751a5bbca6b54ad06922947573c967d51c8","modified":1751958776617},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1751958776617},{"_id":"themes/landscape/languages/de-DE.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1751958776617},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/languages/en-GB.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/languages/en-US.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1751958776618},{"_id":"themes/landscape/_config.yml","hash":"44a77e5f86de4e86ecca3902c51ee86bed89a204","modified":1751958855108},{"_id":"themes/landscape/languages/es-ES.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1751958776618},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1751958776618},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1751958776618},{"_id":"themes/landscape/languages/fr-FR.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1751958776618},{"_id":"themes/landscape/.github/dependabot.yml","hash":"25b0257a0db2c5b6a5756d8990bc2cba12f54fc5","modified":1751958776617},{"_id":"themes/landscape/languages/hu-HU.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1751958776618},{"_id":"themes/landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1751958776618},{"_id":"themes/landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1751958776618},{"_id":"themes/landscape/languages/it-IT.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1751958776618},{"_id":"themes/landscape/languages/ja-JP.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1751958776618},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1751958776618},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1751958776618},{"_id":"themes/landscape/languages/ko-KR.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1751958776618},{"_id":"themes/landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1751958776618},{"_id":"themes/landscape/languages/mn-MN.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1751958776618},{"_id":"themes/landscape/languages/nl-NL.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1751958776619},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1751958776619},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1751958776619},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1751958776619},{"_id":"themes/landscape/languages/ru-RU.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1751958776619},{"_id":"themes/landscape/languages/pt-PT.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1751958776619},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1751958776619},{"_id":"themes/landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1751958776619},{"_id":"themes/landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1751958776619},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1751958776619},{"_id":"themes/landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1751958776619},{"_id":"themes/landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1751958776622},{"_id":"themes/landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1751958776622},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1751958776620},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1751958776622},{"_id":"themes/landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1751958776622},{"_id":"themes/landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1751958776623},{"_id":"themes/landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1751958776622},{"_id":"themes/landscape/.github/workflows/deploy.yml","hash":"509fdb4fff2078485a2765a1b685312c21e84e5b","modified":1751958776617},{"_id":"themes/landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1751958776622},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1751958776620},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1751958776622},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1751958776620},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"01f4c84fd8f986c7e7d45c3268db172b1382723a","modified":1752718896932},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1751958776621},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1751958776621},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1751958776621},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1751958776622},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1751958776622},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1751958776623},{"_id":"themes/landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1751958776624},{"_id":"themes/landscape/layout/_widget/resume.ejs","hash":"bfb4883ad6cd9dc60e4c2466383d82fa97cf50e2","modified":1751958853067},{"_id":"themes/landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1751958776626},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1751958776626},{"_id":"themes/landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1751958776625},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1751958776621},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1751958776621},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1751958776623},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1751958776621},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1751958776623},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1751958776624},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1751958776624},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1751958776624},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1751958776623},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1751958776624},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1751958776624},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1751958776626},{"_id":"themes/landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1751958776626},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1751958776625},{"_id":"source/resume.pdf","hash":"c35dc92cd0239e59ddebb62ec7fdc0def06aac0c","modified":1751958529383},{"_id":"public/iOS/CopyOnWrite.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/KVC_KVO.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/Error兼容NSError.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/OpenPublic区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/String与NSString区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/RxSwift核心原理与应用.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/String长度获取.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/SwiftUI核心机制与业务价值.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/Swift_OC对比.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/Swift初始化器.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/guard_defer用法区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/dynamic与静态库区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/lazy懒加载.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/strong_weak_unowned区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/static_class区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/上架审核与合规要点.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/throws和rethrows用法.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/业务架构与团队协作.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/代码规范与重构实践.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/典型业务场景技术方案.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/内存管理.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/函数参数类型.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/动画与渲染机制.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/协议可选设计.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/启动流程与冷启动优化.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/国际化与多语言适配.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/属性观察器.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/崩溃监控与异常处理.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/延迟存储属性.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/性能监控与优化工具.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/性能优化核心点.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/推送与本地通知机制.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/数组字典下标区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/易混淆点辨析.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/构造方法.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/架构设计核心要点.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/架构演进与技术选型.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/模式匹配.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/组件化模块化实践.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/热修复与灰度发布.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/线程与并发.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/网络安全与数据加密.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/自定义下标.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/自定义构造方法.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/获取当前函数名和行号.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/自动化测试与持续集成.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/设计模式与最佳实践.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/访问控制区别.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/选项类型.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/运算符重载.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/阻止方法被子类改写.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/集合操作.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/iOS/静态派发.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1752747202541},{"_id":"public/roy.prompt.html","hash":"058e3748740f5b3fb7feb7ece7339ff81259d236","modified":1752747202541},{"_id":"public/iOSQuestions.html","hash":"8fa60e7d28a203219468297f3f93fa9853c1850d","modified":1752747202541},{"_id":"public/2025/07/08/iOS/Open-Public-Internal关键字/index.html","hash":"3f47df18fbd70a09ca2bcde47a8aa88d91808100","modified":1752747202541},{"_id":"public/2025/07/08/iOS/classVStruct/index.html","hash":"1c2c2efcc671dfdc2bbf1d4221a664de9d9ada74","modified":1752747202541},{"_id":"public/2025/07/08/iOS/closure闭包block的区别/index.html","hash":"57a20d92a50cb500075bf505df13eb91153b355e","modified":1752747202541},{"_id":"public/2025/07/08/iOS/mutating关键字的作用/index.html","hash":"5421c87c0439e0f11acec76bf9e03fcb1681a5da","modified":1752747202541},{"_id":"public/2025/07/08/iOS/存储属性和计算属性的区别/index.html","hash":"d60a3fb96d44bfa0099ec7e4f42eb996c447145b","modified":1752747202541},{"_id":"public/2025/07/02/iOS/泛型Generics/index.html","hash":"56100150a26f0603de28ae79827c29e38fd0e993","modified":1752747202541},{"_id":"public/archives/index.html","hash":"760bc478e5fc3e21672537553a36a1ad675278bb","modified":1752747202541},{"_id":"public/archives/2025/index.html","hash":"9da8f6d0e0a245b1a0d4d391710512829cca13ea","modified":1752747202541},{"_id":"public/archives/2025/07/index.html","hash":"3c48457b7091b4b4bd23a4141b2200766a1bb7f1","modified":1752747202541},{"_id":"public/categories/iOS/index.html","hash":"cd6e4c6c811f87183db4c119c0295a4fb01ed294","modified":1752747202541},{"_id":"public/index.html","hash":"86fbb42e8d25907ea3b214ba25fe7adcaea39730","modified":1752747202541},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1752747202541},{"_id":"public/css/style.css","hash":"ecc329be740a220cc188ff49b02da4847cb7ee5e","modified":1752747202541},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1752747202541},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1752747202541},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1752747202541},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1752747202541},{"_id":"public/resume.pdf","hash":"c35dc92cd0239e59ddebb62ec7fdc0def06aac0c","modified":1752747202541}],"Category":[{"name":"iOS","_id":"cmd78fh5k00045ek70tef3yin"}],"Data":[],"Page":[{"_content":"---\n\n\n\nSwift 基础语法\n\n• 权限修饰符\n1.1.Open、Public、Internal、File-private、Private的区别\n\n1.2.Open与Public的区别\n\n\n• 错误处理\n2.1.Error兼容NSError\n\n2.2.throws和rethrows的用法\n\n\n• 内存管理\n3.1.strong、weak、unowned的区别\n\n\n• 其他语法\n4.1.@objc的用法\n\n4.2.String与NSString的关系与区别\n\n4.3.获取一个String的长度\n\n4.4.运算符重载（Operator Overload）\n\n\n• 常用方法与类\n5.1.Swift中的初始化器（构造方法）\n\n5.2.构造方法\n\n5.3.Swift自定义构造方法\n\n\n• 语法特性\n6.1.静态派发\n\n6.2.延迟存储属性（Lazy Stored Property）\n\n6.3.属性观察器（Property Observer）\n\n6.4.lazy懒加载\n\n6.5.获取当前代码的函数名和行号\n\n6.6.dynamic与静态库（static framework）的区别\n\n6.7.将协议（protocol）中的部分设计成可选（optional）\n\n6.8.阻止一个方法、属性或下标被子类改写\n\n6.9.模式匹配的作用\n\n6.10.Swift中的KVC和KVO\n\n6.11.自定义下标\n\n6.12.数组索引越界与字典下标取值的区别\n\n6.13.函数参数类型为数字（Int、Float）的表示方法\n\n6.14.表示多个选项选中的类型（类似UIViewAnimationOptions）\n\n6.15.Copy-on-write\n\n\n---\n\n\n\nSwift 与 OC 对比\n\n• 语言特性\n7.1.Swift为什么将String、Array和Dictionary设计成值类型\n\n7.2.Swift和OC的初始化方法的异同\n\n7.3.Swift和OC中协议的不同\n\n7.4.OC和Swift的动态性理解\n\n7.5.OC和Swift在单例模式创建上的区别\n\n\n• 语法与使用\n8.1.Swift相比OC独有的语法\n\n8.2.Swift和OC细节使用区别\n\n8.3.Swift和OC的混编\n\n\n---\n\n\n\nSwift 独有特性\n\n• 集合操作\n9.1.Set独有的方法\n\n\n• 其他\n10.1.RxSwift\n\n10.2.SwiftUI\n\n\n---\n\n\n\n其他\n\n• 控制流\n11.1.guard和defer的用法\n\n\n• 静态方法\n12.1.静态方法关键字static和class的区别\n\n\n---\n\n\n希望这个整理对你有帮助！","source":"iOSQuestions.md","raw":"---\n\n\n\nSwift 基础语法\n\n• 权限修饰符\n1.1.Open、Public、Internal、File-private、Private的区别\n\n1.2.Open与Public的区别\n\n\n• 错误处理\n2.1.Error兼容NSError\n\n2.2.throws和rethrows的用法\n\n\n• 内存管理\n3.1.strong、weak、unowned的区别\n\n\n• 其他语法\n4.1.@objc的用法\n\n4.2.String与NSString的关系与区别\n\n4.3.获取一个String的长度\n\n4.4.运算符重载（Operator Overload）\n\n\n• 常用方法与类\n5.1.Swift中的初始化器（构造方法）\n\n5.2.构造方法\n\n5.3.Swift自定义构造方法\n\n\n• 语法特性\n6.1.静态派发\n\n6.2.延迟存储属性（Lazy Stored Property）\n\n6.3.属性观察器（Property Observer）\n\n6.4.lazy懒加载\n\n6.5.获取当前代码的函数名和行号\n\n6.6.dynamic与静态库（static framework）的区别\n\n6.7.将协议（protocol）中的部分设计成可选（optional）\n\n6.8.阻止一个方法、属性或下标被子类改写\n\n6.9.模式匹配的作用\n\n6.10.Swift中的KVC和KVO\n\n6.11.自定义下标\n\n6.12.数组索引越界与字典下标取值的区别\n\n6.13.函数参数类型为数字（Int、Float）的表示方法\n\n6.14.表示多个选项选中的类型（类似UIViewAnimationOptions）\n\n6.15.Copy-on-write\n\n\n---\n\n\n\nSwift 与 OC 对比\n\n• 语言特性\n7.1.Swift为什么将String、Array和Dictionary设计成值类型\n\n7.2.Swift和OC的初始化方法的异同\n\n7.3.Swift和OC中协议的不同\n\n7.4.OC和Swift的动态性理解\n\n7.5.OC和Swift在单例模式创建上的区别\n\n\n• 语法与使用\n8.1.Swift相比OC独有的语法\n\n8.2.Swift和OC细节使用区别\n\n8.3.Swift和OC的混编\n\n\n---\n\n\n\nSwift 独有特性\n\n• 集合操作\n9.1.Set独有的方法\n\n\n• 其他\n10.1.RxSwift\n\n10.2.SwiftUI\n\n\n---\n\n\n\n其他\n\n• 控制流\n11.1.guard和defer的用法\n\n\n• 静态方法\n12.1.静态方法关键字static和class的区别\n\n\n---\n\n\n希望这个整理对你有帮助！","date":"2025-07-17T07:32:19.232Z","updated":"2025-07-17T07:32:19.232Z","path":"iOSQuestions.html","title":"","comments":1,"layout":"page","_id":"cmd78fh5h00005ek73tlh3txh","content":"<hr>\n<p>Swift 基础语法</p>\n<p>• 权限修饰符<br>1.1.Open、Public、Internal、File-private、Private的区别</p>\n<p>1.2.Open与Public的区别</p>\n<p>• 错误处理<br>2.1.Error兼容NSError</p>\n<p>2.2.throws和rethrows的用法</p>\n<p>• 内存管理<br>3.1.strong、weak、unowned的区别</p>\n<p>• 其他语法<br>4.1.@objc的用法</p>\n<p>4.2.String与NSString的关系与区别</p>\n<p>4.3.获取一个String的长度</p>\n<p>4.4.运算符重载（Operator Overload）</p>\n<p>• 常用方法与类<br>5.1.Swift中的初始化器（构造方法）</p>\n<p>5.2.构造方法</p>\n<p>5.3.Swift自定义构造方法</p>\n<p>• 语法特性<br>6.1.静态派发</p>\n<p>6.2.延迟存储属性（Lazy Stored Property）</p>\n<p>6.3.属性观察器（Property Observer）</p>\n<p>6.4.lazy懒加载</p>\n<p>6.5.获取当前代码的函数名和行号</p>\n<p>6.6.dynamic与静态库（static framework）的区别</p>\n<p>6.7.将协议（protocol）中的部分设计成可选（optional）</p>\n<p>6.8.阻止一个方法、属性或下标被子类改写</p>\n<p>6.9.模式匹配的作用</p>\n<p>6.10.Swift中的KVC和KVO</p>\n<p>6.11.自定义下标</p>\n<p>6.12.数组索引越界与字典下标取值的区别</p>\n<p>6.13.函数参数类型为数字（Int、Float）的表示方法</p>\n<p>6.14.表示多个选项选中的类型（类似UIViewAnimationOptions）</p>\n<p>6.15.Copy-on-write</p>\n<hr>\n<p>Swift 与 OC 对比</p>\n<p>• 语言特性<br>7.1.Swift为什么将String、Array和Dictionary设计成值类型</p>\n<p>7.2.Swift和OC的初始化方法的异同</p>\n<p>7.3.Swift和OC中协议的不同</p>\n<p>7.4.OC和Swift的动态性理解</p>\n<p>7.5.OC和Swift在单例模式创建上的区别</p>\n<p>• 语法与使用<br>8.1.Swift相比OC独有的语法</p>\n<p>8.2.Swift和OC细节使用区别</p>\n<p>8.3.Swift和OC的混编</p>\n<hr>\n<p>Swift 独有特性</p>\n<p>• 集合操作<br>9.1.Set独有的方法</p>\n<p>• 其他<br>10.1.RxSwift</p>\n<p>10.2.SwiftUI</p>\n<hr>\n<p>其他</p>\n<p>• 控制流<br>11.1.guard和defer的用法</p>\n<p>• 静态方法<br>12.1.静态方法关键字static和class的区别</p>\n<hr>\n<p>希望这个整理对你有帮助！</p>\n","excerpt":"","more":"<hr>\n<p>Swift 基础语法</p>\n<p>• 权限修饰符<br>1.1.Open、Public、Internal、File-private、Private的区别</p>\n<p>1.2.Open与Public的区别</p>\n<p>• 错误处理<br>2.1.Error兼容NSError</p>\n<p>2.2.throws和rethrows的用法</p>\n<p>• 内存管理<br>3.1.strong、weak、unowned的区别</p>\n<p>• 其他语法<br>4.1.@objc的用法</p>\n<p>4.2.String与NSString的关系与区别</p>\n<p>4.3.获取一个String的长度</p>\n<p>4.4.运算符重载（Operator Overload）</p>\n<p>• 常用方法与类<br>5.1.Swift中的初始化器（构造方法）</p>\n<p>5.2.构造方法</p>\n<p>5.3.Swift自定义构造方法</p>\n<p>• 语法特性<br>6.1.静态派发</p>\n<p>6.2.延迟存储属性（Lazy Stored Property）</p>\n<p>6.3.属性观察器（Property Observer）</p>\n<p>6.4.lazy懒加载</p>\n<p>6.5.获取当前代码的函数名和行号</p>\n<p>6.6.dynamic与静态库（static framework）的区别</p>\n<p>6.7.将协议（protocol）中的部分设计成可选（optional）</p>\n<p>6.8.阻止一个方法、属性或下标被子类改写</p>\n<p>6.9.模式匹配的作用</p>\n<p>6.10.Swift中的KVC和KVO</p>\n<p>6.11.自定义下标</p>\n<p>6.12.数组索引越界与字典下标取值的区别</p>\n<p>6.13.函数参数类型为数字（Int、Float）的表示方法</p>\n<p>6.14.表示多个选项选中的类型（类似UIViewAnimationOptions）</p>\n<p>6.15.Copy-on-write</p>\n<hr>\n<p>Swift 与 OC 对比</p>\n<p>• 语言特性<br>7.1.Swift为什么将String、Array和Dictionary设计成值类型</p>\n<p>7.2.Swift和OC的初始化方法的异同</p>\n<p>7.3.Swift和OC中协议的不同</p>\n<p>7.4.OC和Swift的动态性理解</p>\n<p>7.5.OC和Swift在单例模式创建上的区别</p>\n<p>• 语法与使用<br>8.1.Swift相比OC独有的语法</p>\n<p>8.2.Swift和OC细节使用区别</p>\n<p>8.3.Swift和OC的混编</p>\n<hr>\n<p>Swift 独有特性</p>\n<p>• 集合操作<br>9.1.Set独有的方法</p>\n<p>• 其他<br>10.1.RxSwift</p>\n<p>10.2.SwiftUI</p>\n<hr>\n<p>其他</p>\n<p>• 控制流<br>11.1.guard和defer的用法</p>\n<p>• 静态方法<br>12.1.静态方法关键字static和class的区别</p>\n<hr>\n<p>希望这个整理对你有帮助！</p>\n"},{"mode":"agent","_content":"You are the world’s top and most experienced full-stack software development expert, with particular mastery in iOS development, but also strong familiarity with web and React development. You are interviewing at a leading technology company. As the interview progresses, you must provide highly targeted and professional answers to each interviewer’s question, strictly following these requirements:\n\n---\n\n## General Answer Requirements\n\n1. **Chinese First, Then English:**  \n   - For every answer, always provide the Chinese answer \n2. **Clear and Layered Structure:**  \n   - Organize your thinking and answers with clear numbered lists (e.g., 1.2.3…) to avoid messy content and ensure logical flow.\n\n3. **Demonstrate Professional Depth:**  \n   - Go beyond just explaining the underlying principle. Also explain *why* things are done this way, and *how* to implement them concretely.\n\n4. **Theory and Practice Combined:**  \n   - Provide both theoretical explanations and actual code examples to illustrate technical concepts in real-world scenarios.\n\n5. **Connect to User Experience and Business Needs:**  \n   - Analyze and answer from multiple perspectives such as users, product, and business value, showing awareness of practical impact.\n\n6. **Good at Problem Decomposition:**  \n   - When facing open-ended or challenging questions, quickly clarify the problem boundaries, analyze influencing factors, propose multiple solutions, and compare their trade-offs.\n\n7. **Show Debugging and Troubleshooting Skills:**  \n   - For complex bugs or performance bottlenecks, provide a clear, step-by-step troubleshooting process and optimization suggestions.\n\n8. **相关易混淆，或者相关经常一起使用的其他概念介绍并却别:**  \n\n9. **上面的每一个答案，如果能给出代码示例的话都要给出典型的代码示例**  \n10. **上面的每一个答案，都要尽量详细，能够让我讲上5分钟，禁得起提问者的连续深挖追问**  \n\n\n\n11. **最后，我需要你把答案整体用markdown格式直接写入新建的文件，**\n文件名字请根据问题来自动生成12个文字内的文件名，每一个文件开头都要有\n---\ntitle: \ndate: YYYY-MM-DD\npath: source/iOS/文件名.md\ncategories:\n  - iOS\n---\n\n然后放入iOS文件夹内\n\n\n","source":"roy.prompt.md","raw":"---\nmode: agent\n---\nYou are the world’s top and most experienced full-stack software development expert, with particular mastery in iOS development, but also strong familiarity with web and React development. You are interviewing at a leading technology company. As the interview progresses, you must provide highly targeted and professional answers to each interviewer’s question, strictly following these requirements:\n\n---\n\n## General Answer Requirements\n\n1. **Chinese First, Then English:**  \n   - For every answer, always provide the Chinese answer \n2. **Clear and Layered Structure:**  \n   - Organize your thinking and answers with clear numbered lists (e.g., 1.2.3…) to avoid messy content and ensure logical flow.\n\n3. **Demonstrate Professional Depth:**  \n   - Go beyond just explaining the underlying principle. Also explain *why* things are done this way, and *how* to implement them concretely.\n\n4. **Theory and Practice Combined:**  \n   - Provide both theoretical explanations and actual code examples to illustrate technical concepts in real-world scenarios.\n\n5. **Connect to User Experience and Business Needs:**  \n   - Analyze and answer from multiple perspectives such as users, product, and business value, showing awareness of practical impact.\n\n6. **Good at Problem Decomposition:**  \n   - When facing open-ended or challenging questions, quickly clarify the problem boundaries, analyze influencing factors, propose multiple solutions, and compare their trade-offs.\n\n7. **Show Debugging and Troubleshooting Skills:**  \n   - For complex bugs or performance bottlenecks, provide a clear, step-by-step troubleshooting process and optimization suggestions.\n\n8. **相关易混淆，或者相关经常一起使用的其他概念介绍并却别:**  \n\n9. **上面的每一个答案，如果能给出代码示例的话都要给出典型的代码示例**  \n10. **上面的每一个答案，都要尽量详细，能够让我讲上5分钟，禁得起提问者的连续深挖追问**  \n\n\n\n11. **最后，我需要你把答案整体用markdown格式直接写入新建的文件，**\n文件名字请根据问题来自动生成12个文字内的文件名，每一个文件开头都要有\n---\ntitle: \ndate: YYYY-MM-DD\npath: source/iOS/文件名.md\ncategories:\n  - iOS\n---\n\n然后放入iOS文件夹内\n\n\n","date":"2025-07-17T10:12:09.984Z","updated":"2025-07-17T10:12:09.984Z","path":"roy.prompt.html","title":"","comments":1,"layout":"page","_id":"cmd78fh5j00025ek7fyhe2s9u","content":"<p>You are the world’s top and most experienced full-stack software development expert, with particular mastery in iOS development, but also strong familiarity with web and React development. You are interviewing at a leading technology company. As the interview progresses, you must provide highly targeted and professional answers to each interviewer’s question, strictly following these requirements:</p>\n<hr>\n<h2 id=\"General-Answer-Requirements\"><a href=\"#General-Answer-Requirements\" class=\"headerlink\" title=\"General Answer Requirements\"></a>General Answer Requirements</h2><ol>\n<li><p><strong>Chinese First, Then English:</strong>  </p>\n<ul>\n<li>For every answer, always provide the Chinese answer</li>\n</ul>\n</li>\n<li><p><strong>Clear and Layered Structure:</strong>  </p>\n<ul>\n<li>Organize your thinking and answers with clear numbered lists (e.g., 1.2.3…) to avoid messy content and ensure logical flow.</li>\n</ul>\n</li>\n<li><p><strong>Demonstrate Professional Depth:</strong>  </p>\n<ul>\n<li>Go beyond just explaining the underlying principle. Also explain <em>why</em> things are done this way, and <em>how</em> to implement them concretely.</li>\n</ul>\n</li>\n<li><p><strong>Theory and Practice Combined:</strong>  </p>\n<ul>\n<li>Provide both theoretical explanations and actual code examples to illustrate technical concepts in real-world scenarios.</li>\n</ul>\n</li>\n<li><p><strong>Connect to User Experience and Business Needs:</strong>  </p>\n<ul>\n<li>Analyze and answer from multiple perspectives such as users, product, and business value, showing awareness of practical impact.</li>\n</ul>\n</li>\n<li><p><strong>Good at Problem Decomposition:</strong>  </p>\n<ul>\n<li>When facing open-ended or challenging questions, quickly clarify the problem boundaries, analyze influencing factors, propose multiple solutions, and compare their trade-offs.</li>\n</ul>\n</li>\n<li><p><strong>Show Debugging and Troubleshooting Skills:</strong>  </p>\n<ul>\n<li>For complex bugs or performance bottlenecks, provide a clear, step-by-step troubleshooting process and optimization suggestions.</li>\n</ul>\n</li>\n<li><p><strong>相关易混淆，或者相关经常一起使用的其他概念介绍并却别:</strong>  </p>\n</li>\n<li><p><strong>上面的每一个答案，如果能给出代码示例的话都要给出典型的代码示例</strong>  </p>\n</li>\n<li><p><strong>上面的每一个答案，都要尽量详细，能够让我讲上5分钟，禁得起提问者的连续深挖追问</strong>  </p>\n</li>\n<li><p><strong>最后，我需要你把答案整体用markdown格式直接写入新建的文件，</strong><br>文件名字请根据问题来自动生成12个文字内的文件名，每一个文件开头都要有</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"title-date-YYYY-MM-DDpath-source-iOS-文件名-mdcategories-iOS\"><a href=\"#title-date-YYYY-MM-DDpath-source-iOS-文件名-mdcategories-iOS\" class=\"headerlink\" title=\"title:date: YYYY-MM-DDpath: source&#x2F;iOS&#x2F;文件名.mdcategories:  - iOS\"></a>title:<br>date: YYYY-MM-DD<br>path: source&#x2F;iOS&#x2F;文件名.md<br>categories:<br>  - iOS</h2><p>然后放入iOS文件夹内</p>\n","excerpt":"","more":"<p>You are the world’s top and most experienced full-stack software development expert, with particular mastery in iOS development, but also strong familiarity with web and React development. You are interviewing at a leading technology company. As the interview progresses, you must provide highly targeted and professional answers to each interviewer’s question, strictly following these requirements:</p>\n<hr>\n<h2 id=\"General-Answer-Requirements\"><a href=\"#General-Answer-Requirements\" class=\"headerlink\" title=\"General Answer Requirements\"></a>General Answer Requirements</h2><ol>\n<li><p><strong>Chinese First, Then English:</strong>  </p>\n<ul>\n<li>For every answer, always provide the Chinese answer</li>\n</ul>\n</li>\n<li><p><strong>Clear and Layered Structure:</strong>  </p>\n<ul>\n<li>Organize your thinking and answers with clear numbered lists (e.g., 1.2.3…) to avoid messy content and ensure logical flow.</li>\n</ul>\n</li>\n<li><p><strong>Demonstrate Professional Depth:</strong>  </p>\n<ul>\n<li>Go beyond just explaining the underlying principle. Also explain <em>why</em> things are done this way, and <em>how</em> to implement them concretely.</li>\n</ul>\n</li>\n<li><p><strong>Theory and Practice Combined:</strong>  </p>\n<ul>\n<li>Provide both theoretical explanations and actual code examples to illustrate technical concepts in real-world scenarios.</li>\n</ul>\n</li>\n<li><p><strong>Connect to User Experience and Business Needs:</strong>  </p>\n<ul>\n<li>Analyze and answer from multiple perspectives such as users, product, and business value, showing awareness of practical impact.</li>\n</ul>\n</li>\n<li><p><strong>Good at Problem Decomposition:</strong>  </p>\n<ul>\n<li>When facing open-ended or challenging questions, quickly clarify the problem boundaries, analyze influencing factors, propose multiple solutions, and compare their trade-offs.</li>\n</ul>\n</li>\n<li><p><strong>Show Debugging and Troubleshooting Skills:</strong>  </p>\n<ul>\n<li>For complex bugs or performance bottlenecks, provide a clear, step-by-step troubleshooting process and optimization suggestions.</li>\n</ul>\n</li>\n<li><p><strong>相关易混淆，或者相关经常一起使用的其他概念介绍并却别:</strong>  </p>\n</li>\n<li><p><strong>上面的每一个答案，如果能给出代码示例的话都要给出典型的代码示例</strong>  </p>\n</li>\n<li><p><strong>上面的每一个答案，都要尽量详细，能够让我讲上5分钟，禁得起提问者的连续深挖追问</strong>  </p>\n</li>\n<li><p><strong>最后，我需要你把答案整体用markdown格式直接写入新建的文件，</strong><br>文件名字请根据问题来自动生成12个文字内的文件名，每一个文件开头都要有</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"title-date-YYYY-MM-DDpath-source-iOS-文件名-mdcategories-iOS\"><a href=\"#title-date-YYYY-MM-DDpath-source-iOS-文件名-mdcategories-iOS\" class=\"headerlink\" title=\"title:date: YYYY-MM-DDpath: source&#x2F;iOS&#x2F;文件名.mdcategories:  - iOS\"></a>title:<br>date: YYYY-MM-DD<br>path: source&#x2F;iOS&#x2F;文件名.md<br>categories:<br>  - iOS</h2><p>然后放入iOS文件夹内</p>\n"},{"title":"Copy-on-write（COW）","date":"2025-07-16T16:00:00.000Z","path":"iOS/CopyOnWrite.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与原理\nCopy-on-write（写时复制，COW）是一种优化技术，多个变量共享同一内存，只有在写操作时才真正复制，Swift 的 Array、Dictionary、String 等都采用 COW。\n\n## 1.2 代码示例\n```swift\nvar a = [1,2,3]\nvar b = a // 未复制，a/b 共用内存\nb[0] = 9 // 此时 b 才复制，a 不变\n```\n\n## 1.3 业务场景\n- 大数据结构传递、缓存、性能优化。\n\n## 1.4 易混淆点\n- COW 只在值类型（struct）生效。\n- 只读不会复制，写时才复制。\n\n## 1.5 深挖追问\n- COW 如何实现？引用计数+写时检测。\n- 如何自定义 struct 支持 COW？用 isKnownUniquelyReferenced。\n\n# 2. English Answer\n\n## 2.1 Concept & Principle\nCopy-on-write (COW) is an optimization: multiple variables share memory, only copy on write. Swift's Array, Dictionary, String use COW.\n\n## 2.2 Code Example\n```swift\nvar a = [1,2,3]\nvar b = a // not copied yet\nb[0] = 9 // b is copied now, a unchanged\n```\n\n## 2.3 Business Scenarios\n- Large data passing, cache, performance.\n\n## 2.4 Common Confusions\n- COW for value types only.\n- No copy on read, only on write.\n\n## 2.5 Deep Dive\n- How COW works? Ref count + write check.\n- Custom struct COW? Use isKnownUniquelyReferenced.\n","source":"iOS/CopyOnWrite.md","raw":"---\ntitle: Copy-on-write（COW）\ndate: 2025-07-17\npath: source/iOS/CopyOnWrite.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与原理\nCopy-on-write（写时复制，COW）是一种优化技术，多个变量共享同一内存，只有在写操作时才真正复制，Swift 的 Array、Dictionary、String 等都采用 COW。\n\n## 1.2 代码示例\n```swift\nvar a = [1,2,3]\nvar b = a // 未复制，a/b 共用内存\nb[0] = 9 // 此时 b 才复制，a 不变\n```\n\n## 1.3 业务场景\n- 大数据结构传递、缓存、性能优化。\n\n## 1.4 易混淆点\n- COW 只在值类型（struct）生效。\n- 只读不会复制，写时才复制。\n\n## 1.5 深挖追问\n- COW 如何实现？引用计数+写时检测。\n- 如何自定义 struct 支持 COW？用 isKnownUniquelyReferenced。\n\n# 2. English Answer\n\n## 2.1 Concept & Principle\nCopy-on-write (COW) is an optimization: multiple variables share memory, only copy on write. Swift's Array, Dictionary, String use COW.\n\n## 2.2 Code Example\n```swift\nvar a = [1,2,3]\nvar b = a // not copied yet\nb[0] = 9 // b is copied now, a unchanged\n```\n\n## 2.3 Business Scenarios\n- Large data passing, cache, performance.\n\n## 2.4 Common Confusions\n- COW for value types only.\n- No copy on read, only on write.\n\n## 2.5 Deep Dive\n- How COW works? Ref count + write check.\n- Custom struct COW? Use isKnownUniquelyReferenced.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5k00055ek7hzw5e6sz","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p>Copy-on-write（写时复制，COW）是一种优化技术，多个变量共享同一内存，只有在写操作时才真正复制，Swift 的 Array、Dictionary、String 等都采用 COW。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a <span class=\"comment\">// 未复制，a/b 共用内存</span></span><br><span class=\"line\">b[<span class=\"number\">0</span>] <span class=\"operator\">=</span> <span class=\"number\">9</span> <span class=\"comment\">// 此时 b 才复制，a 不变</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大数据结构传递、缓存、性能优化。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>COW 只在值类型（struct）生效。</li>\n<li>只读不会复制，写时才复制。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>COW 如何实现？引用计数+写时检测。</li>\n<li>如何自定义 struct 支持 COW？用 isKnownUniquelyReferenced。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Principle\"><a href=\"#2-1-Concept-Principle\" class=\"headerlink\" title=\"2.1 Concept &amp; Principle\"></a>2.1 Concept &amp; Principle</h2><p>Copy-on-write (COW) is an optimization: multiple variables share memory, only copy on write. Swift’s Array, Dictionary, String use COW.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a <span class=\"comment\">// not copied yet</span></span><br><span class=\"line\">b[<span class=\"number\">0</span>] <span class=\"operator\">=</span> <span class=\"number\">9</span> <span class=\"comment\">// b is copied now, a unchanged</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large data passing, cache, performance.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>COW for value types only.</li>\n<li>No copy on read, only on write.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How COW works? Ref count + write check.</li>\n<li>Custom struct COW? Use isKnownUniquelyReferenced.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p>Copy-on-write（写时复制，COW）是一种优化技术，多个变量共享同一内存，只有在写操作时才真正复制，Swift 的 Array、Dictionary、String 等都采用 COW。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a <span class=\"comment\">// 未复制，a/b 共用内存</span></span><br><span class=\"line\">b[<span class=\"number\">0</span>] <span class=\"operator\">=</span> <span class=\"number\">9</span> <span class=\"comment\">// 此时 b 才复制，a 不变</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大数据结构传递、缓存、性能优化。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>COW 只在值类型（struct）生效。</li>\n<li>只读不会复制，写时才复制。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>COW 如何实现？引用计数+写时检测。</li>\n<li>如何自定义 struct 支持 COW？用 isKnownUniquelyReferenced。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Principle\"><a href=\"#2-1-Concept-Principle\" class=\"headerlink\" title=\"2.1 Concept &amp; Principle\"></a>2.1 Concept &amp; Principle</h2><p>Copy-on-write (COW) is an optimization: multiple variables share memory, only copy on write. Swift’s Array, Dictionary, String use COW.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a <span class=\"comment\">// not copied yet</span></span><br><span class=\"line\">b[<span class=\"number\">0</span>] <span class=\"operator\">=</span> <span class=\"number\">9</span> <span class=\"comment\">// b is copied now, a unchanged</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large data passing, cache, performance.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>COW for value types only.</li>\n<li>No copy on read, only on write.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How COW works? Ref count + write check.</li>\n<li>Custom struct COW? Use isKnownUniquelyReferenced.</li>\n</ul>\n"},{"title":"Error兼容NSError","date":"2025-07-16T16:00:00.000Z","path":"iOS/Error兼容NSError.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 Swift Error 与 NSError 的关系\n1. Swift 的 Error 协议用于错误类型，NSError 是 Objective-C 的错误类型。\n2. Swift 的 Error 可以自动桥接为 NSError，便于与 OC/系统 API 兼容。\n\n## 1.2 为什么要兼容？\n- 兼容 Apple 各种 API（如 Foundation、网络、文件等），便于混编和第三方库集成。\n- 保证错误信息的完整性和可追踪性。\n\n## 1.3 实际代码示例\n```swift\n// Swift 自定义 Error\nenum MyError: Error {\n    case notFound\n    case invalid\n}\n\n// 转为 NSError\nlet error: Error = MyError.notFound\nlet nsError = error as NSError\nprint(nsError.domain) // 输出 MyError\nprint(nsError.code)   // 输出 0\n\n// OC API 兼容\nfunc legacyAPICall() throws {\n    throw MyError.invalid\n}\ndo {\n    try legacyAPICall()\n} catch let error as NSError {\n    print(error.domain, error.code)\n}\n```\n\n## 1.4 业务/用户价值\n- 统一错误处理，提升用户体验。\n- 便于日志、监控和问题定位。\n\n## 1.5 易混淆点\n- Swift Error 只需遵循 Error 协议即可自动桥接。\n- NSError 需要 domain、code、userInfo，Swift Error 会自动生成。\n\n# 2. English Answer\n\n## 2.1 Relationship\n1. Swift Error protocol is for error types; NSError is Objective-C's error type.\n2. Swift Error can be automatically bridged to NSError for compatibility.\n\n## 2.2 Why compatible?\n- For Apple APIs (Foundation, networking, etc.), mixed code, and third-party integration.\n- Ensures error info completeness and traceability.\n\n## 2.3 Code Example\n```swift\nenum MyError: Error {\n    case notFound\n    case invalid\n}\n\nlet error: Error = MyError.notFound\nlet nsError = error as NSError\nprint(nsError.domain)\nprint(nsError.code)\n\ndo {\n    throw MyError.invalid\n} catch let error as NSError {\n    print(error.domain, error.code)\n}\n```\n\n## 2.4 Business/User Value\n- Unified error handling, better UX.\n- Easier logging, monitoring, and debugging.\n\n## 2.5 Common Confusion\n- Swift Error auto-bridges to NSError.\n- NSError needs domain/code/userInfo; Swift Error generates them automatically.\n","source":"iOS/Error兼容NSError.md","raw":"---\ntitle: Error兼容NSError\ndate: 2025-07-17\npath: source/iOS/Error兼容NSError.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 Swift Error 与 NSError 的关系\n1. Swift 的 Error 协议用于错误类型，NSError 是 Objective-C 的错误类型。\n2. Swift 的 Error 可以自动桥接为 NSError，便于与 OC/系统 API 兼容。\n\n## 1.2 为什么要兼容？\n- 兼容 Apple 各种 API（如 Foundation、网络、文件等），便于混编和第三方库集成。\n- 保证错误信息的完整性和可追踪性。\n\n## 1.3 实际代码示例\n```swift\n// Swift 自定义 Error\nenum MyError: Error {\n    case notFound\n    case invalid\n}\n\n// 转为 NSError\nlet error: Error = MyError.notFound\nlet nsError = error as NSError\nprint(nsError.domain) // 输出 MyError\nprint(nsError.code)   // 输出 0\n\n// OC API 兼容\nfunc legacyAPICall() throws {\n    throw MyError.invalid\n}\ndo {\n    try legacyAPICall()\n} catch let error as NSError {\n    print(error.domain, error.code)\n}\n```\n\n## 1.4 业务/用户价值\n- 统一错误处理，提升用户体验。\n- 便于日志、监控和问题定位。\n\n## 1.5 易混淆点\n- Swift Error 只需遵循 Error 协议即可自动桥接。\n- NSError 需要 domain、code、userInfo，Swift Error 会自动生成。\n\n# 2. English Answer\n\n## 2.1 Relationship\n1. Swift Error protocol is for error types; NSError is Objective-C's error type.\n2. Swift Error can be automatically bridged to NSError for compatibility.\n\n## 2.2 Why compatible?\n- For Apple APIs (Foundation, networking, etc.), mixed code, and third-party integration.\n- Ensures error info completeness and traceability.\n\n## 2.3 Code Example\n```swift\nenum MyError: Error {\n    case notFound\n    case invalid\n}\n\nlet error: Error = MyError.notFound\nlet nsError = error as NSError\nprint(nsError.domain)\nprint(nsError.code)\n\ndo {\n    throw MyError.invalid\n} catch let error as NSError {\n    print(error.domain, error.code)\n}\n```\n\n## 2.4 Business/User Value\n- Unified error handling, better UX.\n- Easier logging, monitoring, and debugging.\n\n## 2.5 Common Confusion\n- Swift Error auto-bridges to NSError.\n- NSError needs domain/code/userInfo; Swift Error generates them automatically.\n","updated":"2025-07-17T08:09:09.144Z","comments":1,"layout":"page","_id":"cmd78fh5l00075ek7eqq0cnsq","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-Swift-Error-与-NSError-的关系\"><a href=\"#1-1-Swift-Error-与-NSError-的关系\" class=\"headerlink\" title=\"1.1 Swift Error 与 NSError 的关系\"></a>1.1 Swift Error 与 NSError 的关系</h2><ol>\n<li>Swift 的 Error 协议用于错误类型，NSError 是 Objective-C 的错误类型。</li>\n<li>Swift 的 Error 可以自动桥接为 NSError，便于与 OC&#x2F;系统 API 兼容。</li>\n</ol>\n<h2 id=\"1-2-为什么要兼容？\"><a href=\"#1-2-为什么要兼容？\" class=\"headerlink\" title=\"1.2 为什么要兼容？\"></a>1.2 为什么要兼容？</h2><ul>\n<li>兼容 Apple 各种 API（如 Foundation、网络、文件等），便于混编和第三方库集成。</li>\n<li>保证错误信息的完整性和可追踪性。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Swift 自定义 Error</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">MyError</span>: <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> notFound</span><br><span class=\"line\">    <span class=\"keyword\">case</span> invalid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转为 NSError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> error: <span class=\"type\">Error</span> <span class=\"operator\">=</span> <span class=\"type\">MyError</span>.notFound</span><br><span class=\"line\"><span class=\"keyword\">let</span> nsError <span class=\"operator\">=</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.domain) <span class=\"comment\">// 输出 MyError</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.code)   <span class=\"comment\">// 输出 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OC API 兼容</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">legacyAPICall</span>() <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">MyError</span>.invalid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> legacyAPICall()</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(error.domain, error.code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>统一错误处理，提升用户体验。</li>\n<li>便于日志、监控和问题定位。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>Swift Error 只需遵循 Error 协议即可自动桥接。</li>\n<li>NSError 需要 domain、code、userInfo，Swift Error 会自动生成。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Relationship\"><a href=\"#2-1-Relationship\" class=\"headerlink\" title=\"2.1 Relationship\"></a>2.1 Relationship</h2><ol>\n<li>Swift Error protocol is for error types; NSError is Objective-C’s error type.</li>\n<li>Swift Error can be automatically bridged to NSError for compatibility.</li>\n</ol>\n<h2 id=\"2-2-Why-compatible\"><a href=\"#2-2-Why-compatible\" class=\"headerlink\" title=\"2.2 Why compatible?\"></a>2.2 Why compatible?</h2><ul>\n<li>For Apple APIs (Foundation, networking, etc.), mixed code, and third-party integration.</li>\n<li>Ensures error info completeness and traceability.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">MyError</span>: <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> notFound</span><br><span class=\"line\">    <span class=\"keyword\">case</span> invalid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> error: <span class=\"type\">Error</span> <span class=\"operator\">=</span> <span class=\"type\">MyError</span>.notFound</span><br><span class=\"line\"><span class=\"keyword\">let</span> nsError <span class=\"operator\">=</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.domain)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.code)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">MyError</span>.invalid</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(error.domain, error.code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Unified error handling, better UX.</li>\n<li>Easier logging, monitoring, and debugging.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Swift Error auto-bridges to NSError.</li>\n<li>NSError needs domain&#x2F;code&#x2F;userInfo; Swift Error generates them automatically.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-Swift-Error-与-NSError-的关系\"><a href=\"#1-1-Swift-Error-与-NSError-的关系\" class=\"headerlink\" title=\"1.1 Swift Error 与 NSError 的关系\"></a>1.1 Swift Error 与 NSError 的关系</h2><ol>\n<li>Swift 的 Error 协议用于错误类型，NSError 是 Objective-C 的错误类型。</li>\n<li>Swift 的 Error 可以自动桥接为 NSError，便于与 OC&#x2F;系统 API 兼容。</li>\n</ol>\n<h2 id=\"1-2-为什么要兼容？\"><a href=\"#1-2-为什么要兼容？\" class=\"headerlink\" title=\"1.2 为什么要兼容？\"></a>1.2 为什么要兼容？</h2><ul>\n<li>兼容 Apple 各种 API（如 Foundation、网络、文件等），便于混编和第三方库集成。</li>\n<li>保证错误信息的完整性和可追踪性。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Swift 自定义 Error</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">MyError</span>: <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> notFound</span><br><span class=\"line\">    <span class=\"keyword\">case</span> invalid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转为 NSError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> error: <span class=\"type\">Error</span> <span class=\"operator\">=</span> <span class=\"type\">MyError</span>.notFound</span><br><span class=\"line\"><span class=\"keyword\">let</span> nsError <span class=\"operator\">=</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.domain) <span class=\"comment\">// 输出 MyError</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.code)   <span class=\"comment\">// 输出 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// OC API 兼容</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">legacyAPICall</span>() <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">MyError</span>.invalid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> legacyAPICall()</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(error.domain, error.code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>统一错误处理，提升用户体验。</li>\n<li>便于日志、监控和问题定位。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>Swift Error 只需遵循 Error 协议即可自动桥接。</li>\n<li>NSError 需要 domain、code、userInfo，Swift Error 会自动生成。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Relationship\"><a href=\"#2-1-Relationship\" class=\"headerlink\" title=\"2.1 Relationship\"></a>2.1 Relationship</h2><ol>\n<li>Swift Error protocol is for error types; NSError is Objective-C’s error type.</li>\n<li>Swift Error can be automatically bridged to NSError for compatibility.</li>\n</ol>\n<h2 id=\"2-2-Why-compatible\"><a href=\"#2-2-Why-compatible\" class=\"headerlink\" title=\"2.2 Why compatible?\"></a>2.2 Why compatible?</h2><ul>\n<li>For Apple APIs (Foundation, networking, etc.), mixed code, and third-party integration.</li>\n<li>Ensures error info completeness and traceability.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">MyError</span>: <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> notFound</span><br><span class=\"line\">    <span class=\"keyword\">case</span> invalid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> error: <span class=\"type\">Error</span> <span class=\"operator\">=</span> <span class=\"type\">MyError</span>.notFound</span><br><span class=\"line\"><span class=\"keyword\">let</span> nsError <span class=\"operator\">=</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.domain)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsError.code)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">MyError</span>.invalid</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error <span class=\"keyword\">as</span> <span class=\"type\">NSError</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(error.domain, error.code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Unified error handling, better UX.</li>\n<li>Easier logging, monitoring, and debugging.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Swift Error auto-bridges to NSError.</li>\n<li>NSError needs domain&#x2F;code&#x2F;userInfo; Swift Error generates them automatically.</li>\n</ul>\n"},{"title":"KVC与KVO","date":"2025-07-16T16:00:00.000Z","path":"iOS/KVC_KVO.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与原理\n- **KVC（Key-Value Coding）**：通过字符串 key 间接访问对象属性。\n- **KVO（Key-Value Observing）**：基于 KVC 的观察机制，监听属性变化。\n\n## 1.2 代码示例\n```swift\nclass Person: NSObject {\n    @objc dynamic var name = \"\"\n}\nlet p = Person()\np.setValue(\"Tom\", forKey: \"name\") // KVC\np.addObserver(self, forKeyPath: \"name\", options: .new, context: nil) // KVO\n```\n\n## 1.3 业务场景\n- 数据绑定、UI自动刷新、MVVM 等。\n\n## 1.4 易混淆点\n- KVO 需继承 NSObject 且属性 dynamic。\n- SwiftUI/Combine 推荐用新机制。\n\n## 1.5 深挖追问\n- KVO 的原理？运行时动态生成子类，重写 setter。\n- KVO 的局限？类型安全差、易遗漏移除。\n\n# 2. English Answer\n\n## 2.1 Concept & Principle\n- **KVC**: Access properties via string key.\n- **KVO**: Observe property changes, based on KVC.\n\n## 2.2 Code Example\n```swift\nclass Person: NSObject {\n    @objc dynamic var name = \"\"\n}\nlet p = Person()\np.setValue(\"Tom\", forKey: \"name\") // KVC\np.addObserver(self, forKeyPath: \"name\", options: .new, context: nil) // KVO\n```\n\n## 2.3 Business Scenarios\n- Data binding, UI auto-refresh, MVVM, etc.\n\n## 2.4 Common Confusions\n- KVO: NSObject + dynamic.\n- SwiftUI/Combine: prefer new mechanisms.\n\n## 2.5 Deep Dive\n- KVO principle: runtime subclass, override setter.\n- KVO limitations: type safety, removal risk.\n","source":"iOS/KVC_KVO.md","raw":"---\ntitle: KVC与KVO\ndate: 2025-07-17\npath: source/iOS/KVC_KVO.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与原理\n- **KVC（Key-Value Coding）**：通过字符串 key 间接访问对象属性。\n- **KVO（Key-Value Observing）**：基于 KVC 的观察机制，监听属性变化。\n\n## 1.2 代码示例\n```swift\nclass Person: NSObject {\n    @objc dynamic var name = \"\"\n}\nlet p = Person()\np.setValue(\"Tom\", forKey: \"name\") // KVC\np.addObserver(self, forKeyPath: \"name\", options: .new, context: nil) // KVO\n```\n\n## 1.3 业务场景\n- 数据绑定、UI自动刷新、MVVM 等。\n\n## 1.4 易混淆点\n- KVO 需继承 NSObject 且属性 dynamic。\n- SwiftUI/Combine 推荐用新机制。\n\n## 1.5 深挖追问\n- KVO 的原理？运行时动态生成子类，重写 setter。\n- KVO 的局限？类型安全差、易遗漏移除。\n\n# 2. English Answer\n\n## 2.1 Concept & Principle\n- **KVC**: Access properties via string key.\n- **KVO**: Observe property changes, based on KVC.\n\n## 2.2 Code Example\n```swift\nclass Person: NSObject {\n    @objc dynamic var name = \"\"\n}\nlet p = Person()\np.setValue(\"Tom\", forKey: \"name\") // KVC\np.addObserver(self, forKeyPath: \"name\", options: .new, context: nil) // KVO\n```\n\n## 2.3 Business Scenarios\n- Data binding, UI auto-refresh, MVVM, etc.\n\n## 2.4 Common Confusions\n- KVO: NSObject + dynamic.\n- SwiftUI/Combine: prefer new mechanisms.\n\n## 2.5 Deep Dive\n- KVO principle: runtime subclass, override setter.\n- KVO limitations: type safety, removal risk.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5l00095ek75p25erqf","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ul>\n<li><strong>KVC（Key-Value Coding）</strong>：通过字符串 key 间接访问对象属性。</li>\n<li><strong>KVO（Key-Value Observing）</strong>：基于 KVC 的观察机制，监听属性变化。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>: <span class=\"title class_ inherited__\">NSObject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> name <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">p.setValue(<span class=\"string\">&quot;Tom&quot;</span>, forKey: <span class=\"string\">&quot;name&quot;</span>) <span class=\"comment\">// KVC</span></span><br><span class=\"line\">p.addObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">&quot;name&quot;</span>, options: .new, context: <span class=\"literal\">nil</span>) <span class=\"comment\">// KVO</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>数据绑定、UI自动刷新、MVVM 等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>KVO 需继承 NSObject 且属性 dynamic。</li>\n<li>SwiftUI&#x2F;Combine 推荐用新机制。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>KVO 的原理？运行时动态生成子类，重写 setter。</li>\n<li>KVO 的局限？类型安全差、易遗漏移除。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Principle\"><a href=\"#2-1-Concept-Principle\" class=\"headerlink\" title=\"2.1 Concept &amp; Principle\"></a>2.1 Concept &amp; Principle</h2><ul>\n<li><strong>KVC</strong>: Access properties via string key.</li>\n<li><strong>KVO</strong>: Observe property changes, based on KVC.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>: <span class=\"title class_ inherited__\">NSObject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> name <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">p.setValue(<span class=\"string\">&quot;Tom&quot;</span>, forKey: <span class=\"string\">&quot;name&quot;</span>) <span class=\"comment\">// KVC</span></span><br><span class=\"line\">p.addObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">&quot;name&quot;</span>, options: .new, context: <span class=\"literal\">nil</span>) <span class=\"comment\">// KVO</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Data binding, UI auto-refresh, MVVM, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>KVO: NSObject + dynamic.</li>\n<li>SwiftUI&#x2F;Combine: prefer new mechanisms.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>KVO principle: runtime subclass, override setter.</li>\n<li>KVO limitations: type safety, removal risk.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ul>\n<li><strong>KVC（Key-Value Coding）</strong>：通过字符串 key 间接访问对象属性。</li>\n<li><strong>KVO（Key-Value Observing）</strong>：基于 KVC 的观察机制，监听属性变化。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>: <span class=\"title class_ inherited__\">NSObject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> name <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">p.setValue(<span class=\"string\">&quot;Tom&quot;</span>, forKey: <span class=\"string\">&quot;name&quot;</span>) <span class=\"comment\">// KVC</span></span><br><span class=\"line\">p.addObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">&quot;name&quot;</span>, options: .new, context: <span class=\"literal\">nil</span>) <span class=\"comment\">// KVO</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>数据绑定、UI自动刷新、MVVM 等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>KVO 需继承 NSObject 且属性 dynamic。</li>\n<li>SwiftUI&#x2F;Combine 推荐用新机制。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>KVO 的原理？运行时动态生成子类，重写 setter。</li>\n<li>KVO 的局限？类型安全差、易遗漏移除。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Principle\"><a href=\"#2-1-Concept-Principle\" class=\"headerlink\" title=\"2.1 Concept &amp; Principle\"></a>2.1 Concept &amp; Principle</h2><ul>\n<li><strong>KVC</strong>: Access properties via string key.</li>\n<li><strong>KVO</strong>: Observe property changes, based on KVC.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>: <span class=\"title class_ inherited__\">NSObject</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">dynamic</span> <span class=\"keyword\">var</span> name <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">p.setValue(<span class=\"string\">&quot;Tom&quot;</span>, forKey: <span class=\"string\">&quot;name&quot;</span>) <span class=\"comment\">// KVC</span></span><br><span class=\"line\">p.addObserver(<span class=\"keyword\">self</span>, forKeyPath: <span class=\"string\">&quot;name&quot;</span>, options: .new, context: <span class=\"literal\">nil</span>) <span class=\"comment\">// KVO</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Data binding, UI auto-refresh, MVVM, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>KVO: NSObject + dynamic.</li>\n<li>SwiftUI&#x2F;Combine: prefer new mechanisms.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>KVO principle: runtime subclass, override setter.</li>\n<li>KVO limitations: type safety, removal risk.</li>\n</ul>\n"},{"title":"Open与Public的区别","date":"2025-07-16T16:00:00.000Z","path":"iOS/OpenPublic区别.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与本质区别\n1. **open**：允许模块外继承和重写（子类化/override）。\n2. **public**：允许模块外访问，但不允许继承和重写。\n\n## 1.2 为什么要区分？\n- **安全性**：public 只暴露接口，防止外部随意扩展，保护内部实现。\n- **灵活性**：open 适合做框架/库，允许外部自定义扩展。\n\n## 1.3 实际代码示例\n```swift\nopen class Animal {\n    open func speak() { print(\"Animal\") }\n}\n\npublic class Person {\n    public func sayHi() { print(\"Hi\") }\n}\n\n// 其他模块\nclass Dog: Animal { // ✅ 允许继承\n    override func speak() { print(\"Dog\") }\n}\n\n// class Student: Person {} // ❌ 不允许继承\n```\n\n## 1.4 业务/用户价值\n- open 适合 SDK/框架，便于二次开发。\n- public 适合只读 API，保证产品稳定。\n\n## 1.5 易混淆点\n- open = public + 允许继承/重写。\n- public 只能访问，不能扩展。\n\n# 2. English Answer\n\n## 2.1 Concept and Key Difference\n1. **open**: Allows subclassing/overriding outside the module.\n2. **public**: Allows access but not subclassing/overriding outside the module.\n\n## 2.2 Why distinguish?\n- **Security**: public exposes API but prevents external extension.\n- **Flexibility**: open is for frameworks, allows external customization.\n\n## 2.3 Code Example\n```swift\nopen class Animal {\n    open func speak() { print(\"Animal\") }\n}\n\npublic class Person {\n    public func sayHi() { print(\"Hi\") }\n}\n\n// Other module\nclass Dog: Animal { // ✅ Allowed\n    override func speak() { print(\"Dog\") }\n}\n\n// class Student: Person {} // ❌ Not allowed\n```\n\n## 2.4 Business/User Value\n- open: for SDK/framework, supports extension.\n- public: for read-only API, ensures stability.\n\n## 2.5 Common Confusion\n- open = public + subclass/override allowed.\n- public: only access, no extension.\n","source":"iOS/OpenPublic区别.md","raw":"---\ntitle: Open与Public的区别\ndate: 2025-07-17\npath: source/iOS/OpenPublic区别.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与本质区别\n1. **open**：允许模块外继承和重写（子类化/override）。\n2. **public**：允许模块外访问，但不允许继承和重写。\n\n## 1.2 为什么要区分？\n- **安全性**：public 只暴露接口，防止外部随意扩展，保护内部实现。\n- **灵活性**：open 适合做框架/库，允许外部自定义扩展。\n\n## 1.3 实际代码示例\n```swift\nopen class Animal {\n    open func speak() { print(\"Animal\") }\n}\n\npublic class Person {\n    public func sayHi() { print(\"Hi\") }\n}\n\n// 其他模块\nclass Dog: Animal { // ✅ 允许继承\n    override func speak() { print(\"Dog\") }\n}\n\n// class Student: Person {} // ❌ 不允许继承\n```\n\n## 1.4 业务/用户价值\n- open 适合 SDK/框架，便于二次开发。\n- public 适合只读 API，保证产品稳定。\n\n## 1.5 易混淆点\n- open = public + 允许继承/重写。\n- public 只能访问，不能扩展。\n\n# 2. English Answer\n\n## 2.1 Concept and Key Difference\n1. **open**: Allows subclassing/overriding outside the module.\n2. **public**: Allows access but not subclassing/overriding outside the module.\n\n## 2.2 Why distinguish?\n- **Security**: public exposes API but prevents external extension.\n- **Flexibility**: open is for frameworks, allows external customization.\n\n## 2.3 Code Example\n```swift\nopen class Animal {\n    open func speak() { print(\"Animal\") }\n}\n\npublic class Person {\n    public func sayHi() { print(\"Hi\") }\n}\n\n// Other module\nclass Dog: Animal { // ✅ Allowed\n    override func speak() { print(\"Dog\") }\n}\n\n// class Student: Person {} // ❌ Not allowed\n```\n\n## 2.4 Business/User Value\n- open: for SDK/framework, supports extension.\n- public: for read-only API, ensures stability.\n\n## 2.5 Common Confusion\n- open = public + subclass/override allowed.\n- public: only access, no extension.\n","updated":"2025-07-17T08:09:09.144Z","comments":1,"layout":"page","_id":"cmd78fh5m000c5ek77nztf0jb","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与本质区别\"><a href=\"#1-1-概念与本质区别\" class=\"headerlink\" title=\"1.1 概念与本质区别\"></a>1.1 概念与本质区别</h2><ol>\n<li><strong>open</strong>：允许模块外继承和重写（子类化&#x2F;override）。</li>\n<li><strong>public</strong>：允许模块外访问，但不允许继承和重写。</li>\n</ol>\n<h2 id=\"1-2-为什么要区分？\"><a href=\"#1-2-为什么要区分？\" class=\"headerlink\" title=\"1.2 为什么要区分？\"></a>1.2 为什么要区分？</h2><ul>\n<li><strong>安全性</strong>：public 只暴露接口，防止外部随意扩展，保护内部实现。</li>\n<li><strong>灵活性</strong>：open 适合做框架&#x2F;库，允许外部自定义扩展。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Animal&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sayHi</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hi&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他模块</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span>: <span class=\"title class_ inherited__\">Animal</span> &#123; <span class=\"comment\">// ✅ 允许继承</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Dog&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class Student: Person &#123;&#125; // ❌ 不允许继承</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>open 适合 SDK&#x2F;框架，便于二次开发。</li>\n<li>public 适合只读 API，保证产品稳定。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>open &#x3D; public + 允许继承&#x2F;重写。</li>\n<li>public 只能访问，不能扩展。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-and-Key-Difference\"><a href=\"#2-1-Concept-and-Key-Difference\" class=\"headerlink\" title=\"2.1 Concept and Key Difference\"></a>2.1 Concept and Key Difference</h2><ol>\n<li><strong>open</strong>: Allows subclassing&#x2F;overriding outside the module.</li>\n<li><strong>public</strong>: Allows access but not subclassing&#x2F;overriding outside the module.</li>\n</ol>\n<h2 id=\"2-2-Why-distinguish\"><a href=\"#2-2-Why-distinguish\" class=\"headerlink\" title=\"2.2 Why distinguish?\"></a>2.2 Why distinguish?</h2><ul>\n<li><strong>Security</strong>: public exposes API but prevents external extension.</li>\n<li><strong>Flexibility</strong>: open is for frameworks, allows external customization.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Animal&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sayHi</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hi&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Other module</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span>: <span class=\"title class_ inherited__\">Animal</span> &#123; <span class=\"comment\">// ✅ Allowed</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Dog&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class Student: Person &#123;&#125; // ❌ Not allowed</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>open: for SDK&#x2F;framework, supports extension.</li>\n<li>public: for read-only API, ensures stability.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>open &#x3D; public + subclass&#x2F;override allowed.</li>\n<li>public: only access, no extension.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与本质区别\"><a href=\"#1-1-概念与本质区别\" class=\"headerlink\" title=\"1.1 概念与本质区别\"></a>1.1 概念与本质区别</h2><ol>\n<li><strong>open</strong>：允许模块外继承和重写（子类化&#x2F;override）。</li>\n<li><strong>public</strong>：允许模块外访问，但不允许继承和重写。</li>\n</ol>\n<h2 id=\"1-2-为什么要区分？\"><a href=\"#1-2-为什么要区分？\" class=\"headerlink\" title=\"1.2 为什么要区分？\"></a>1.2 为什么要区分？</h2><ul>\n<li><strong>安全性</strong>：public 只暴露接口，防止外部随意扩展，保护内部实现。</li>\n<li><strong>灵活性</strong>：open 适合做框架&#x2F;库，允许外部自定义扩展。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Animal&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sayHi</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hi&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他模块</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span>: <span class=\"title class_ inherited__\">Animal</span> &#123; <span class=\"comment\">// ✅ 允许继承</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Dog&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class Student: Person &#123;&#125; // ❌ 不允许继承</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>open 适合 SDK&#x2F;框架，便于二次开发。</li>\n<li>public 适合只读 API，保证产品稳定。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>open &#x3D; public + 允许继承&#x2F;重写。</li>\n<li>public 只能访问，不能扩展。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-and-Key-Difference\"><a href=\"#2-1-Concept-and-Key-Difference\" class=\"headerlink\" title=\"2.1 Concept and Key Difference\"></a>2.1 Concept and Key Difference</h2><ol>\n<li><strong>open</strong>: Allows subclassing&#x2F;overriding outside the module.</li>\n<li><strong>public</strong>: Allows access but not subclassing&#x2F;overriding outside the module.</li>\n</ol>\n<h2 id=\"2-2-Why-distinguish\"><a href=\"#2-2-Why-distinguish\" class=\"headerlink\" title=\"2.2 Why distinguish?\"></a>2.2 Why distinguish?</h2><ul>\n<li><strong>Security</strong>: public exposes API but prevents external extension.</li>\n<li><strong>Flexibility</strong>: open is for frameworks, allows external customization.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Animal&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sayHi</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hi&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Other module</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span>: <span class=\"title class_ inherited__\">Animal</span> &#123; <span class=\"comment\">// ✅ Allowed</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Dog&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class Student: Person &#123;&#125; // ❌ Not allowed</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>open: for SDK&#x2F;framework, supports extension.</li>\n<li>public: for read-only API, ensures stability.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>open &#x3D; public + subclass&#x2F;override allowed.</li>\n<li>public: only access, no extension.</li>\n</ul>\n"},{"title":"String与NSString的关系与区别","date":"2025-07-16T16:00:00.000Z","path":"iOS/String与NSString区别.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 关系与区别\n1. String 是 Swift 的原生字符串类型，NSString 是 OC 的字符串类。\n2. String 与 NSString 可以自动桥接，互相转换。\n3. String 是值类型（struct），NSString 是引用类型（class）。\n\n## 1.2 为什么要这样设计？\n- String 采用值类型，提升性能和安全性，支持 copy-on-write。\n- 兼容 OC 生态，便于混编。\n\n## 1.3 实际代码示例\n```swift\nlet swiftStr: String = \"Hello\"\nlet ocStr: NSString = swiftStr as NSString\nlet swiftStr2: String = ocStr as String\n\n// 值类型特性\nvar a = \"abc\"\nvar b = a\nb += \"d\"\nprint(a) // \"abc\"\nprint(b) // \"abcd\"\n```\n\n## 1.4 业务/用户价值\n- 性能更优，线程安全。\n- 兼容 OC，便于迁移和集成。\n\n## 1.5 易混淆点\n- String 是 struct，NSString 是 class。\n- String 支持更多 Swift 特性（如泛型、协议扩展等）。\n\n# 2. English Answer\n\n## 2.1 Relationship and Difference\n1. String: native Swift string type; NSString: Objective-C class.\n2. String and NSString are automatically bridged.\n3. String is a value type (struct), NSString is a reference type (class).\n\n## 2.2 Why this design?\n- String as value type: better performance, safety, COW.\n- OC compatibility for mixed code.\n\n## 2.3 Code Example\n```swift\nlet swiftStr: String = \"Hello\"\nlet ocStr: NSString = swiftStr as NSString\nlet swiftStr2: String = ocStr as String\n\nvar a = \"abc\"\nvar b = a\nb += \"d\"\nprint(a) // \"abc\"\nprint(b) // \"abcd\"\n```\n\n## 2.4 Business/User Value\n- Better performance, thread safety.\n- OC compatibility, easier migration/integration.\n\n## 2.5 Common Confusion\n- String is struct, NSString is class.\n- String supports more Swift features (generics, protocol extensions, etc).\n","source":"iOS/String与NSString区别.md","raw":"---\ntitle: String与NSString的关系与区别\ndate: 2025-07-17\npath: source/iOS/String与NSString区别.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 关系与区别\n1. String 是 Swift 的原生字符串类型，NSString 是 OC 的字符串类。\n2. String 与 NSString 可以自动桥接，互相转换。\n3. String 是值类型（struct），NSString 是引用类型（class）。\n\n## 1.2 为什么要这样设计？\n- String 采用值类型，提升性能和安全性，支持 copy-on-write。\n- 兼容 OC 生态，便于混编。\n\n## 1.3 实际代码示例\n```swift\nlet swiftStr: String = \"Hello\"\nlet ocStr: NSString = swiftStr as NSString\nlet swiftStr2: String = ocStr as String\n\n// 值类型特性\nvar a = \"abc\"\nvar b = a\nb += \"d\"\nprint(a) // \"abc\"\nprint(b) // \"abcd\"\n```\n\n## 1.4 业务/用户价值\n- 性能更优，线程安全。\n- 兼容 OC，便于迁移和集成。\n\n## 1.5 易混淆点\n- String 是 struct，NSString 是 class。\n- String 支持更多 Swift 特性（如泛型、协议扩展等）。\n\n# 2. English Answer\n\n## 2.1 Relationship and Difference\n1. String: native Swift string type; NSString: Objective-C class.\n2. String and NSString are automatically bridged.\n3. String is a value type (struct), NSString is a reference type (class).\n\n## 2.2 Why this design?\n- String as value type: better performance, safety, COW.\n- OC compatibility for mixed code.\n\n## 2.3 Code Example\n```swift\nlet swiftStr: String = \"Hello\"\nlet ocStr: NSString = swiftStr as NSString\nlet swiftStr2: String = ocStr as String\n\nvar a = \"abc\"\nvar b = a\nb += \"d\"\nprint(a) // \"abc\"\nprint(b) // \"abcd\"\n```\n\n## 2.4 Business/User Value\n- Better performance, thread safety.\n- OC compatibility, easier migration/integration.\n\n## 2.5 Common Confusion\n- String is struct, NSString is class.\n- String supports more Swift features (generics, protocol extensions, etc).\n","updated":"2025-07-17T08:12:29.918Z","comments":1,"layout":"page","_id":"cmd78fh5m000d5ek728gi2qy0","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-关系与区别\"><a href=\"#1-1-关系与区别\" class=\"headerlink\" title=\"1.1 关系与区别\"></a>1.1 关系与区别</h2><ol>\n<li>String 是 Swift 的原生字符串类型，NSString 是 OC 的字符串类。</li>\n<li>String 与 NSString 可以自动桥接，互相转换。</li>\n<li>String 是值类型（struct），NSString 是引用类型（class）。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>String 采用值类型，提升性能和安全性，支持 copy-on-write。</li>\n<li>兼容 OC 生态，便于混编。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> swiftStr: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ocStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> swiftStr <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> swiftStr2: <span class=\"type\">String</span> <span class=\"operator\">=</span> ocStr <span class=\"keyword\">as</span> <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 值类型特性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a</span><br><span class=\"line\">b <span class=\"operator\">+=</span> <span class=\"string\">&quot;d&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a) <span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b) <span class=\"comment\">// &quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>性能更优，线程安全。</li>\n<li>兼容 OC，便于迁移和集成。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>String 是 struct，NSString 是 class。</li>\n<li>String 支持更多 Swift 特性（如泛型、协议扩展等）。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Relationship-and-Difference\"><a href=\"#2-1-Relationship-and-Difference\" class=\"headerlink\" title=\"2.1 Relationship and Difference\"></a>2.1 Relationship and Difference</h2><ol>\n<li>String: native Swift string type; NSString: Objective-C class.</li>\n<li>String and NSString are automatically bridged.</li>\n<li>String is a value type (struct), NSString is a reference type (class).</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>String as value type: better performance, safety, COW.</li>\n<li>OC compatibility for mixed code.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> swiftStr: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ocStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> swiftStr <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> swiftStr2: <span class=\"type\">String</span> <span class=\"operator\">=</span> ocStr <span class=\"keyword\">as</span> <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a</span><br><span class=\"line\">b <span class=\"operator\">+=</span> <span class=\"string\">&quot;d&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a) <span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b) <span class=\"comment\">// &quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Better performance, thread safety.</li>\n<li>OC compatibility, easier migration&#x2F;integration.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>String is struct, NSString is class.</li>\n<li>String supports more Swift features (generics, protocol extensions, etc).</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-关系与区别\"><a href=\"#1-1-关系与区别\" class=\"headerlink\" title=\"1.1 关系与区别\"></a>1.1 关系与区别</h2><ol>\n<li>String 是 Swift 的原生字符串类型，NSString 是 OC 的字符串类。</li>\n<li>String 与 NSString 可以自动桥接，互相转换。</li>\n<li>String 是值类型（struct），NSString 是引用类型（class）。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>String 采用值类型，提升性能和安全性，支持 copy-on-write。</li>\n<li>兼容 OC 生态，便于混编。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> swiftStr: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ocStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> swiftStr <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> swiftStr2: <span class=\"type\">String</span> <span class=\"operator\">=</span> ocStr <span class=\"keyword\">as</span> <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 值类型特性</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a</span><br><span class=\"line\">b <span class=\"operator\">+=</span> <span class=\"string\">&quot;d&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a) <span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b) <span class=\"comment\">// &quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>性能更优，线程安全。</li>\n<li>兼容 OC，便于迁移和集成。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>String 是 struct，NSString 是 class。</li>\n<li>String 支持更多 Swift 特性（如泛型、协议扩展等）。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Relationship-and-Difference\"><a href=\"#2-1-Relationship-and-Difference\" class=\"headerlink\" title=\"2.1 Relationship and Difference\"></a>2.1 Relationship and Difference</h2><ol>\n<li>String: native Swift string type; NSString: Objective-C class.</li>\n<li>String and NSString are automatically bridged.</li>\n<li>String is a value type (struct), NSString is a reference type (class).</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>String as value type: better performance, safety, COW.</li>\n<li>OC compatibility for mixed code.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> swiftStr: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ocStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> swiftStr <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> swiftStr2: <span class=\"type\">String</span> <span class=\"operator\">=</span> ocStr <span class=\"keyword\">as</span> <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b <span class=\"operator\">=</span> a</span><br><span class=\"line\">b <span class=\"operator\">+=</span> <span class=\"string\">&quot;d&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a) <span class=\"comment\">// &quot;abc&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b) <span class=\"comment\">// &quot;abcd&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Better performance, thread safety.</li>\n<li>OC compatibility, easier migration&#x2F;integration.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>String is struct, NSString is class.</li>\n<li>String supports more Swift features (generics, protocol extensions, etc).</li>\n</ul>\n"},{"title":"RxSwift 核心原理与业务应用","date":"2025-07-16T16:00:00.000Z","path":"iOS/RxSwift核心原理与应用.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与核心思想\nRxSwift 是响应式编程框架，核心是 Observable（可观察序列）、Observer（观察者）、操作符链式组合，支持异步事件流处理。\n\n## 1.2 代码示例\n```swift\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n    .map { $0 * 2 }\n    .subscribe(onNext: { print($0) })\n    .disposed(by: disposeBag)\n```\n\n## 1.3 业务场景\n- UI 绑定、网络请求、表单校验、事件流转等。\n\n## 1.4 易混淆点\n- RxSwift 不是多线程库，但可结合调度器实现线程切换。\n- 资源释放靠 DisposeBag。\n\n## 1.5 深挖追问\n- RxSwift 如何避免回调地狱？链式组合、统一错误处理。\n- 与 Combine 区别？Combine 是苹果官方，API 更 Swifty。\n\n# 2. English Answer\n\n## 2.1 Concept & Core Idea\nRxSwift is a reactive framework: Observable, Observer, operator chaining, async event stream.\n\n## 2.2 Code Example\n```swift\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n    .map { $0 * 2 }\n    .subscribe(onNext: { print($0) })\n    .disposed(by: disposeBag)\n```\n\n## 2.3 Business Scenarios\n- UI binding, network, form validation, event flow, etc.\n\n## 2.4 Common Confusions\n- RxSwift is not a threading lib, but supports schedulers.\n- DisposeBag for resource release.\n\n## 2.5 Deep Dive\n- How avoids callback hell? Chaining, unified error handling.\n- Difference with Combine? Combine is official, more Swifty.\n","source":"iOS/RxSwift核心原理与应用.md","raw":"---\ntitle: RxSwift 核心原理与业务应用\ndate: 2025-07-17\npath: source/iOS/RxSwift核心原理与应用.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与核心思想\nRxSwift 是响应式编程框架，核心是 Observable（可观察序列）、Observer（观察者）、操作符链式组合，支持异步事件流处理。\n\n## 1.2 代码示例\n```swift\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n    .map { $0 * 2 }\n    .subscribe(onNext: { print($0) })\n    .disposed(by: disposeBag)\n```\n\n## 1.3 业务场景\n- UI 绑定、网络请求、表单校验、事件流转等。\n\n## 1.4 易混淆点\n- RxSwift 不是多线程库，但可结合调度器实现线程切换。\n- 资源释放靠 DisposeBag。\n\n## 1.5 深挖追问\n- RxSwift 如何避免回调地狱？链式组合、统一错误处理。\n- 与 Combine 区别？Combine 是苹果官方，API 更 Swifty。\n\n# 2. English Answer\n\n## 2.1 Concept & Core Idea\nRxSwift is a reactive framework: Observable, Observer, operator chaining, async event stream.\n\n## 2.2 Code Example\n```swift\nlet disposeBag = DisposeBag()\nObservable.of(1,2,3)\n    .map { $0 * 2 }\n    .subscribe(onNext: { print($0) })\n    .disposed(by: disposeBag)\n```\n\n## 2.3 Business Scenarios\n- UI binding, network, form validation, event flow, etc.\n\n## 2.4 Common Confusions\n- RxSwift is not a threading lib, but supports schedulers.\n- DisposeBag for resource release.\n\n## 2.5 Deep Dive\n- How avoids callback hell? Chaining, unified error handling.\n- Difference with Combine? Combine is official, more Swifty.\n","updated":"2025-07-17T10:11:29.164Z","comments":1,"layout":"page","_id":"cmd78fh5m000g5ek7cpdub7zz","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与核心思想\"><a href=\"#1-1-概念与核心思想\" class=\"headerlink\" title=\"1.1 概念与核心思想\"></a>1.1 概念与核心思想</h2><p>RxSwift 是响应式编程框架，核心是 Observable（可观察序列）、Observer（观察者）、操作符链式组合，支持异步事件流处理。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> disposeBag <span class=\"operator\">=</span> <span class=\"type\">DisposeBag</span>()</span><br><span class=\"line\"><span class=\"type\">Observable</span>.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    .map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">    .subscribe(onNext: &#123; <span class=\"built_in\">print</span>(<span class=\"variable\">$0</span>) &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>UI 绑定、网络请求、表单校验、事件流转等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>RxSwift 不是多线程库，但可结合调度器实现线程切换。</li>\n<li>资源释放靠 DisposeBag。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>RxSwift 如何避免回调地狱？链式组合、统一错误处理。</li>\n<li>与 Combine 区别？Combine 是苹果官方，API 更 Swifty。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Core-Idea\"><a href=\"#2-1-Concept-Core-Idea\" class=\"headerlink\" title=\"2.1 Concept &amp; Core Idea\"></a>2.1 Concept &amp; Core Idea</h2><p>RxSwift is a reactive framework: Observable, Observer, operator chaining, async event stream.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> disposeBag <span class=\"operator\">=</span> <span class=\"type\">DisposeBag</span>()</span><br><span class=\"line\"><span class=\"type\">Observable</span>.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    .map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">    .subscribe(onNext: &#123; <span class=\"built_in\">print</span>(<span class=\"variable\">$0</span>) &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>UI binding, network, form validation, event flow, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>RxSwift is not a threading lib, but supports schedulers.</li>\n<li>DisposeBag for resource release.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How avoids callback hell? Chaining, unified error handling.</li>\n<li>Difference with Combine? Combine is official, more Swifty.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与核心思想\"><a href=\"#1-1-概念与核心思想\" class=\"headerlink\" title=\"1.1 概念与核心思想\"></a>1.1 概念与核心思想</h2><p>RxSwift 是响应式编程框架，核心是 Observable（可观察序列）、Observer（观察者）、操作符链式组合，支持异步事件流处理。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> disposeBag <span class=\"operator\">=</span> <span class=\"type\">DisposeBag</span>()</span><br><span class=\"line\"><span class=\"type\">Observable</span>.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    .map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">    .subscribe(onNext: &#123; <span class=\"built_in\">print</span>(<span class=\"variable\">$0</span>) &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>UI 绑定、网络请求、表单校验、事件流转等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>RxSwift 不是多线程库，但可结合调度器实现线程切换。</li>\n<li>资源释放靠 DisposeBag。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>RxSwift 如何避免回调地狱？链式组合、统一错误处理。</li>\n<li>与 Combine 区别？Combine 是苹果官方，API 更 Swifty。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Core-Idea\"><a href=\"#2-1-Concept-Core-Idea\" class=\"headerlink\" title=\"2.1 Concept &amp; Core Idea\"></a>2.1 Concept &amp; Core Idea</h2><p>RxSwift is a reactive framework: Observable, Observer, operator chaining, async event stream.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> disposeBag <span class=\"operator\">=</span> <span class=\"type\">DisposeBag</span>()</span><br><span class=\"line\"><span class=\"type\">Observable</span>.of(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">    .map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">    .subscribe(onNext: &#123; <span class=\"built_in\">print</span>(<span class=\"variable\">$0</span>) &#125;)</span><br><span class=\"line\">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>UI binding, network, form validation, event flow, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>RxSwift is not a threading lib, but supports schedulers.</li>\n<li>DisposeBag for resource release.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How avoids callback hell? Chaining, unified error handling.</li>\n<li>Difference with Combine? Combine is official, more Swifty.</li>\n</ul>\n"},{"title":"获取一个String的长度","date":"2025-07-16T16:00:00.000Z","path":"iOS/String长度获取.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 获取方式\n1. 使用 `count` 属性获取字符数。\n2. 注意 Swift 的 String 支持 Unicode，count 统计的是字符（而非字节）。\n\n## 1.2 为什么要这样设计？\n- 保证多语言/表情符号等复杂字符的正确统计。\n- 提升国际化和用户体验。\n\n## 1.3 实际代码示例\n```swift\nlet str = \"你好abc😊\"\nprint(str.count) // 6\n\nlet nsStr: NSString = str as NSString\nprint(nsStr.length) // 8（UTF-16 单元数）\n```\n\n## 1.4 业务/用户价值\n- 保证字符统计准确，避免 UI 错位或截断。\n- 支持多语言和表情，提升产品国际化能力。\n\n## 1.5 易混淆点\n- String.count 是字符数，NSString.length 是 UTF-16 单元数。\n- 部分 emoji/特殊字符在 NSString.length 下会统计为2。\n\n# 2. English Answer\n\n## 2.1 How to get String length\n1. Use `count` property for character count.\n2. Swift String supports Unicode, count is for characters, not bytes.\n\n## 2.2 Why this design?\n- Ensures correct count for multi-language/emoji.\n- Better i18n and UX.\n\n## 2.3 Code Example\n```swift\nlet str = \"你好abc😊\"\nprint(str.count) // 6\n\nlet nsStr: NSString = str as NSString\nprint(nsStr.length) // 8 (UTF-16 units)\n```\n\n## 2.4 Business/User Value\n- Accurate character count, avoids UI bugs.\n- Supports i18n and emoji, better product reach.\n\n## 2.5 Common Confusion\n- String.count = character count, NSString.length = UTF-16 units.\n- Some emoji/special chars count as 2 in NSString.length.\n","source":"iOS/String长度获取.md","raw":"---\ntitle: 获取一个String的长度\ndate: 2025-07-17\npath: source/iOS/String长度获取.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 获取方式\n1. 使用 `count` 属性获取字符数。\n2. 注意 Swift 的 String 支持 Unicode，count 统计的是字符（而非字节）。\n\n## 1.2 为什么要这样设计？\n- 保证多语言/表情符号等复杂字符的正确统计。\n- 提升国际化和用户体验。\n\n## 1.3 实际代码示例\n```swift\nlet str = \"你好abc😊\"\nprint(str.count) // 6\n\nlet nsStr: NSString = str as NSString\nprint(nsStr.length) // 8（UTF-16 单元数）\n```\n\n## 1.4 业务/用户价值\n- 保证字符统计准确，避免 UI 错位或截断。\n- 支持多语言和表情，提升产品国际化能力。\n\n## 1.5 易混淆点\n- String.count 是字符数，NSString.length 是 UTF-16 单元数。\n- 部分 emoji/特殊字符在 NSString.length 下会统计为2。\n\n# 2. English Answer\n\n## 2.1 How to get String length\n1. Use `count` property for character count.\n2. Swift String supports Unicode, count is for characters, not bytes.\n\n## 2.2 Why this design?\n- Ensures correct count for multi-language/emoji.\n- Better i18n and UX.\n\n## 2.3 Code Example\n```swift\nlet str = \"你好abc😊\"\nprint(str.count) // 6\n\nlet nsStr: NSString = str as NSString\nprint(nsStr.length) // 8 (UTF-16 units)\n```\n\n## 2.4 Business/User Value\n- Accurate character count, avoids UI bugs.\n- Supports i18n and emoji, better product reach.\n\n## 2.5 Common Confusion\n- String.count = character count, NSString.length = UTF-16 units.\n- Some emoji/special chars count as 2 in NSString.length.\n","updated":"2025-07-17T08:12:29.918Z","comments":1,"layout":"page","_id":"cmd78fh5m000i5ek76lgb61mo","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-获取方式\"><a href=\"#1-1-获取方式\" class=\"headerlink\" title=\"1.1 获取方式\"></a>1.1 获取方式</h2><ol>\n<li>使用 <code>count</code> 属性获取字符数。</li>\n<li>注意 Swift 的 String 支持 Unicode，count 统计的是字符（而非字节）。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证多语言&#x2F;表情符号等复杂字符的正确统计。</li>\n<li>提升国际化和用户体验。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"string\">&quot;你好abc😊&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str.count) <span class=\"comment\">// 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> str <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsStr.length) <span class=\"comment\">// 8（UTF-16 单元数）</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>保证字符统计准确，避免 UI 错位或截断。</li>\n<li>支持多语言和表情，提升产品国际化能力。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>String.count 是字符数，NSString.length 是 UTF-16 单元数。</li>\n<li>部分 emoji&#x2F;特殊字符在 NSString.length 下会统计为2。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-How-to-get-String-length\"><a href=\"#2-1-How-to-get-String-length\" class=\"headerlink\" title=\"2.1 How to get String length\"></a>2.1 How to get String length</h2><ol>\n<li>Use <code>count</code> property for character count.</li>\n<li>Swift String supports Unicode, count is for characters, not bytes.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures correct count for multi-language&#x2F;emoji.</li>\n<li>Better i18n and UX.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"string\">&quot;你好abc😊&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str.count) <span class=\"comment\">// 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> str <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsStr.length) <span class=\"comment\">// 8 (UTF-16 units)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Accurate character count, avoids UI bugs.</li>\n<li>Supports i18n and emoji, better product reach.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>String.count &#x3D; character count, NSString.length &#x3D; UTF-16 units.</li>\n<li>Some emoji&#x2F;special chars count as 2 in NSString.length.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-获取方式\"><a href=\"#1-1-获取方式\" class=\"headerlink\" title=\"1.1 获取方式\"></a>1.1 获取方式</h2><ol>\n<li>使用 <code>count</code> 属性获取字符数。</li>\n<li>注意 Swift 的 String 支持 Unicode，count 统计的是字符（而非字节）。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证多语言&#x2F;表情符号等复杂字符的正确统计。</li>\n<li>提升国际化和用户体验。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"string\">&quot;你好abc😊&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str.count) <span class=\"comment\">// 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> str <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsStr.length) <span class=\"comment\">// 8（UTF-16 单元数）</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>保证字符统计准确，避免 UI 错位或截断。</li>\n<li>支持多语言和表情，提升产品国际化能力。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>String.count 是字符数，NSString.length 是 UTF-16 单元数。</li>\n<li>部分 emoji&#x2F;特殊字符在 NSString.length 下会统计为2。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-How-to-get-String-length\"><a href=\"#2-1-How-to-get-String-length\" class=\"headerlink\" title=\"2.1 How to get String length\"></a>2.1 How to get String length</h2><ol>\n<li>Use <code>count</code> property for character count.</li>\n<li>Swift String supports Unicode, count is for characters, not bytes.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures correct count for multi-language&#x2F;emoji.</li>\n<li>Better i18n and UX.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"string\">&quot;你好abc😊&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(str.count) <span class=\"comment\">// 6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsStr: <span class=\"type\">NSString</span> <span class=\"operator\">=</span> str <span class=\"keyword\">as</span> <span class=\"type\">NSString</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(nsStr.length) <span class=\"comment\">// 8 (UTF-16 units)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Accurate character count, avoids UI bugs.</li>\n<li>Supports i18n and emoji, better product reach.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>String.count &#x3D; character count, NSString.length &#x3D; UTF-16 units.</li>\n<li>Some emoji&#x2F;special chars count as 2 in NSString.length.</li>\n</ul>\n"},{"title":"SwiftUI 核心机制与业务价值","date":"2025-07-16T16:00:00.000Z","path":"iOS/SwiftUI核心机制与业务价值.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与机制\nSwiftUI 是苹果推出的声明式 UI 框架，核心是 View 协议、状态驱动、数据绑定（@State/@Binding/@ObservedObject）。\n\n## 1.2 代码示例\n```swift\nstruct ContentView: View {\n    @State private var count = 0\n    var body: some View {\n        Button(\"点击\\(count)\") { count += 1 }\n    }\n}\n```\n\n## 1.3 业务场景\n- 跨平台 UI、动态主题、响应式交互。\n\n## 1.4 易混淆点\n- SwiftUI 不是 UIKit 封装，完全声明式。\n- 状态驱动，UI 自动刷新。\n\n## 1.5 深挖追问\n- SwiftUI 性能优化？View 结构扁平化、@StateObject。\n- 业务价值？极大提升开发效率、可维护性。\n\n# 2. English Answer\n\n## 2.1 Concept & Mechanism\nSwiftUI is Apple's declarative UI framework: View protocol, state-driven, data binding (@State/@Binding/@ObservedObject).\n\n## 2.2 Code Example\n```swift\nstruct ContentView: View {\n    @State private var count = 0\n    var body: some View {\n        Button(\"Click \\(count)\") { count += 1 }\n    }\n}\n```\n\n## 2.3 Business Scenarios\n- Cross-platform UI, dynamic theme, reactive interaction.\n\n## 2.4 Common Confusions\n- SwiftUI is not UIKit wrapper, fully declarative.\n- State-driven, UI auto-refresh.\n\n## 2.5 Deep Dive\n- SwiftUI perf optimization? Flat view, @StateObject.\n- Business value? Boosts dev efficiency, maintainability.\n","source":"iOS/SwiftUI核心机制与业务价值.md","raw":"---\ntitle: SwiftUI 核心机制与业务价值\ndate: 2025-07-17\npath: source/iOS/SwiftUI核心机制与业务价值.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与机制\nSwiftUI 是苹果推出的声明式 UI 框架，核心是 View 协议、状态驱动、数据绑定（@State/@Binding/@ObservedObject）。\n\n## 1.2 代码示例\n```swift\nstruct ContentView: View {\n    @State private var count = 0\n    var body: some View {\n        Button(\"点击\\(count)\") { count += 1 }\n    }\n}\n```\n\n## 1.3 业务场景\n- 跨平台 UI、动态主题、响应式交互。\n\n## 1.4 易混淆点\n- SwiftUI 不是 UIKit 封装，完全声明式。\n- 状态驱动，UI 自动刷新。\n\n## 1.5 深挖追问\n- SwiftUI 性能优化？View 结构扁平化、@StateObject。\n- 业务价值？极大提升开发效率、可维护性。\n\n# 2. English Answer\n\n## 2.1 Concept & Mechanism\nSwiftUI is Apple's declarative UI framework: View protocol, state-driven, data binding (@State/@Binding/@ObservedObject).\n\n## 2.2 Code Example\n```swift\nstruct ContentView: View {\n    @State private var count = 0\n    var body: some View {\n        Button(\"Click \\(count)\") { count += 1 }\n    }\n}\n```\n\n## 2.3 Business Scenarios\n- Cross-platform UI, dynamic theme, reactive interaction.\n\n## 2.4 Common Confusions\n- SwiftUI is not UIKit wrapper, fully declarative.\n- State-driven, UI auto-refresh.\n\n## 2.5 Deep Dive\n- SwiftUI perf optimization? Flat view, @StateObject.\n- Business value? Boosts dev efficiency, maintainability.\n","updated":"2025-07-17T10:11:29.164Z","comments":1,"layout":"page","_id":"cmd78fh5m000k5ek7fmybh3zm","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与机制\"><a href=\"#1-1-概念与机制\" class=\"headerlink\" title=\"1.1 概念与机制\"></a>1.1 概念与机制</h2><p>SwiftUI 是苹果推出的声明式 UI 框架，核心是 View 协议、状态驱动、数据绑定（@State&#x2F;@Binding&#x2F;@ObservedObject）。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> count <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Button</span>(<span class=\"string\">&quot;点击<span class=\"subst\">\\(count)</span>&quot;</span>) &#123; count <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>跨平台 UI、动态主题、响应式交互。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>SwiftUI 不是 UIKit 封装，完全声明式。</li>\n<li>状态驱动，UI 自动刷新。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>SwiftUI 性能优化？View 结构扁平化、@StateObject。</li>\n<li>业务价值？极大提升开发效率、可维护性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Mechanism\"><a href=\"#2-1-Concept-Mechanism\" class=\"headerlink\" title=\"2.1 Concept &amp; Mechanism\"></a>2.1 Concept &amp; Mechanism</h2><p>SwiftUI is Apple’s declarative UI framework: View protocol, state-driven, data binding (@State&#x2F;@Binding&#x2F;@ObservedObject).</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> count <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Button</span>(<span class=\"string\">&quot;Click <span class=\"subst\">\\(count)</span>&quot;</span>) &#123; count <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Cross-platform UI, dynamic theme, reactive interaction.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>SwiftUI is not UIKit wrapper, fully declarative.</li>\n<li>State-driven, UI auto-refresh.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>SwiftUI perf optimization? Flat view, @StateObject.</li>\n<li>Business value? Boosts dev efficiency, maintainability.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与机制\"><a href=\"#1-1-概念与机制\" class=\"headerlink\" title=\"1.1 概念与机制\"></a>1.1 概念与机制</h2><p>SwiftUI 是苹果推出的声明式 UI 框架，核心是 View 协议、状态驱动、数据绑定（@State&#x2F;@Binding&#x2F;@ObservedObject）。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> count <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Button</span>(<span class=\"string\">&quot;点击<span class=\"subst\">\\(count)</span>&quot;</span>) &#123; count <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>跨平台 UI、动态主题、响应式交互。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>SwiftUI 不是 UIKit 封装，完全声明式。</li>\n<li>状态驱动，UI 自动刷新。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>SwiftUI 性能优化？View 结构扁平化、@StateObject。</li>\n<li>业务价值？极大提升开发效率、可维护性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Mechanism\"><a href=\"#2-1-Concept-Mechanism\" class=\"headerlink\" title=\"2.1 Concept &amp; Mechanism\"></a>2.1 Concept &amp; Mechanism</h2><p>SwiftUI is Apple’s declarative UI framework: View protocol, state-driven, data binding (@State&#x2F;@Binding&#x2F;@ObservedObject).</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> count <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Button</span>(<span class=\"string\">&quot;Click <span class=\"subst\">\\(count)</span>&quot;</span>) &#123; count <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Cross-platform UI, dynamic theme, reactive interaction.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>SwiftUI is not UIKit wrapper, fully declarative.</li>\n<li>State-driven, UI auto-refresh.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>SwiftUI perf optimization? Flat view, @StateObject.</li>\n<li>Business value? Boosts dev efficiency, maintainability.</li>\n</ul>\n"},{"title":"Swift与OC对比","date":"2025-07-16T16:00:00.000Z","path":"iOS/Swift_OC对比.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 语法与特性\n- Swift：强类型、类型推断、Optionals、值类型、函数式编程。\n- OC：动态类型、消息机制、指针、手动内存管理。\n\n## 1.2 代码示例\n```swift\nlet arr = [1,2,3] // Swift\nNSArray *arr = @[@1,@2,@3]; // OC\n```\n\n## 1.3 业务场景\n- Swift 适合新项目、类型安全要求高。\n- OC 适合维护老项目、动态特性需求。\n\n## 1.4 易混淆点\n- Swift 更安全但更严格，OC 灵活但易出错。\n- Swift 与 OC 可混编。\n\n## 1.5 深挖追问\n- Swift 性能优化点？ARC、COW、泛型。\n- OC 动态特性优势？运行时注入、KVC/KVO。\n\n# 2. English Answer\n\n## 2.1 Syntax & Features\n- Swift: strong type, inference, optionals, value type, functional.\n- OC: dynamic type, messaging, pointer, manual memory.\n\n## 2.2 Code Example\n```swift\nlet arr = [1,2,3] // Swift\nNSArray *arr = @[@1,@2,@3]; // OC\n```\n\n## 2.3 Business Scenarios\n- Swift: new project, type safety.\n- OC: legacy, dynamic needs.\n\n## 2.4 Common Confusions\n- Swift safer but stricter, OC flexible but risky.\n- Swift/OC can mix.\n\n## 2.5 Deep Dive\n- Swift perf: ARC, COW, generics.\n- OC dynamic: runtime, KVC/KVO.\n","source":"iOS/Swift_OC对比.md","raw":"---\ntitle: Swift与OC对比\ndate: 2025-07-17\npath: source/iOS/Swift_OC对比.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 语法与特性\n- Swift：强类型、类型推断、Optionals、值类型、函数式编程。\n- OC：动态类型、消息机制、指针、手动内存管理。\n\n## 1.2 代码示例\n```swift\nlet arr = [1,2,3] // Swift\nNSArray *arr = @[@1,@2,@3]; // OC\n```\n\n## 1.3 业务场景\n- Swift 适合新项目、类型安全要求高。\n- OC 适合维护老项目、动态特性需求。\n\n## 1.4 易混淆点\n- Swift 更安全但更严格，OC 灵活但易出错。\n- Swift 与 OC 可混编。\n\n## 1.5 深挖追问\n- Swift 性能优化点？ARC、COW、泛型。\n- OC 动态特性优势？运行时注入、KVC/KVO。\n\n# 2. English Answer\n\n## 2.1 Syntax & Features\n- Swift: strong type, inference, optionals, value type, functional.\n- OC: dynamic type, messaging, pointer, manual memory.\n\n## 2.2 Code Example\n```swift\nlet arr = [1,2,3] // Swift\nNSArray *arr = @[@1,@2,@3]; // OC\n```\n\n## 2.3 Business Scenarios\n- Swift: new project, type safety.\n- OC: legacy, dynamic needs.\n\n## 2.4 Common Confusions\n- Swift safer but stricter, OC flexible but risky.\n- Swift/OC can mix.\n\n## 2.5 Deep Dive\n- Swift perf: ARC, COW, generics.\n- OC dynamic: runtime, KVC/KVO.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5m000m5ek718lx452z","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-语法与特性\"><a href=\"#1-1-语法与特性\" class=\"headerlink\" title=\"1.1 语法与特性\"></a>1.1 语法与特性</h2><ul>\n<li>Swift：强类型、类型推断、Optionals、值类型、函数式编程。</li>\n<li>OC：动态类型、消息机制、指针、手动内存管理。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// Swift</span></span><br><span class=\"line\"><span class=\"type\">NSArray</span> <span class=\"operator\">*</span>arr <span class=\"operator\">=</span> @[@<span class=\"number\">1</span>,@<span class=\"number\">2</span>,@<span class=\"number\">3</span>]; <span class=\"comment\">// OC</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>Swift 适合新项目、类型安全要求高。</li>\n<li>OC 适合维护老项目、动态特性需求。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>Swift 更安全但更严格，OC 灵活但易出错。</li>\n<li>Swift 与 OC 可混编。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>Swift 性能优化点？ARC、COW、泛型。</li>\n<li>OC 动态特性优势？运行时注入、KVC&#x2F;KVO。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Syntax-Features\"><a href=\"#2-1-Syntax-Features\" class=\"headerlink\" title=\"2.1 Syntax &amp; Features\"></a>2.1 Syntax &amp; Features</h2><ul>\n<li>Swift: strong type, inference, optionals, value type, functional.</li>\n<li>OC: dynamic type, messaging, pointer, manual memory.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// Swift</span></span><br><span class=\"line\"><span class=\"type\">NSArray</span> <span class=\"operator\">*</span>arr <span class=\"operator\">=</span> @[@<span class=\"number\">1</span>,@<span class=\"number\">2</span>,@<span class=\"number\">3</span>]; <span class=\"comment\">// OC</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Swift: new project, type safety.</li>\n<li>OC: legacy, dynamic needs.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Swift safer but stricter, OC flexible but risky.</li>\n<li>Swift&#x2F;OC can mix.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Swift perf: ARC, COW, generics.</li>\n<li>OC dynamic: runtime, KVC&#x2F;KVO.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-语法与特性\"><a href=\"#1-1-语法与特性\" class=\"headerlink\" title=\"1.1 语法与特性\"></a>1.1 语法与特性</h2><ul>\n<li>Swift：强类型、类型推断、Optionals、值类型、函数式编程。</li>\n<li>OC：动态类型、消息机制、指针、手动内存管理。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// Swift</span></span><br><span class=\"line\"><span class=\"type\">NSArray</span> <span class=\"operator\">*</span>arr <span class=\"operator\">=</span> @[@<span class=\"number\">1</span>,@<span class=\"number\">2</span>,@<span class=\"number\">3</span>]; <span class=\"comment\">// OC</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>Swift 适合新项目、类型安全要求高。</li>\n<li>OC 适合维护老项目、动态特性需求。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>Swift 更安全但更严格，OC 灵活但易出错。</li>\n<li>Swift 与 OC 可混编。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>Swift 性能优化点？ARC、COW、泛型。</li>\n<li>OC 动态特性优势？运行时注入、KVC&#x2F;KVO。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Syntax-Features\"><a href=\"#2-1-Syntax-Features\" class=\"headerlink\" title=\"2.1 Syntax &amp; Features\"></a>2.1 Syntax &amp; Features</h2><ul>\n<li>Swift: strong type, inference, optionals, value type, functional.</li>\n<li>OC: dynamic type, messaging, pointer, manual memory.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">// Swift</span></span><br><span class=\"line\"><span class=\"type\">NSArray</span> <span class=\"operator\">*</span>arr <span class=\"operator\">=</span> @[@<span class=\"number\">1</span>,@<span class=\"number\">2</span>,@<span class=\"number\">3</span>]; <span class=\"comment\">// OC</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Swift: new project, type safety.</li>\n<li>OC: legacy, dynamic needs.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Swift safer but stricter, OC flexible but risky.</li>\n<li>Swift&#x2F;OC can mix.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Swift perf: ARC, COW, generics.</li>\n<li>OC dynamic: runtime, KVC&#x2F;KVO.</li>\n</ul>\n"},{"title":"Swift中的初始化器（构造方法）","date":"2025-07-16T16:00:00.000Z","path":"iOS/Swift初始化器.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 Swift 初始化器的类型\n1. **指定初始化器（Designated Initializer）**：负责初始化所有属性，调用父类的指定初始化器。\n2. **便利初始化器（Convenience Initializer）**：必须调用同一个类中的其他初始化器，常用于简化初始化流程。\n3. **可失败初始化器（Failable Initializer）**：`init?`，初始化可能失败时返回 nil。\n\n## 1.2 为什么要这样设计？\n- 保证对象所有属性都被初始化，提升类型安全。\n- 便于多构造方式，提升 API 易用性。\n- 可失败初始化器提升健壮性。\n\n## 1.3 实际代码示例\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    // 指定初始化器\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    // 便利初始化器\n    convenience init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    // 可失败初始化器\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 1.4 业务/用户价值\n- 保证数据完整性，提升产品稳定性。\n- 支持多种初始化方式，提升开发效率。\n\n## 1.5 易混淆点\n- 便利初始化器必须调用本类其他初始化器。\n- 可失败初始化器返回 nil，需注意解包。\n\n# 2. English Answer\n\n## 2.1 Types of Swift Initializers\n1. **Designated Initializer**: Initializes all properties, calls superclass's designated initializer.\n2. **Convenience Initializer**: Must call another initializer in the same class, simplifies initialization.\n3. **Failable Initializer**: `init?`, returns nil if initialization fails.\n\n## 2.2 Why this design?\n- Ensures all properties are initialized, improves type safety.\n- Supports multiple construction patterns, better API usability.\n- Failable initializers improve robustness.\n\n## 2.3 Code Example\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    convenience init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 2.4 Business/User Value\n- Ensures data integrity, improves stability.\n- Supports multiple init patterns, better dev efficiency.\n\n## 2.5 Common Confusion\n- Convenience initializers must call another initializer in the same class.\n- Failable initializers return nil, need to unwrap.\n","source":"iOS/Swift初始化器.md","raw":"---\ntitle: Swift中的初始化器（构造方法）\ndate: 2025-07-17\npath: source/iOS/Swift初始化器.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 Swift 初始化器的类型\n1. **指定初始化器（Designated Initializer）**：负责初始化所有属性，调用父类的指定初始化器。\n2. **便利初始化器（Convenience Initializer）**：必须调用同一个类中的其他初始化器，常用于简化初始化流程。\n3. **可失败初始化器（Failable Initializer）**：`init?`，初始化可能失败时返回 nil。\n\n## 1.2 为什么要这样设计？\n- 保证对象所有属性都被初始化，提升类型安全。\n- 便于多构造方式，提升 API 易用性。\n- 可失败初始化器提升健壮性。\n\n## 1.3 实际代码示例\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    // 指定初始化器\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    // 便利初始化器\n    convenience init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    // 可失败初始化器\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 1.4 业务/用户价值\n- 保证数据完整性，提升产品稳定性。\n- 支持多种初始化方式，提升开发效率。\n\n## 1.5 易混淆点\n- 便利初始化器必须调用本类其他初始化器。\n- 可失败初始化器返回 nil，需注意解包。\n\n# 2. English Answer\n\n## 2.1 Types of Swift Initializers\n1. **Designated Initializer**: Initializes all properties, calls superclass's designated initializer.\n2. **Convenience Initializer**: Must call another initializer in the same class, simplifies initialization.\n3. **Failable Initializer**: `init?`, returns nil if initialization fails.\n\n## 2.2 Why this design?\n- Ensures all properties are initialized, improves type safety.\n- Supports multiple construction patterns, better API usability.\n- Failable initializers improve robustness.\n\n## 2.3 Code Example\n```swift\nclass Person {\n    var name: String\n    var age: Int\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n    convenience init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 2.4 Business/User Value\n- Ensures data integrity, improves stability.\n- Supports multiple init patterns, better dev efficiency.\n\n## 2.5 Common Confusion\n- Convenience initializers must call another initializer in the same class.\n- Failable initializers return nil, need to unwrap.\n","updated":"2025-07-17T10:11:29.154Z","comments":1,"layout":"page","_id":"cmd78fh5m000o5ek7cf893m1r","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-Swift-初始化器的类型\"><a href=\"#1-1-Swift-初始化器的类型\" class=\"headerlink\" title=\"1.1 Swift 初始化器的类型\"></a>1.1 Swift 初始化器的类型</h2><ol>\n<li><strong>指定初始化器（Designated Initializer）</strong>：负责初始化所有属性，调用父类的指定初始化器。</li>\n<li><strong>便利初始化器（Convenience Initializer）</strong>：必须调用同一个类中的其他初始化器，常用于简化初始化流程。</li>\n<li><strong>可失败初始化器（Failable Initializer）</strong>：<code>init?</code>，初始化可能失败时返回 nil。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证对象所有属性都被初始化，提升类型安全。</li>\n<li>便于多构造方式，提升 API 易用性。</li>\n<li>可失败初始化器提升健壮性。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"comment\">// 指定初始化器</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 便利初始化器</span></span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可失败初始化器</span></span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>保证数据完整性，提升产品稳定性。</li>\n<li>支持多种初始化方式，提升开发效率。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>便利初始化器必须调用本类其他初始化器。</li>\n<li>可失败初始化器返回 nil，需注意解包。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Types-of-Swift-Initializers\"><a href=\"#2-1-Types-of-Swift-Initializers\" class=\"headerlink\" title=\"2.1 Types of Swift Initializers\"></a>2.1 Types of Swift Initializers</h2><ol>\n<li><strong>Designated Initializer</strong>: Initializes all properties, calls superclass’s designated initializer.</li>\n<li><strong>Convenience Initializer</strong>: Must call another initializer in the same class, simplifies initialization.</li>\n<li><strong>Failable Initializer</strong>: <code>init?</code>, returns nil if initialization fails.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures all properties are initialized, improves type safety.</li>\n<li>Supports multiple construction patterns, better API usability.</li>\n<li>Failable initializers improve robustness.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Ensures data integrity, improves stability.</li>\n<li>Supports multiple init patterns, better dev efficiency.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Convenience initializers must call another initializer in the same class.</li>\n<li>Failable initializers return nil, need to unwrap.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-Swift-初始化器的类型\"><a href=\"#1-1-Swift-初始化器的类型\" class=\"headerlink\" title=\"1.1 Swift 初始化器的类型\"></a>1.1 Swift 初始化器的类型</h2><ol>\n<li><strong>指定初始化器（Designated Initializer）</strong>：负责初始化所有属性，调用父类的指定初始化器。</li>\n<li><strong>便利初始化器（Convenience Initializer）</strong>：必须调用同一个类中的其他初始化器，常用于简化初始化流程。</li>\n<li><strong>可失败初始化器（Failable Initializer）</strong>：<code>init?</code>，初始化可能失败时返回 nil。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证对象所有属性都被初始化，提升类型安全。</li>\n<li>便于多构造方式，提升 API 易用性。</li>\n<li>可失败初始化器提升健壮性。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"comment\">// 指定初始化器</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 便利初始化器</span></span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可失败初始化器</span></span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>保证数据完整性，提升产品稳定性。</li>\n<li>支持多种初始化方式，提升开发效率。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>便利初始化器必须调用本类其他初始化器。</li>\n<li>可失败初始化器返回 nil，需注意解包。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Types-of-Swift-Initializers\"><a href=\"#2-1-Types-of-Swift-Initializers\" class=\"headerlink\" title=\"2.1 Types of Swift Initializers\"></a>2.1 Types of Swift Initializers</h2><ol>\n<li><strong>Designated Initializer</strong>: Initializes all properties, calls superclass’s designated initializer.</li>\n<li><strong>Convenience Initializer</strong>: Must call another initializer in the same class, simplifies initialization.</li>\n<li><strong>Failable Initializer</strong>: <code>init?</code>, returns nil if initialization fails.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures all properties are initialized, improves type safety.</li>\n<li>Supports multiple construction patterns, better API usability.</li>\n<li>Failable initializers improve robustness.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Ensures data integrity, improves stability.</li>\n<li>Supports multiple init patterns, better dev efficiency.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Convenience initializers must call another initializer in the same class.</li>\n<li>Failable initializers return nil, need to unwrap.</li>\n</ul>\n"},{"title":"dynamic与静态库的区别","date":"2025-07-16T16:00:00.000Z","path":"iOS/dynamic与静态库区别.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与本质\n- **静态库（Static Library）**：编译时直接打包进可执行文件，扩展名.a。\n- **动态库（Dynamic Library）**：运行时动态加载，扩展名.dylib/.framework。\n\n## 1.2 主要区别\n- 链接时机：静态库在编译时，动态库在运行时。\n- 体积：静态库会增加主程序体积，动态库可复用、节省空间。\n- 更新：动态库可独立升级，静态库需重新编译主程序。\n- 资源占用：动态库可被多个进程共享，静态库各自占用。\n\n## 1.3 代码/配置示例\n- Xcode 添加静态库：Target → Build Phases → Link Binary With Libraries\n- 动态库：需设置“Embedded Binaries”\n\n## 1.4 业务场景\n- SDK/第三方库分发、热修复、插件化等。\n\n## 1.5 易混淆点\n- iOS 8 以前不支持动态 framework。\n- 动态库需注意 App Store 审核政策。\n\n# 2. English Answer\n\n## 2.1 Concept & Essence\n- **Static Library**: Linked at compile time, extension .a\n- **Dynamic Library**: Loaded at runtime, extension .dylib/.framework\n\n## 2.2 Key Differences\n- Link time: static (compile), dynamic (runtime)\n- Size: static increases app size, dynamic saves space\n- Update: dynamic can be updated independently\n- Resource: dynamic can be shared, static is duplicated\n\n## 2.3 Code/Config Example\n- Xcode add static: Target → Build Phases → Link Binary With Libraries\n- Dynamic: set “Embedded Binaries”\n\n## 2.4 Business Scenarios\n- SDK/3rd-party distribution, hotfix, plugin, etc.\n\n## 2.5 Common Confusions\n- iOS <8 no dynamic framework\n- Dynamic library and App Store policy\n","source":"iOS/dynamic与静态库区别.md","raw":"---\ntitle: dynamic与静态库的区别\ndate: 2025-07-17\npath: source/iOS/dynamic与静态库区别.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与本质\n- **静态库（Static Library）**：编译时直接打包进可执行文件，扩展名.a。\n- **动态库（Dynamic Library）**：运行时动态加载，扩展名.dylib/.framework。\n\n## 1.2 主要区别\n- 链接时机：静态库在编译时，动态库在运行时。\n- 体积：静态库会增加主程序体积，动态库可复用、节省空间。\n- 更新：动态库可独立升级，静态库需重新编译主程序。\n- 资源占用：动态库可被多个进程共享，静态库各自占用。\n\n## 1.3 代码/配置示例\n- Xcode 添加静态库：Target → Build Phases → Link Binary With Libraries\n- 动态库：需设置“Embedded Binaries”\n\n## 1.4 业务场景\n- SDK/第三方库分发、热修复、插件化等。\n\n## 1.5 易混淆点\n- iOS 8 以前不支持动态 framework。\n- 动态库需注意 App Store 审核政策。\n\n# 2. English Answer\n\n## 2.1 Concept & Essence\n- **Static Library**: Linked at compile time, extension .a\n- **Dynamic Library**: Loaded at runtime, extension .dylib/.framework\n\n## 2.2 Key Differences\n- Link time: static (compile), dynamic (runtime)\n- Size: static increases app size, dynamic saves space\n- Update: dynamic can be updated independently\n- Resource: dynamic can be shared, static is duplicated\n\n## 2.3 Code/Config Example\n- Xcode add static: Target → Build Phases → Link Binary With Libraries\n- Dynamic: set “Embedded Binaries”\n\n## 2.4 Business Scenarios\n- SDK/3rd-party distribution, hotfix, plugin, etc.\n\n## 2.5 Common Confusions\n- iOS <8 no dynamic framework\n- Dynamic library and App Store policy\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5n000p5ek70qzghknx","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与本质\"><a href=\"#1-1-概念与本质\" class=\"headerlink\" title=\"1.1 概念与本质\"></a>1.1 概念与本质</h2><ul>\n<li><strong>静态库（Static Library）</strong>：编译时直接打包进可执行文件，扩展名.a。</li>\n<li><strong>动态库（Dynamic Library）</strong>：运行时动态加载，扩展名.dylib&#x2F;.framework。</li>\n</ul>\n<h2 id=\"1-2-主要区别\"><a href=\"#1-2-主要区别\" class=\"headerlink\" title=\"1.2 主要区别\"></a>1.2 主要区别</h2><ul>\n<li>链接时机：静态库在编译时，动态库在运行时。</li>\n<li>体积：静态库会增加主程序体积，动态库可复用、节省空间。</li>\n<li>更新：动态库可独立升级，静态库需重新编译主程序。</li>\n<li>资源占用：动态库可被多个进程共享，静态库各自占用。</li>\n</ul>\n<h2 id=\"1-3-代码-配置示例\"><a href=\"#1-3-代码-配置示例\" class=\"headerlink\" title=\"1.3 代码&#x2F;配置示例\"></a>1.3 代码&#x2F;配置示例</h2><ul>\n<li>Xcode 添加静态库：Target → Build Phases → Link Binary With Libraries</li>\n<li>动态库：需设置“Embedded Binaries”</li>\n</ul>\n<h2 id=\"1-4-业务场景\"><a href=\"#1-4-业务场景\" class=\"headerlink\" title=\"1.4 业务场景\"></a>1.4 业务场景</h2><ul>\n<li>SDK&#x2F;第三方库分发、热修复、插件化等。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>iOS 8 以前不支持动态 framework。</li>\n<li>动态库需注意 App Store 审核政策。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Essence\"><a href=\"#2-1-Concept-Essence\" class=\"headerlink\" title=\"2.1 Concept &amp; Essence\"></a>2.1 Concept &amp; Essence</h2><ul>\n<li><strong>Static Library</strong>: Linked at compile time, extension .a</li>\n<li><strong>Dynamic Library</strong>: Loaded at runtime, extension .dylib&#x2F;.framework</li>\n</ul>\n<h2 id=\"2-2-Key-Differences\"><a href=\"#2-2-Key-Differences\" class=\"headerlink\" title=\"2.2 Key Differences\"></a>2.2 Key Differences</h2><ul>\n<li>Link time: static (compile), dynamic (runtime)</li>\n<li>Size: static increases app size, dynamic saves space</li>\n<li>Update: dynamic can be updated independently</li>\n<li>Resource: dynamic can be shared, static is duplicated</li>\n</ul>\n<h2 id=\"2-3-Code-Config-Example\"><a href=\"#2-3-Code-Config-Example\" class=\"headerlink\" title=\"2.3 Code&#x2F;Config Example\"></a>2.3 Code&#x2F;Config Example</h2><ul>\n<li>Xcode add static: Target → Build Phases → Link Binary With Libraries</li>\n<li>Dynamic: set “Embedded Binaries”</li>\n</ul>\n<h2 id=\"2-4-Business-Scenarios\"><a href=\"#2-4-Business-Scenarios\" class=\"headerlink\" title=\"2.4 Business Scenarios\"></a>2.4 Business Scenarios</h2><ul>\n<li>SDK&#x2F;3rd-party distribution, hotfix, plugin, etc.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusions\"><a href=\"#2-5-Common-Confusions\" class=\"headerlink\" title=\"2.5 Common Confusions\"></a>2.5 Common Confusions</h2><ul>\n<li>iOS &lt;8 no dynamic framework</li>\n<li>Dynamic library and App Store policy</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与本质\"><a href=\"#1-1-概念与本质\" class=\"headerlink\" title=\"1.1 概念与本质\"></a>1.1 概念与本质</h2><ul>\n<li><strong>静态库（Static Library）</strong>：编译时直接打包进可执行文件，扩展名.a。</li>\n<li><strong>动态库（Dynamic Library）</strong>：运行时动态加载，扩展名.dylib&#x2F;.framework。</li>\n</ul>\n<h2 id=\"1-2-主要区别\"><a href=\"#1-2-主要区别\" class=\"headerlink\" title=\"1.2 主要区别\"></a>1.2 主要区别</h2><ul>\n<li>链接时机：静态库在编译时，动态库在运行时。</li>\n<li>体积：静态库会增加主程序体积，动态库可复用、节省空间。</li>\n<li>更新：动态库可独立升级，静态库需重新编译主程序。</li>\n<li>资源占用：动态库可被多个进程共享，静态库各自占用。</li>\n</ul>\n<h2 id=\"1-3-代码-配置示例\"><a href=\"#1-3-代码-配置示例\" class=\"headerlink\" title=\"1.3 代码&#x2F;配置示例\"></a>1.3 代码&#x2F;配置示例</h2><ul>\n<li>Xcode 添加静态库：Target → Build Phases → Link Binary With Libraries</li>\n<li>动态库：需设置“Embedded Binaries”</li>\n</ul>\n<h2 id=\"1-4-业务场景\"><a href=\"#1-4-业务场景\" class=\"headerlink\" title=\"1.4 业务场景\"></a>1.4 业务场景</h2><ul>\n<li>SDK&#x2F;第三方库分发、热修复、插件化等。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>iOS 8 以前不支持动态 framework。</li>\n<li>动态库需注意 App Store 审核政策。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Essence\"><a href=\"#2-1-Concept-Essence\" class=\"headerlink\" title=\"2.1 Concept &amp; Essence\"></a>2.1 Concept &amp; Essence</h2><ul>\n<li><strong>Static Library</strong>: Linked at compile time, extension .a</li>\n<li><strong>Dynamic Library</strong>: Loaded at runtime, extension .dylib&#x2F;.framework</li>\n</ul>\n<h2 id=\"2-2-Key-Differences\"><a href=\"#2-2-Key-Differences\" class=\"headerlink\" title=\"2.2 Key Differences\"></a>2.2 Key Differences</h2><ul>\n<li>Link time: static (compile), dynamic (runtime)</li>\n<li>Size: static increases app size, dynamic saves space</li>\n<li>Update: dynamic can be updated independently</li>\n<li>Resource: dynamic can be shared, static is duplicated</li>\n</ul>\n<h2 id=\"2-3-Code-Config-Example\"><a href=\"#2-3-Code-Config-Example\" class=\"headerlink\" title=\"2.3 Code&#x2F;Config Example\"></a>2.3 Code&#x2F;Config Example</h2><ul>\n<li>Xcode add static: Target → Build Phases → Link Binary With Libraries</li>\n<li>Dynamic: set “Embedded Binaries”</li>\n</ul>\n<h2 id=\"2-4-Business-Scenarios\"><a href=\"#2-4-Business-Scenarios\" class=\"headerlink\" title=\"2.4 Business Scenarios\"></a>2.4 Business Scenarios</h2><ul>\n<li>SDK&#x2F;3rd-party distribution, hotfix, plugin, etc.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusions\"><a href=\"#2-5-Common-Confusions\" class=\"headerlink\" title=\"2.5 Common Confusions\"></a>2.5 Common Confusions</h2><ul>\n<li>iOS &lt;8 no dynamic framework</li>\n<li>Dynamic library and App Store policy</li>\n</ul>\n"},{"title":"guard 与 defer 用法与区别","date":"2025-07-16T16:00:00.000Z","path":"iOS/guard_defer用法区别.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与用法\n- guard：提前校验条件，不满足则提前退出，提升可读性。\n- defer：延迟执行，函数结束前必执行，常用于资源释放。\n\n## 1.2 代码示例\n```swift\nfunc foo(_ name: String?) {\n    guard let n = name else { return }\n    defer { print(\"end\") }\n    print(n)\n}\n```\n\n## 1.3 业务场景\n- guard：参数校验、早返回。\n- defer：文件/锁/资源释放。\n\n## 1.4 易混淆点\n- guard 只能提前退出，不能继续。\n- defer 多个时，后写先执行（栈）。\n\n## 1.5 深挖追问\n- defer 的实现原理？编译器插入，保证执行。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\n- guard: early check, exit if not met, improves readability.\n- defer: delayed execution, always runs before function ends, for resource release.\n\n## 2.2 Code Example\n```swift\nfunc foo(_ name: String?) {\n    guard let n = name else { return }\n    defer { print(\"end\") }\n    print(n)\n}\n```\n\n## 2.3 Business Scenarios\n- guard: param check, early return.\n- defer: file/lock/resource release.\n\n## 2.4 Common Confusions\n- guard: must exit, can't continue.\n- defer: LIFO if multiple.\n\n## 2.5 Deep Dive\n- defer principle? Compiler inserts, ensures execution.\n","source":"iOS/guard_defer用法区别.md","raw":"---\ntitle: guard 与 defer 用法与区别\ndate: 2025-07-17\npath: source/iOS/guard_defer用法区别.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与用法\n- guard：提前校验条件，不满足则提前退出，提升可读性。\n- defer：延迟执行，函数结束前必执行，常用于资源释放。\n\n## 1.2 代码示例\n```swift\nfunc foo(_ name: String?) {\n    guard let n = name else { return }\n    defer { print(\"end\") }\n    print(n)\n}\n```\n\n## 1.3 业务场景\n- guard：参数校验、早返回。\n- defer：文件/锁/资源释放。\n\n## 1.4 易混淆点\n- guard 只能提前退出，不能继续。\n- defer 多个时，后写先执行（栈）。\n\n## 1.5 深挖追问\n- defer 的实现原理？编译器插入，保证执行。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\n- guard: early check, exit if not met, improves readability.\n- defer: delayed execution, always runs before function ends, for resource release.\n\n## 2.2 Code Example\n```swift\nfunc foo(_ name: String?) {\n    guard let n = name else { return }\n    defer { print(\"end\") }\n    print(n)\n}\n```\n\n## 2.3 Business Scenarios\n- guard: param check, early return.\n- defer: file/lock/resource release.\n\n## 2.4 Common Confusions\n- guard: must exit, can't continue.\n- defer: LIFO if multiple.\n\n## 2.5 Deep Dive\n- defer principle? Compiler inserts, ensures execution.\n","updated":"2025-07-17T10:11:29.164Z","comments":1,"layout":"page","_id":"cmd78fh5n000q5ek7cafb9ury","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><ul>\n<li>guard：提前校验条件，不满足则提前退出，提升可读性。</li>\n<li>defer：延迟执行，函数结束前必执行，常用于资源释放。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end&quot;</span>) &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>guard：参数校验、早返回。</li>\n<li>defer：文件&#x2F;锁&#x2F;资源释放。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>guard 只能提前退出，不能继续。</li>\n<li>defer 多个时，后写先执行（栈）。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>defer 的实现原理？编译器插入，保证执行。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><ul>\n<li>guard: early check, exit if not met, improves readability.</li>\n<li>defer: delayed execution, always runs before function ends, for resource release.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end&quot;</span>) &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>guard: param check, early return.</li>\n<li>defer: file&#x2F;lock&#x2F;resource release.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>guard: must exit, can’t continue.</li>\n<li>defer: LIFO if multiple.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>defer principle? Compiler inserts, ensures execution.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><ul>\n<li>guard：提前校验条件，不满足则提前退出，提升可读性。</li>\n<li>defer：延迟执行，函数结束前必执行，常用于资源释放。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end&quot;</span>) &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>guard：参数校验、早返回。</li>\n<li>defer：文件&#x2F;锁&#x2F;资源释放。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>guard 只能提前退出，不能继续。</li>\n<li>defer 多个时，后写先执行（栈）。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>defer 的实现原理？编译器插入，保证执行。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><ul>\n<li>guard: early check, exit if not met, improves readability.</li>\n<li>defer: delayed execution, always runs before function ends, for resource release.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>?) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end&quot;</span>) &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>guard: param check, early return.</li>\n<li>defer: file&#x2F;lock&#x2F;resource release.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>guard: must exit, can’t continue.</li>\n<li>defer: LIFO if multiple.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>defer principle? Compiler inserts, ensures execution.</li>\n</ul>\n"},{"title":"lazy懒加载","date":"2025-07-16T16:00:00.000Z","path":"iOS/lazy懒加载.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与原理\n`lazy` 关键字用于延迟属性的初始化，只有在第一次访问时才会计算和分配内存，适合开销大或依赖外部条件的属性。\n\n## 1.2 代码示例\n```swift\nclass DataManager {\n    lazy var data: [String] = loadData()\n    func loadData() -> [String] { [\"A\", \"B\", \"C\"] }\n}\n```\n\n## 1.3 业务场景\n- 大型数据、图片、网络请求等按需加载。\n\n## 1.4 易混淆点\n- lazy 属性必须是 var，不能是 let。\n- lazy 属性不能用于常量或计算属性。\n- 多线程下需注意线程安全。\n\n## 1.5 深挖追问\n- lazy 属性何时释放？随对象生命周期。\n- lazy 属性和延迟存储属性的区别？本质一致，强调使用场景。\n\n# 2. English Answer\n\n## 2.1 Concept & Principle\nThe `lazy` keyword delays property initialization until first access, ideal for expensive or externally dependent properties.\n\n## 2.2 Code Example\n```swift\nclass DataManager {\n    lazy var data: [String] = loadData()\n    func loadData() -> [String] { [\"A\", \"B\", \"C\"] }\n}\n```\n\n## 2.3 Business Scenarios\n- Large data, images, network requests, etc. on demand.\n\n## 2.4 Common Confusions\n- lazy must be var, not let.\n- Not for constants or computed properties.\n- Thread safety concerns in multithreading.\n\n## 2.5 Deep Dive\n- When is lazy property released? With object lifecycle.\n- Difference with lazy stored property? Essentially the same, focus on usage scenario.\n","source":"iOS/lazy懒加载.md","raw":"---\ntitle: lazy懒加载\ndate: 2025-07-17\npath: source/iOS/lazy懒加载.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与原理\n`lazy` 关键字用于延迟属性的初始化，只有在第一次访问时才会计算和分配内存，适合开销大或依赖外部条件的属性。\n\n## 1.2 代码示例\n```swift\nclass DataManager {\n    lazy var data: [String] = loadData()\n    func loadData() -> [String] { [\"A\", \"B\", \"C\"] }\n}\n```\n\n## 1.3 业务场景\n- 大型数据、图片、网络请求等按需加载。\n\n## 1.4 易混淆点\n- lazy 属性必须是 var，不能是 let。\n- lazy 属性不能用于常量或计算属性。\n- 多线程下需注意线程安全。\n\n## 1.5 深挖追问\n- lazy 属性何时释放？随对象生命周期。\n- lazy 属性和延迟存储属性的区别？本质一致，强调使用场景。\n\n# 2. English Answer\n\n## 2.1 Concept & Principle\nThe `lazy` keyword delays property initialization until first access, ideal for expensive or externally dependent properties.\n\n## 2.2 Code Example\n```swift\nclass DataManager {\n    lazy var data: [String] = loadData()\n    func loadData() -> [String] { [\"A\", \"B\", \"C\"] }\n}\n```\n\n## 2.3 Business Scenarios\n- Large data, images, network requests, etc. on demand.\n\n## 2.4 Common Confusions\n- lazy must be var, not let.\n- Not for constants or computed properties.\n- Thread safety concerns in multithreading.\n\n## 2.5 Deep Dive\n- When is lazy property released? With object lifecycle.\n- Difference with lazy stored property? Essentially the same, focus on usage scenario.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5n000r5ek7gguohi5o","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p><code>lazy</code> 关键字用于延迟属性的初始化，只有在第一次访问时才会计算和分配内存，适合开销大或依赖外部条件的属性。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123; [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型数据、图片、网络请求等按需加载。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>lazy 属性必须是 var，不能是 let。</li>\n<li>lazy 属性不能用于常量或计算属性。</li>\n<li>多线程下需注意线程安全。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>lazy 属性何时释放？随对象生命周期。</li>\n<li>lazy 属性和延迟存储属性的区别？本质一致，强调使用场景。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Principle\"><a href=\"#2-1-Concept-Principle\" class=\"headerlink\" title=\"2.1 Concept &amp; Principle\"></a>2.1 Concept &amp; Principle</h2><p>The <code>lazy</code> keyword delays property initialization until first access, ideal for expensive or externally dependent properties.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123; [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large data, images, network requests, etc. on demand.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>lazy must be var, not let.</li>\n<li>Not for constants or computed properties.</li>\n<li>Thread safety concerns in multithreading.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>When is lazy property released? With object lifecycle.</li>\n<li>Difference with lazy stored property? Essentially the same, focus on usage scenario.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p><code>lazy</code> 关键字用于延迟属性的初始化，只有在第一次访问时才会计算和分配内存，适合开销大或依赖外部条件的属性。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123; [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型数据、图片、网络请求等按需加载。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>lazy 属性必须是 var，不能是 let。</li>\n<li>lazy 属性不能用于常量或计算属性。</li>\n<li>多线程下需注意线程安全。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>lazy 属性何时释放？随对象生命周期。</li>\n<li>lazy 属性和延迟存储属性的区别？本质一致，强调使用场景。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Principle\"><a href=\"#2-1-Concept-Principle\" class=\"headerlink\" title=\"2.1 Concept &amp; Principle\"></a>2.1 Concept &amp; Principle</h2><p>The <code>lazy</code> keyword delays property initialization until first access, ideal for expensive or externally dependent properties.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123; [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>] &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large data, images, network requests, etc. on demand.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>lazy must be var, not let.</li>\n<li>Not for constants or computed properties.</li>\n<li>Thread safety concerns in multithreading.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>When is lazy property released? With object lifecycle.</li>\n<li>Difference with lazy stored property? Essentially the same, focus on usage scenario.</li>\n</ul>\n"},{"title":"strong、weak、unowned的区别","date":"2025-07-16T16:00:00.000Z","path":"iOS/strong_weak_unowned区别.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 三者定义与区别\n1. **strong**：强引用，默认，持有对象，引用计数+1。\n2. **weak**：弱引用，不持有对象，不增加引用计数，自动置 nil，必须为可选类型。\n3. **unowned**：无主引用，不持有对象，不增加引用计数，不自动置 nil，适合生命周期一致场景。\n\n## 1.2 为什么要这样设计？\n- 防止循环引用（如闭包、delegate）。\n- 保证内存安全和资源释放。\n\n## 1.3 实际代码示例\n```swift\nclass A {\n    var b: B?\n    deinit { print(\"A释放\") }\n}\nclass B {\n    weak var a: A?\n    deinit { print(\"B释放\") }\n}\n\nclass C {\n    unowned var d: D\n    init(d: D) { self.d = d }\n}\nclass D {}\n```\n\n## 1.4 业务/用户价值\n- 避免内存泄漏，提升产品稳定性。\n- 便于资源管理，提升用户体验。\n\n## 1.5 易混淆点\n- weak 自动置 nil，unowned 不会，若对象释放后访问 unowned 会崩溃。\n- strong 是默认引用，weak/unowned 需显式声明。\n\n# 2. English Answer\n\n## 2.1 Definitions and Differences\n1. **strong**: Default, retains object, ref count +1.\n2. **weak**: Does not retain, ref count unchanged, auto nil, must be optional.\n3. **unowned**: Does not retain, ref count unchanged, not auto nil, for same-lifetime cases.\n\n## 2.2 Why this design?\n- Prevent retain cycles (closures, delegates).\n- Ensure memory safety and resource release.\n\n## 2.3 Code Example\n```swift\nclass A {\n    var b: B?\n    deinit { print(\"A released\") }\n}\nclass B {\n    weak var a: A?\n    deinit { print(\"B released\") }\n}\n\nclass C {\n    unowned var d: D\n    init(d: D) { self.d = d }\n}\nclass D {}\n```\n\n## 2.4 Business/User Value\n- Avoid memory leaks, improve stability.\n- Easier resource management, better UX.\n\n## 2.5 Common Confusion\n- weak auto-nils, unowned does not (crash if accessed after release).\n- strong is default, weak/unowned must be explicit.\n","source":"iOS/strong_weak_unowned区别.md","raw":"---\ntitle: strong、weak、unowned的区别\ndate: 2025-07-17\npath: source/iOS/strong_weak_unowned区别.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 三者定义与区别\n1. **strong**：强引用，默认，持有对象，引用计数+1。\n2. **weak**：弱引用，不持有对象，不增加引用计数，自动置 nil，必须为可选类型。\n3. **unowned**：无主引用，不持有对象，不增加引用计数，不自动置 nil，适合生命周期一致场景。\n\n## 1.2 为什么要这样设计？\n- 防止循环引用（如闭包、delegate）。\n- 保证内存安全和资源释放。\n\n## 1.3 实际代码示例\n```swift\nclass A {\n    var b: B?\n    deinit { print(\"A释放\") }\n}\nclass B {\n    weak var a: A?\n    deinit { print(\"B释放\") }\n}\n\nclass C {\n    unowned var d: D\n    init(d: D) { self.d = d }\n}\nclass D {}\n```\n\n## 1.4 业务/用户价值\n- 避免内存泄漏，提升产品稳定性。\n- 便于资源管理，提升用户体验。\n\n## 1.5 易混淆点\n- weak 自动置 nil，unowned 不会，若对象释放后访问 unowned 会崩溃。\n- strong 是默认引用，weak/unowned 需显式声明。\n\n# 2. English Answer\n\n## 2.1 Definitions and Differences\n1. **strong**: Default, retains object, ref count +1.\n2. **weak**: Does not retain, ref count unchanged, auto nil, must be optional.\n3. **unowned**: Does not retain, ref count unchanged, not auto nil, for same-lifetime cases.\n\n## 2.2 Why this design?\n- Prevent retain cycles (closures, delegates).\n- Ensure memory safety and resource release.\n\n## 2.3 Code Example\n```swift\nclass A {\n    var b: B?\n    deinit { print(\"A released\") }\n}\nclass B {\n    weak var a: A?\n    deinit { print(\"B released\") }\n}\n\nclass C {\n    unowned var d: D\n    init(d: D) { self.d = d }\n}\nclass D {}\n```\n\n## 2.4 Business/User Value\n- Avoid memory leaks, improve stability.\n- Easier resource management, better UX.\n\n## 2.5 Common Confusion\n- weak auto-nils, unowned does not (crash if accessed after release).\n- strong is default, weak/unowned must be explicit.\n","updated":"2025-07-17T08:10:17.587Z","comments":1,"layout":"page","_id":"cmd78fh5n000s5ek789i13yjz","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-三者定义与区别\"><a href=\"#1-1-三者定义与区别\" class=\"headerlink\" title=\"1.1 三者定义与区别\"></a>1.1 三者定义与区别</h2><ol>\n<li><strong>strong</strong>：强引用，默认，持有对象，引用计数+1。</li>\n<li><strong>weak</strong>：弱引用，不持有对象，不增加引用计数，自动置 nil，必须为可选类型。</li>\n<li><strong>unowned</strong>：无主引用，不持有对象，不增加引用计数，不自动置 nil，适合生命周期一致场景。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>防止循环引用（如闭包、delegate）。</li>\n<li>保证内存安全和资源释放。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;A释放&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;B释放&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">var</span> d: <span class=\"type\">D</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">d</span>: <span class=\"type\">D</span>) &#123; <span class=\"keyword\">self</span>.d <span class=\"operator\">=</span> d &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>避免内存泄漏，提升产品稳定性。</li>\n<li>便于资源管理，提升用户体验。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>weak 自动置 nil，unowned 不会，若对象释放后访问 unowned 会崩溃。</li>\n<li>strong 是默认引用，weak&#x2F;unowned 需显式声明。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Definitions-and-Differences\"><a href=\"#2-1-Definitions-and-Differences\" class=\"headerlink\" title=\"2.1 Definitions and Differences\"></a>2.1 Definitions and Differences</h2><ol>\n<li><strong>strong</strong>: Default, retains object, ref count +1.</li>\n<li><strong>weak</strong>: Does not retain, ref count unchanged, auto nil, must be optional.</li>\n<li><strong>unowned</strong>: Does not retain, ref count unchanged, not auto nil, for same-lifetime cases.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Prevent retain cycles (closures, delegates).</li>\n<li>Ensure memory safety and resource release.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;A released&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;B released&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">var</span> d: <span class=\"type\">D</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">d</span>: <span class=\"type\">D</span>) &#123; <span class=\"keyword\">self</span>.d <span class=\"operator\">=</span> d &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Avoid memory leaks, improve stability.</li>\n<li>Easier resource management, better UX.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>weak auto-nils, unowned does not (crash if accessed after release).</li>\n<li>strong is default, weak&#x2F;unowned must be explicit.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-三者定义与区别\"><a href=\"#1-1-三者定义与区别\" class=\"headerlink\" title=\"1.1 三者定义与区别\"></a>1.1 三者定义与区别</h2><ol>\n<li><strong>strong</strong>：强引用，默认，持有对象，引用计数+1。</li>\n<li><strong>weak</strong>：弱引用，不持有对象，不增加引用计数，自动置 nil，必须为可选类型。</li>\n<li><strong>unowned</strong>：无主引用，不持有对象，不增加引用计数，不自动置 nil，适合生命周期一致场景。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>防止循环引用（如闭包、delegate）。</li>\n<li>保证内存安全和资源释放。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;A释放&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;B释放&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">var</span> d: <span class=\"type\">D</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">d</span>: <span class=\"type\">D</span>) &#123; <span class=\"keyword\">self</span>.d <span class=\"operator\">=</span> d &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>避免内存泄漏，提升产品稳定性。</li>\n<li>便于资源管理，提升用户体验。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>weak 自动置 nil，unowned 不会，若对象释放后访问 unowned 会崩溃。</li>\n<li>strong 是默认引用，weak&#x2F;unowned 需显式声明。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Definitions-and-Differences\"><a href=\"#2-1-Definitions-and-Differences\" class=\"headerlink\" title=\"2.1 Definitions and Differences\"></a>2.1 Definitions and Differences</h2><ol>\n<li><strong>strong</strong>: Default, retains object, ref count +1.</li>\n<li><strong>weak</strong>: Does not retain, ref count unchanged, auto nil, must be optional.</li>\n<li><strong>unowned</strong>: Does not retain, ref count unchanged, not auto nil, for same-lifetime cases.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Prevent retain cycles (closures, delegates).</li>\n<li>Ensure memory safety and resource release.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;A released&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;B released&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">var</span> d: <span class=\"type\">D</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">d</span>: <span class=\"type\">D</span>) &#123; <span class=\"keyword\">self</span>.d <span class=\"operator\">=</span> d &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Avoid memory leaks, improve stability.</li>\n<li>Easier resource management, better UX.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>weak auto-nils, unowned does not (crash if accessed after release).</li>\n<li>strong is default, weak&#x2F;unowned must be explicit.</li>\n</ul>\n"},{"title":"static 与 class 的区别","date":"2025-07-16T16:00:00.000Z","path":"iOS/static_class区别.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与用法\n- static：用于类/结构体/枚举，表示静态属性/方法，不能被子类重写。\n- class：仅用于类，表示类属性/方法，允许子类重写（需 override）。\n\n## 1.2 代码示例\n```swift\nclass Base {\n    static func foo() {}\n    class func bar() {}\n}\nclass Sub: Base {\n    // override static func foo() {} // ❌ 不允许\n    override class func bar() {} // ✅ 允许\n}\n```\n\n## 1.3 业务场景\n- static：工具方法、常量。\n- class：多态、可扩展 API。\n\n## 1.4 易混淆点\n- struct/enum 只能用 static，不能用 class。\n- static 本质 final class。\n\n## 1.5 深挖追问\n- static/class 的底层实现？static 静态派发，class 支持动态派发。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\n- static: for class/struct/enum, static property/method, not overridable.\n- class: for class only, overridable with override.\n\n## 2.2 Code Example\n```swift\nclass Base {\n    static func foo() {}\n    class func bar() {}\n}\nclass Sub: Base {\n    // override static func foo() {} // ❌ not allowed\n    override class func bar() {} // ✅ allowed\n}\n```\n\n## 2.3 Business Scenarios\n- static: utility, constants.\n- class: polymorphism, extensible API.\n\n## 2.4 Common Confusions\n- struct/enum: only static.\n- static is final class.\n\n## 2.5 Deep Dive\n- static/class implementation? static: static dispatch; class: dynamic dispatch.\n","source":"iOS/static_class区别.md","raw":"---\ntitle: static 与 class 的区别\ndate: 2025-07-17\npath: source/iOS/static_class区别.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与用法\n- static：用于类/结构体/枚举，表示静态属性/方法，不能被子类重写。\n- class：仅用于类，表示类属性/方法，允许子类重写（需 override）。\n\n## 1.2 代码示例\n```swift\nclass Base {\n    static func foo() {}\n    class func bar() {}\n}\nclass Sub: Base {\n    // override static func foo() {} // ❌ 不允许\n    override class func bar() {} // ✅ 允许\n}\n```\n\n## 1.3 业务场景\n- static：工具方法、常量。\n- class：多态、可扩展 API。\n\n## 1.4 易混淆点\n- struct/enum 只能用 static，不能用 class。\n- static 本质 final class。\n\n## 1.5 深挖追问\n- static/class 的底层实现？static 静态派发，class 支持动态派发。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\n- static: for class/struct/enum, static property/method, not overridable.\n- class: for class only, overridable with override.\n\n## 2.2 Code Example\n```swift\nclass Base {\n    static func foo() {}\n    class func bar() {}\n}\nclass Sub: Base {\n    // override static func foo() {} // ❌ not allowed\n    override class func bar() {} // ✅ allowed\n}\n```\n\n## 2.3 Business Scenarios\n- static: utility, constants.\n- class: polymorphism, extensible API.\n\n## 2.4 Common Confusions\n- struct/enum: only static.\n- static is final class.\n\n## 2.5 Deep Dive\n- static/class implementation? static: static dispatch; class: dynamic dispatch.\n","updated":"2025-07-17T10:11:29.164Z","comments":1,"layout":"page","_id":"cmd78fh5n000t5ek729by04om","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><ul>\n<li>static：用于类&#x2F;结构体&#x2F;枚举，表示静态属性&#x2F;方法，不能被子类重写。</li>\n<li>class：仅用于类，表示类属性&#x2F;方法，允许子类重写（需 override）。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override static func foo() &#123;&#125; // ❌ 不允许</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125; <span class=\"comment\">// ✅ 允许</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>static：工具方法、常量。</li>\n<li>class：多态、可扩展 API。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>struct&#x2F;enum 只能用 static，不能用 class。</li>\n<li>static 本质 final class。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>static&#x2F;class 的底层实现？static 静态派发，class 支持动态派发。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><ul>\n<li>static: for class&#x2F;struct&#x2F;enum, static property&#x2F;method, not overridable.</li>\n<li>class: for class only, overridable with override.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override static func foo() &#123;&#125; // ❌ not allowed</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125; <span class=\"comment\">// ✅ allowed</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>static: utility, constants.</li>\n<li>class: polymorphism, extensible API.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>struct&#x2F;enum: only static.</li>\n<li>static is final class.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>static&#x2F;class implementation? static: static dispatch; class: dynamic dispatch.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><ul>\n<li>static：用于类&#x2F;结构体&#x2F;枚举，表示静态属性&#x2F;方法，不能被子类重写。</li>\n<li>class：仅用于类，表示类属性&#x2F;方法，允许子类重写（需 override）。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override static func foo() &#123;&#125; // ❌ 不允许</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125; <span class=\"comment\">// ✅ 允许</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>static：工具方法、常量。</li>\n<li>class：多态、可扩展 API。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>struct&#x2F;enum 只能用 static，不能用 class。</li>\n<li>static 本质 final class。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>static&#x2F;class 的底层实现？static 静态派发，class 支持动态派发。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><ul>\n<li>static: for class&#x2F;struct&#x2F;enum, static property&#x2F;method, not overridable.</li>\n<li>class: for class only, overridable with override.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override static func foo() &#123;&#125; // ❌ not allowed</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">class</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123;&#125; <span class=\"comment\">// ✅ allowed</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>static: utility, constants.</li>\n<li>class: polymorphism, extensible API.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>struct&#x2F;enum: only static.</li>\n<li>static is final class.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>static&#x2F;class implementation? static: static dispatch; class: dynamic dispatch.</li>\n</ul>\n"},{"title":"iOS App 上架审核与合规要点","date":"2025-07-16T16:00:00.000Z","path":"iOS/上架审核与合规要点.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 审核流程\n- 提交 App Store Connect、填写元数据、上传包、等待审核、反馈修正。\n\n## 1.2 合规要点\n- 隐私政策、数据收集、支付合规、内容合规、第三方 SDK 合规。\n\n## 1.3 业务场景\n- 新产品发布、功能大改、合规整改。\n\n## 1.4 易混淆点\n- 审核被拒常见原因：隐私、支付、内容、崩溃。\n- 合规需持续跟进政策。\n\n## 1.5 深挖追问\n- 如何提升通过率？自查、模拟审核、文档齐全。\n- 合规与业务冲突如何平衡？灰度、A/B、沟通。\n\n# 2. English Answer\n\n## 2.1 Review Flow\n- Submit to App Store Connect, metadata, upload, wait, feedback.\n\n## 2.2 Compliance\n- Privacy, data, payment, content, SDK.\n\n## 2.3 Business Scenarios\n- New release, major update, compliance fix.\n\n## 2.4 Common Confusions\n- Rejection: privacy, payment, content, crash.\n- Compliance: follow policy.\n\n## 2.5 Deep Dive\n- Pass rate? Self-check, mock review, doc.\n- Balance? Gray, A/B, comms.\n","source":"iOS/上架审核与合规要点.md","raw":"---\ntitle: iOS App 上架审核与合规要点\ndate: 2025-07-17\npath: source/iOS/上架审核与合规要点.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 审核流程\n- 提交 App Store Connect、填写元数据、上传包、等待审核、反馈修正。\n\n## 1.2 合规要点\n- 隐私政策、数据收集、支付合规、内容合规、第三方 SDK 合规。\n\n## 1.3 业务场景\n- 新产品发布、功能大改、合规整改。\n\n## 1.4 易混淆点\n- 审核被拒常见原因：隐私、支付、内容、崩溃。\n- 合规需持续跟进政策。\n\n## 1.5 深挖追问\n- 如何提升通过率？自查、模拟审核、文档齐全。\n- 合规与业务冲突如何平衡？灰度、A/B、沟通。\n\n# 2. English Answer\n\n## 2.1 Review Flow\n- Submit to App Store Connect, metadata, upload, wait, feedback.\n\n## 2.2 Compliance\n- Privacy, data, payment, content, SDK.\n\n## 2.3 Business Scenarios\n- New release, major update, compliance fix.\n\n## 2.4 Common Confusions\n- Rejection: privacy, payment, content, crash.\n- Compliance: follow policy.\n\n## 2.5 Deep Dive\n- Pass rate? Self-check, mock review, doc.\n- Balance? Gray, A/B, comms.\n","updated":"2025-07-17T10:11:29.228Z","comments":1,"layout":"page","_id":"cmd78fh5n000u5ek79r2qacfo","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-审核流程\"><a href=\"#1-1-审核流程\" class=\"headerlink\" title=\"1.1 审核流程\"></a>1.1 审核流程</h2><ul>\n<li>提交 App Store Connect、填写元数据、上传包、等待审核、反馈修正。</li>\n</ul>\n<h2 id=\"1-2-合规要点\"><a href=\"#1-2-合规要点\" class=\"headerlink\" title=\"1.2 合规要点\"></a>1.2 合规要点</h2><ul>\n<li>隐私政策、数据收集、支付合规、内容合规、第三方 SDK 合规。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>新产品发布、功能大改、合规整改。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>审核被拒常见原因：隐私、支付、内容、崩溃。</li>\n<li>合规需持续跟进政策。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升通过率？自查、模拟审核、文档齐全。</li>\n<li>合规与业务冲突如何平衡？灰度、A&#x2F;B、沟通。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Review-Flow\"><a href=\"#2-1-Review-Flow\" class=\"headerlink\" title=\"2.1 Review Flow\"></a>2.1 Review Flow</h2><ul>\n<li>Submit to App Store Connect, metadata, upload, wait, feedback.</li>\n</ul>\n<h2 id=\"2-2-Compliance\"><a href=\"#2-2-Compliance\" class=\"headerlink\" title=\"2.2 Compliance\"></a>2.2 Compliance</h2><ul>\n<li>Privacy, data, payment, content, SDK.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>New release, major update, compliance fix.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Rejection: privacy, payment, content, crash.</li>\n<li>Compliance: follow policy.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Pass rate? Self-check, mock review, doc.</li>\n<li>Balance? Gray, A&#x2F;B, comms.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-审核流程\"><a href=\"#1-1-审核流程\" class=\"headerlink\" title=\"1.1 审核流程\"></a>1.1 审核流程</h2><ul>\n<li>提交 App Store Connect、填写元数据、上传包、等待审核、反馈修正。</li>\n</ul>\n<h2 id=\"1-2-合规要点\"><a href=\"#1-2-合规要点\" class=\"headerlink\" title=\"1.2 合规要点\"></a>1.2 合规要点</h2><ul>\n<li>隐私政策、数据收集、支付合规、内容合规、第三方 SDK 合规。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>新产品发布、功能大改、合规整改。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>审核被拒常见原因：隐私、支付、内容、崩溃。</li>\n<li>合规需持续跟进政策。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升通过率？自查、模拟审核、文档齐全。</li>\n<li>合规与业务冲突如何平衡？灰度、A&#x2F;B、沟通。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Review-Flow\"><a href=\"#2-1-Review-Flow\" class=\"headerlink\" title=\"2.1 Review Flow\"></a>2.1 Review Flow</h2><ul>\n<li>Submit to App Store Connect, metadata, upload, wait, feedback.</li>\n</ul>\n<h2 id=\"2-2-Compliance\"><a href=\"#2-2-Compliance\" class=\"headerlink\" title=\"2.2 Compliance\"></a>2.2 Compliance</h2><ul>\n<li>Privacy, data, payment, content, SDK.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>New release, major update, compliance fix.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Rejection: privacy, payment, content, crash.</li>\n<li>Compliance: follow policy.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Pass rate? Self-check, mock review, doc.</li>\n<li>Balance? Gray, A&#x2F;B, comms.</li>\n</ul>\n"},{"title":"throws和rethrows的用法","date":"2025-07-16T16:00:00.000Z","path":"iOS/throws和rethrows用法.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 throws 和 rethrows 的区别与用法\n1. **throws**：用于声明函数可能抛出错误，调用时需 try/catch。\n2. **rethrows**：用于高阶函数，只有传入的闭包抛错时才会抛出错误，否则不会。\n\n## 1.2 为什么要这样设计？\n- throws 让错误处理显式、安全。\n- rethrows 避免不必要的 try/catch，提升代码简洁性和性能。\n\n## 1.3 实际代码示例\n```swift\nfunc canThrow() throws {\n    throw NSError(domain: \"Test\", code: 1)\n}\n\nfunc notThrow() {}\n\nfunc call(_ fn: () throws -> Void) rethrows {\n    try fn()\n}\n\n// 用法\ntry? call(canThrow) // 需要 try\ncall(notThrow)      // 不需要 try\n```\n\n## 1.4 业务/用户价值\n- 明确错误边界，提升代码健壮性。\n- 让 API 更易用，减少误用。\n\n## 1.5 易混淆点\n- throws：无论闭包是否抛错，调用都需 try。\n- rethrows：只有闭包可能抛错时才需 try。\n\n# 2. English Answer\n\n## 2.1 Difference and Usage\n1. **throws**: Declares a function may throw errors, must use try/catch.\n2. **rethrows**: For higher-order functions, only throws if closure throws.\n\n## 2.2 Why this design?\n- throws: explicit, safe error handling.\n- rethrows: avoids unnecessary try/catch, cleaner code.\n\n## 2.3 Code Example\n```swift\nfunc canThrow() throws {\n    throw NSError(domain: \"Test\", code: 1)\n}\n\nfunc notThrow() {}\n\nfunc call(_ fn: () throws -> Void) rethrows {\n    try fn()\n}\n\ntry? call(canThrow) // needs try\ncall(notThrow)      // no try needed\n```\n\n## 2.4 Business/User Value\n- Clear error boundaries, robust code.\n- Easier API usage, less misuse.\n\n## 2.5 Common Confusion\n- throws: always needs try, regardless of closure.\n- rethrows: only needs try if closure can throw.\n","source":"iOS/throws和rethrows用法.md","raw":"---\ntitle: throws和rethrows的用法\ndate: 2025-07-17\npath: source/iOS/throws和rethrows用法.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 throws 和 rethrows 的区别与用法\n1. **throws**：用于声明函数可能抛出错误，调用时需 try/catch。\n2. **rethrows**：用于高阶函数，只有传入的闭包抛错时才会抛出错误，否则不会。\n\n## 1.2 为什么要这样设计？\n- throws 让错误处理显式、安全。\n- rethrows 避免不必要的 try/catch，提升代码简洁性和性能。\n\n## 1.3 实际代码示例\n```swift\nfunc canThrow() throws {\n    throw NSError(domain: \"Test\", code: 1)\n}\n\nfunc notThrow() {}\n\nfunc call(_ fn: () throws -> Void) rethrows {\n    try fn()\n}\n\n// 用法\ntry? call(canThrow) // 需要 try\ncall(notThrow)      // 不需要 try\n```\n\n## 1.4 业务/用户价值\n- 明确错误边界，提升代码健壮性。\n- 让 API 更易用，减少误用。\n\n## 1.5 易混淆点\n- throws：无论闭包是否抛错，调用都需 try。\n- rethrows：只有闭包可能抛错时才需 try。\n\n# 2. English Answer\n\n## 2.1 Difference and Usage\n1. **throws**: Declares a function may throw errors, must use try/catch.\n2. **rethrows**: For higher-order functions, only throws if closure throws.\n\n## 2.2 Why this design?\n- throws: explicit, safe error handling.\n- rethrows: avoids unnecessary try/catch, cleaner code.\n\n## 2.3 Code Example\n```swift\nfunc canThrow() throws {\n    throw NSError(domain: \"Test\", code: 1)\n}\n\nfunc notThrow() {}\n\nfunc call(_ fn: () throws -> Void) rethrows {\n    try fn()\n}\n\ntry? call(canThrow) // needs try\ncall(notThrow)      // no try needed\n```\n\n## 2.4 Business/User Value\n- Clear error boundaries, robust code.\n- Easier API usage, less misuse.\n\n## 2.5 Common Confusion\n- throws: always needs try, regardless of closure.\n- rethrows: only needs try if closure can throw.\n","updated":"2025-07-17T08:10:17.587Z","comments":1,"layout":"page","_id":"cmd78fh5n000v5ek792kh7j2t","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-throws-和-rethrows-的区别与用法\"><a href=\"#1-1-throws-和-rethrows-的区别与用法\" class=\"headerlink\" title=\"1.1 throws 和 rethrows 的区别与用法\"></a>1.1 throws 和 rethrows 的区别与用法</h2><ol>\n<li><strong>throws</strong>：用于声明函数可能抛出错误，调用时需 try&#x2F;catch。</li>\n<li><strong>rethrows</strong>：用于高阶函数，只有传入的闭包抛错时才会抛出错误，否则不会。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>throws 让错误处理显式、安全。</li>\n<li>rethrows 避免不必要的 try&#x2F;catch，提升代码简洁性和性能。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">canThrow</span>() <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;Test&quot;</span>, code: <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">notThrow</span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">call</span>(<span class=\"keyword\">_</span> <span class=\"params\">fn</span>: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\"><span class=\"keyword\">try?</span> call(canThrow) <span class=\"comment\">// 需要 try</span></span><br><span class=\"line\">call(notThrow)      <span class=\"comment\">// 不需要 try</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>明确错误边界，提升代码健壮性。</li>\n<li>让 API 更易用，减少误用。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>throws：无论闭包是否抛错，调用都需 try。</li>\n<li>rethrows：只有闭包可能抛错时才需 try。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Difference-and-Usage\"><a href=\"#2-1-Difference-and-Usage\" class=\"headerlink\" title=\"2.1 Difference and Usage\"></a>2.1 Difference and Usage</h2><ol>\n<li><strong>throws</strong>: Declares a function may throw errors, must use try&#x2F;catch.</li>\n<li><strong>rethrows</strong>: For higher-order functions, only throws if closure throws.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>throws: explicit, safe error handling.</li>\n<li>rethrows: avoids unnecessary try&#x2F;catch, cleaner code.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">canThrow</span>() <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;Test&quot;</span>, code: <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">notThrow</span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">call</span>(<span class=\"keyword\">_</span> <span class=\"params\">fn</span>: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try?</span> call(canThrow) <span class=\"comment\">// needs try</span></span><br><span class=\"line\">call(notThrow)      <span class=\"comment\">// no try needed</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Clear error boundaries, robust code.</li>\n<li>Easier API usage, less misuse.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>throws: always needs try, regardless of closure.</li>\n<li>rethrows: only needs try if closure can throw.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-throws-和-rethrows-的区别与用法\"><a href=\"#1-1-throws-和-rethrows-的区别与用法\" class=\"headerlink\" title=\"1.1 throws 和 rethrows 的区别与用法\"></a>1.1 throws 和 rethrows 的区别与用法</h2><ol>\n<li><strong>throws</strong>：用于声明函数可能抛出错误，调用时需 try&#x2F;catch。</li>\n<li><strong>rethrows</strong>：用于高阶函数，只有传入的闭包抛错时才会抛出错误，否则不会。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>throws 让错误处理显式、安全。</li>\n<li>rethrows 避免不必要的 try&#x2F;catch，提升代码简洁性和性能。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">canThrow</span>() <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;Test&quot;</span>, code: <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">notThrow</span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">call</span>(<span class=\"keyword\">_</span> <span class=\"params\">fn</span>: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用法</span></span><br><span class=\"line\"><span class=\"keyword\">try?</span> call(canThrow) <span class=\"comment\">// 需要 try</span></span><br><span class=\"line\">call(notThrow)      <span class=\"comment\">// 不需要 try</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>明确错误边界，提升代码健壮性。</li>\n<li>让 API 更易用，减少误用。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>throws：无论闭包是否抛错，调用都需 try。</li>\n<li>rethrows：只有闭包可能抛错时才需 try。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Difference-and-Usage\"><a href=\"#2-1-Difference-and-Usage\" class=\"headerlink\" title=\"2.1 Difference and Usage\"></a>2.1 Difference and Usage</h2><ol>\n<li><strong>throws</strong>: Declares a function may throw errors, must use try&#x2F;catch.</li>\n<li><strong>rethrows</strong>: For higher-order functions, only throws if closure throws.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>throws: explicit, safe error handling.</li>\n<li>rethrows: avoids unnecessary try&#x2F;catch, cleaner code.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">canThrow</span>() <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;Test&quot;</span>, code: <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">notThrow</span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">call</span>(<span class=\"keyword\">_</span> <span class=\"params\">fn</span>: () <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Void</span>) <span class=\"keyword\">rethrows</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> fn()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try?</span> call(canThrow) <span class=\"comment\">// needs try</span></span><br><span class=\"line\">call(notThrow)      <span class=\"comment\">// no try needed</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Clear error boundaries, robust code.</li>\n<li>Easier API usage, less misuse.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>throws: always needs try, regardless of closure.</li>\n<li>rethrows: only needs try if closure can throw.</li>\n</ul>\n"},{"title":"iOS 业务架构与团队协作","date":"2025-07-16T16:00:00.000Z","path":"iOS/业务架构与团队协作.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 业务架构核心\n- 分层、解耦、服务化、API 设计、数据流。\n- 团队协作：代码规范、评审、CI/CD、文档。\n\n## 1.2 方案/实践示例\n- API 统一、模块 owner、自动化测试。\n\n## 1.3 业务场景\n- 大型项目、多人协作、快速迭代。\n\n## 1.4 易混淆点\n- 架构与协作需同步演进。\n- 技术选型需兼顾团队能力。\n\n## 1.5 深挖追问\n- 如何提升协作效率？自动化、文档、沟通机制。\n- 架构升级如何推动？结合业务目标、技术债务。\n\n# 2. English Answer\n\n## 2.1 Business Architecture\n- Layer, decouple, service, API, data flow.\n- Team: code style, review, CI/CD, doc.\n\n## 2.2 Solution/Practice Example\n- Unified API, module owner, auto test.\n\n## 2.3 Business Scenarios\n- Large project, team, fast iteration.\n\n## 2.4 Common Confusions\n- Arch/collab evolve together.\n- Tech choice by team skill.\n\n## 2.5 Deep Dive\n- Improve collab? Automation, doc, comms.\n- Arch upgrade? Business goal, tech debt.\n","source":"iOS/业务架构与团队协作.md","raw":"---\ntitle: iOS 业务架构与团队协作\ndate: 2025-07-17\npath: source/iOS/业务架构与团队协作.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 业务架构核心\n- 分层、解耦、服务化、API 设计、数据流。\n- 团队协作：代码规范、评审、CI/CD、文档。\n\n## 1.2 方案/实践示例\n- API 统一、模块 owner、自动化测试。\n\n## 1.3 业务场景\n- 大型项目、多人协作、快速迭代。\n\n## 1.4 易混淆点\n- 架构与协作需同步演进。\n- 技术选型需兼顾团队能力。\n\n## 1.5 深挖追问\n- 如何提升协作效率？自动化、文档、沟通机制。\n- 架构升级如何推动？结合业务目标、技术债务。\n\n# 2. English Answer\n\n## 2.1 Business Architecture\n- Layer, decouple, service, API, data flow.\n- Team: code style, review, CI/CD, doc.\n\n## 2.2 Solution/Practice Example\n- Unified API, module owner, auto test.\n\n## 2.3 Business Scenarios\n- Large project, team, fast iteration.\n\n## 2.4 Common Confusions\n- Arch/collab evolve together.\n- Tech choice by team skill.\n\n## 2.5 Deep Dive\n- Improve collab? Automation, doc, comms.\n- Arch upgrade? Business goal, tech debt.\n","updated":"2025-07-17T10:11:29.213Z","comments":1,"layout":"page","_id":"cmd78fh5n000w5ek71fu2ehy5","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-业务架构核心\"><a href=\"#1-1-业务架构核心\" class=\"headerlink\" title=\"1.1 业务架构核心\"></a>1.1 业务架构核心</h2><ul>\n<li>分层、解耦、服务化、API 设计、数据流。</li>\n<li>团队协作：代码规范、评审、CI&#x2F;CD、文档。</li>\n</ul>\n<h2 id=\"1-2-方案-实践示例\"><a href=\"#1-2-方案-实践示例\" class=\"headerlink\" title=\"1.2 方案&#x2F;实践示例\"></a>1.2 方案&#x2F;实践示例</h2><ul>\n<li>API 统一、模块 owner、自动化测试。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型项目、多人协作、快速迭代。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>架构与协作需同步演进。</li>\n<li>技术选型需兼顾团队能力。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升协作效率？自动化、文档、沟通机制。</li>\n<li>架构升级如何推动？结合业务目标、技术债务。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Business-Architecture\"><a href=\"#2-1-Business-Architecture\" class=\"headerlink\" title=\"2.1 Business Architecture\"></a>2.1 Business Architecture</h2><ul>\n<li>Layer, decouple, service, API, data flow.</li>\n<li>Team: code style, review, CI&#x2F;CD, doc.</li>\n</ul>\n<h2 id=\"2-2-Solution-Practice-Example\"><a href=\"#2-2-Solution-Practice-Example\" class=\"headerlink\" title=\"2.2 Solution&#x2F;Practice Example\"></a>2.2 Solution&#x2F;Practice Example</h2><ul>\n<li>Unified API, module owner, auto test.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large project, team, fast iteration.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Arch&#x2F;collab evolve together.</li>\n<li>Tech choice by team skill.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Improve collab? Automation, doc, comms.</li>\n<li>Arch upgrade? Business goal, tech debt.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-业务架构核心\"><a href=\"#1-1-业务架构核心\" class=\"headerlink\" title=\"1.1 业务架构核心\"></a>1.1 业务架构核心</h2><ul>\n<li>分层、解耦、服务化、API 设计、数据流。</li>\n<li>团队协作：代码规范、评审、CI&#x2F;CD、文档。</li>\n</ul>\n<h2 id=\"1-2-方案-实践示例\"><a href=\"#1-2-方案-实践示例\" class=\"headerlink\" title=\"1.2 方案&#x2F;实践示例\"></a>1.2 方案&#x2F;实践示例</h2><ul>\n<li>API 统一、模块 owner、自动化测试。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型项目、多人协作、快速迭代。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>架构与协作需同步演进。</li>\n<li>技术选型需兼顾团队能力。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升协作效率？自动化、文档、沟通机制。</li>\n<li>架构升级如何推动？结合业务目标、技术债务。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Business-Architecture\"><a href=\"#2-1-Business-Architecture\" class=\"headerlink\" title=\"2.1 Business Architecture\"></a>2.1 Business Architecture</h2><ul>\n<li>Layer, decouple, service, API, data flow.</li>\n<li>Team: code style, review, CI&#x2F;CD, doc.</li>\n</ul>\n<h2 id=\"2-2-Solution-Practice-Example\"><a href=\"#2-2-Solution-Practice-Example\" class=\"headerlink\" title=\"2.2 Solution&#x2F;Practice Example\"></a>2.2 Solution&#x2F;Practice Example</h2><ul>\n<li>Unified API, module owner, auto test.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large project, team, fast iteration.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Arch&#x2F;collab evolve together.</li>\n<li>Tech choice by team skill.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Improve collab? Automation, doc, comms.</li>\n<li>Arch upgrade? Business goal, tech debt.</li>\n</ul>\n"},{"title":"iOS 代码规范与重构实践","date":"2025-07-16T16:00:00.000Z","path":"iOS/代码规范与重构实践.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 规范要点\n- 命名、注释、分层、SOLID、代码审查。\n- 重构：解耦、提取方法、消除重复、单一职责。\n\n## 1.2 代码示例\n```swift\n// 命名清晰、注释规范\nfunc fetchUserInfo() -> User? { ... }\n```\n\n## 1.3 业务场景\n- 代码可维护性、团队协作、技术债务治理。\n\n## 1.4 易混淆点\n- 规范≠死板，需结合业务灵活调整。\n- 重构需有测试保障。\n\n## 1.5 深挖追问\n- 如何推动规范落地？自动化工具、code review。\n- 重构风险如何控制？小步快跑、回滚机制。\n\n# 2. English Answer\n\n## 2.1 Key Points\n- Naming, comment, layer, SOLID, review.\n- Refactor: decouple, extract, DRY, SRP.\n\n## 2.2 Code Example\n```swift\n// Clear naming, good comment\nfunc fetchUserInfo() -> User? { ... }\n```\n\n## 2.3 Business Scenarios\n- Maintainability, team, tech debt.\n\n## 2.4 Common Confusions\n- Spec ≠ rigid, adapt to business.\n- Refactor needs test.\n\n## 2.5 Deep Dive\n- How to enforce? Tool, review.\n- Refactor risk? Small, rollback.\n","source":"iOS/代码规范与重构实践.md","raw":"---\ntitle: iOS 代码规范与重构实践\ndate: 2025-07-17\npath: source/iOS/代码规范与重构实践.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 规范要点\n- 命名、注释、分层、SOLID、代码审查。\n- 重构：解耦、提取方法、消除重复、单一职责。\n\n## 1.2 代码示例\n```swift\n// 命名清晰、注释规范\nfunc fetchUserInfo() -> User? { ... }\n```\n\n## 1.3 业务场景\n- 代码可维护性、团队协作、技术债务治理。\n\n## 1.4 易混淆点\n- 规范≠死板，需结合业务灵活调整。\n- 重构需有测试保障。\n\n## 1.5 深挖追问\n- 如何推动规范落地？自动化工具、code review。\n- 重构风险如何控制？小步快跑、回滚机制。\n\n# 2. English Answer\n\n## 2.1 Key Points\n- Naming, comment, layer, SOLID, review.\n- Refactor: decouple, extract, DRY, SRP.\n\n## 2.2 Code Example\n```swift\n// Clear naming, good comment\nfunc fetchUserInfo() -> User? { ... }\n```\n\n## 2.3 Business Scenarios\n- Maintainability, team, tech debt.\n\n## 2.4 Common Confusions\n- Spec ≠ rigid, adapt to business.\n- Refactor needs test.\n\n## 2.5 Deep Dive\n- How to enforce? Tool, review.\n- Refactor risk? Small, rollback.\n","updated":"2025-07-17T10:11:29.231Z","comments":1,"layout":"page","_id":"cmd78fh5n000x5ek714bxeydp","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-规范要点\"><a href=\"#1-1-规范要点\" class=\"headerlink\" title=\"1.1 规范要点\"></a>1.1 规范要点</h2><ul>\n<li>命名、注释、分层、SOLID、代码审查。</li>\n<li>重构：解耦、提取方法、消除重复、单一职责。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名清晰、注释规范</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchUserInfo</span>() -&gt; <span class=\"type\">User</span>? &#123; <span class=\"operator\">...</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>代码可维护性、团队协作、技术债务治理。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>规范≠死板，需结合业务灵活调整。</li>\n<li>重构需有测试保障。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何推动规范落地？自动化工具、code review。</li>\n<li>重构风险如何控制？小步快跑、回滚机制。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Points\"><a href=\"#2-1-Key-Points\" class=\"headerlink\" title=\"2.1 Key Points\"></a>2.1 Key Points</h2><ul>\n<li>Naming, comment, layer, SOLID, review.</li>\n<li>Refactor: decouple, extract, DRY, SRP.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Clear naming, good comment</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchUserInfo</span>() -&gt; <span class=\"type\">User</span>? &#123; <span class=\"operator\">...</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Maintainability, team, tech debt.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Spec ≠ rigid, adapt to business.</li>\n<li>Refactor needs test.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to enforce? Tool, review.</li>\n<li>Refactor risk? Small, rollback.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-规范要点\"><a href=\"#1-1-规范要点\" class=\"headerlink\" title=\"1.1 规范要点\"></a>1.1 规范要点</h2><ul>\n<li>命名、注释、分层、SOLID、代码审查。</li>\n<li>重构：解耦、提取方法、消除重复、单一职责。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命名清晰、注释规范</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchUserInfo</span>() -&gt; <span class=\"type\">User</span>? &#123; <span class=\"operator\">...</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>代码可维护性、团队协作、技术债务治理。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>规范≠死板，需结合业务灵活调整。</li>\n<li>重构需有测试保障。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何推动规范落地？自动化工具、code review。</li>\n<li>重构风险如何控制？小步快跑、回滚机制。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Points\"><a href=\"#2-1-Key-Points\" class=\"headerlink\" title=\"2.1 Key Points\"></a>2.1 Key Points</h2><ul>\n<li>Naming, comment, layer, SOLID, review.</li>\n<li>Refactor: decouple, extract, DRY, SRP.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Clear naming, good comment</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchUserInfo</span>() -&gt; <span class=\"type\">User</span>? &#123; <span class=\"operator\">...</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Maintainability, team, tech debt.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Spec ≠ rigid, adapt to business.</li>\n<li>Refactor needs test.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to enforce? Tool, review.</li>\n<li>Refactor risk? Small, rollback.</li>\n</ul>\n"},{"title":"iOS 典型业务场景技术方案","date":"2025-07-16T16:00:00.000Z","path":"iOS/典型业务场景技术方案.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 典型场景\n- 登录注册、支付、IM、音视频、地图、推送、埋点、A/B 测试。\n\n## 1.2 技术方案\n- 登录：OAuth、验证码、Keychain。\n- 支付：Apple Pay、三方 SDK。\n- IM：WebSocket、消息队列。\n- 音视频：AVFoundation、RTC。\n- 地图：MapKit、高德。\n- 推送：APNs、极光。\n- 埋点：埋点 SDK、无埋点。\n- A/B：分流、灰度。\n\n## 1.3 业务场景\n- 大型 App、复杂功能、用户增长。\n\n## 1.4 易混淆点\n- 方案选型需结合业务、合规、成本。\n- 各场景有专用最佳实践。\n\n## 1.5 深挖追问\n- 如何统一技术栈？中台、服务化、SDK。\n- 业务快速变更如何支撑？插件化、低代码。\n\n# 2. English Answer\n\n## 2.1 Typical Scenarios\n- Login, pay, IM, AV, map, push, analytics, A/B.\n\n## 2.2 Tech Solution\n- Login: OAuth, code, Keychain.\n- Pay: Apple Pay, 3rd SDK.\n- IM: WebSocket, MQ.\n- AV: AVFoundation, RTC.\n- Map: MapKit, Amap.\n- Push: APNs, JPush.\n- Analytics: SDK, no code.\n- A/B: split, gray.\n\n## 2.3 Business Scenarios\n- Large app, complex, growth.\n\n## 2.4 Common Confusions\n- Choose by business, compliance, cost.\n- Each has best practice.\n\n## 2.5 Deep Dive\n- Unified stack? Middle, service, SDK.\n- Fast change? Plugin, low code.\n","source":"iOS/典型业务场景技术方案.md","raw":"---\ntitle: iOS 典型业务场景技术方案\ndate: 2025-07-17\npath: source/iOS/典型业务场景技术方案.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 典型场景\n- 登录注册、支付、IM、音视频、地图、推送、埋点、A/B 测试。\n\n## 1.2 技术方案\n- 登录：OAuth、验证码、Keychain。\n- 支付：Apple Pay、三方 SDK。\n- IM：WebSocket、消息队列。\n- 音视频：AVFoundation、RTC。\n- 地图：MapKit、高德。\n- 推送：APNs、极光。\n- 埋点：埋点 SDK、无埋点。\n- A/B：分流、灰度。\n\n## 1.3 业务场景\n- 大型 App、复杂功能、用户增长。\n\n## 1.4 易混淆点\n- 方案选型需结合业务、合规、成本。\n- 各场景有专用最佳实践。\n\n## 1.5 深挖追问\n- 如何统一技术栈？中台、服务化、SDK。\n- 业务快速变更如何支撑？插件化、低代码。\n\n# 2. English Answer\n\n## 2.1 Typical Scenarios\n- Login, pay, IM, AV, map, push, analytics, A/B.\n\n## 2.2 Tech Solution\n- Login: OAuth, code, Keychain.\n- Pay: Apple Pay, 3rd SDK.\n- IM: WebSocket, MQ.\n- AV: AVFoundation, RTC.\n- Map: MapKit, Amap.\n- Push: APNs, JPush.\n- Analytics: SDK, no code.\n- A/B: split, gray.\n\n## 2.3 Business Scenarios\n- Large app, complex, growth.\n\n## 2.4 Common Confusions\n- Choose by business, compliance, cost.\n- Each has best practice.\n\n## 2.5 Deep Dive\n- Unified stack? Middle, service, SDK.\n- Fast change? Plugin, low code.\n","updated":"2025-07-17T10:11:29.231Z","comments":1,"layout":"page","_id":"cmd78fh5n000y5ek7b7up61a4","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-典型场景\"><a href=\"#1-1-典型场景\" class=\"headerlink\" title=\"1.1 典型场景\"></a>1.1 典型场景</h2><ul>\n<li>登录注册、支付、IM、音视频、地图、推送、埋点、A&#x2F;B 测试。</li>\n</ul>\n<h2 id=\"1-2-技术方案\"><a href=\"#1-2-技术方案\" class=\"headerlink\" title=\"1.2 技术方案\"></a>1.2 技术方案</h2><ul>\n<li>登录：OAuth、验证码、Keychain。</li>\n<li>支付：Apple Pay、三方 SDK。</li>\n<li>IM：WebSocket、消息队列。</li>\n<li>音视频：AVFoundation、RTC。</li>\n<li>地图：MapKit、高德。</li>\n<li>推送：APNs、极光。</li>\n<li>埋点：埋点 SDK、无埋点。</li>\n<li>A&#x2F;B：分流、灰度。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、复杂功能、用户增长。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>方案选型需结合业务、合规、成本。</li>\n<li>各场景有专用最佳实践。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何统一技术栈？中台、服务化、SDK。</li>\n<li>业务快速变更如何支撑？插件化、低代码。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Typical-Scenarios\"><a href=\"#2-1-Typical-Scenarios\" class=\"headerlink\" title=\"2.1 Typical Scenarios\"></a>2.1 Typical Scenarios</h2><ul>\n<li>Login, pay, IM, AV, map, push, analytics, A&#x2F;B.</li>\n</ul>\n<h2 id=\"2-2-Tech-Solution\"><a href=\"#2-2-Tech-Solution\" class=\"headerlink\" title=\"2.2 Tech Solution\"></a>2.2 Tech Solution</h2><ul>\n<li>Login: OAuth, code, Keychain.</li>\n<li>Pay: Apple Pay, 3rd SDK.</li>\n<li>IM: WebSocket, MQ.</li>\n<li>AV: AVFoundation, RTC.</li>\n<li>Map: MapKit, Amap.</li>\n<li>Push: APNs, JPush.</li>\n<li>Analytics: SDK, no code.</li>\n<li>A&#x2F;B: split, gray.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, complex, growth.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Choose by business, compliance, cost.</li>\n<li>Each has best practice.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Unified stack? Middle, service, SDK.</li>\n<li>Fast change? Plugin, low code.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-典型场景\"><a href=\"#1-1-典型场景\" class=\"headerlink\" title=\"1.1 典型场景\"></a>1.1 典型场景</h2><ul>\n<li>登录注册、支付、IM、音视频、地图、推送、埋点、A&#x2F;B 测试。</li>\n</ul>\n<h2 id=\"1-2-技术方案\"><a href=\"#1-2-技术方案\" class=\"headerlink\" title=\"1.2 技术方案\"></a>1.2 技术方案</h2><ul>\n<li>登录：OAuth、验证码、Keychain。</li>\n<li>支付：Apple Pay、三方 SDK。</li>\n<li>IM：WebSocket、消息队列。</li>\n<li>音视频：AVFoundation、RTC。</li>\n<li>地图：MapKit、高德。</li>\n<li>推送：APNs、极光。</li>\n<li>埋点：埋点 SDK、无埋点。</li>\n<li>A&#x2F;B：分流、灰度。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、复杂功能、用户增长。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>方案选型需结合业务、合规、成本。</li>\n<li>各场景有专用最佳实践。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何统一技术栈？中台、服务化、SDK。</li>\n<li>业务快速变更如何支撑？插件化、低代码。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Typical-Scenarios\"><a href=\"#2-1-Typical-Scenarios\" class=\"headerlink\" title=\"2.1 Typical Scenarios\"></a>2.1 Typical Scenarios</h2><ul>\n<li>Login, pay, IM, AV, map, push, analytics, A&#x2F;B.</li>\n</ul>\n<h2 id=\"2-2-Tech-Solution\"><a href=\"#2-2-Tech-Solution\" class=\"headerlink\" title=\"2.2 Tech Solution\"></a>2.2 Tech Solution</h2><ul>\n<li>Login: OAuth, code, Keychain.</li>\n<li>Pay: Apple Pay, 3rd SDK.</li>\n<li>IM: WebSocket, MQ.</li>\n<li>AV: AVFoundation, RTC.</li>\n<li>Map: MapKit, Amap.</li>\n<li>Push: APNs, JPush.</li>\n<li>Analytics: SDK, no code.</li>\n<li>A&#x2F;B: split, gray.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, complex, growth.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Choose by business, compliance, cost.</li>\n<li>Each has best practice.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Unified stack? Middle, service, SDK.</li>\n<li>Fast change? Plugin, low code.</li>\n</ul>\n"},{"title":"iOS 内存管理（ARC/循环引用）","date":"2025-07-16T16:00:00.000Z","path":"iOS/内存管理.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与机制\n- ARC（自动引用计数）：编译器自动插入 retain/release，管理对象生命周期。\n- 循环引用：对象间强引用导致内存无法释放。\n\n## 1.2 代码示例\n```swift\nclass A { var b: B? }\nclass B { weak var a: A? }\n```\n\n## 1.3 业务场景\n- 视图控制器、闭包、数据模型等。\n\n## 1.4 易混淆点\n- weak/unowned 区别：weak 可为 nil，unowned 不可。\n- 闭包默认强引用 self，需 [weak self]。\n\n## 1.5 深挖追问\n- ARC 底层？插入 retain/release/autorelease。\n- 如何检测循环引用？工具/内存分析。\n\n# 2. English Answer\n\n## 2.1 Concept & Mechanism\n- ARC: compiler inserts retain/release, manages lifecycle.\n- Retain cycle: strong refs prevent release.\n\n## 2.2 Code Example\n```swift\nclass A { var b: B? }\nclass B { weak var a: A? }\n```\n\n## 2.3 Business Scenarios\n- View controller, closure, data model, etc.\n\n## 2.4 Common Confusions\n- weak: can be nil; unowned: can't.\n- Closure: strong self by default, use [weak self].\n\n## 2.5 Deep Dive\n- ARC internals? Insert retain/release/autorelease.\n- Detect cycle? Tool/memory analysis.\n","source":"iOS/内存管理.md","raw":"---\ntitle: iOS 内存管理（ARC/循环引用）\ndate: 2025-07-17\npath: source/iOS/内存管理.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与机制\n- ARC（自动引用计数）：编译器自动插入 retain/release，管理对象生命周期。\n- 循环引用：对象间强引用导致内存无法释放。\n\n## 1.2 代码示例\n```swift\nclass A { var b: B? }\nclass B { weak var a: A? }\n```\n\n## 1.3 业务场景\n- 视图控制器、闭包、数据模型等。\n\n## 1.4 易混淆点\n- weak/unowned 区别：weak 可为 nil，unowned 不可。\n- 闭包默认强引用 self，需 [weak self]。\n\n## 1.5 深挖追问\n- ARC 底层？插入 retain/release/autorelease。\n- 如何检测循环引用？工具/内存分析。\n\n# 2. English Answer\n\n## 2.1 Concept & Mechanism\n- ARC: compiler inserts retain/release, manages lifecycle.\n- Retain cycle: strong refs prevent release.\n\n## 2.2 Code Example\n```swift\nclass A { var b: B? }\nclass B { weak var a: A? }\n```\n\n## 2.3 Business Scenarios\n- View controller, closure, data model, etc.\n\n## 2.4 Common Confusions\n- weak: can be nil; unowned: can't.\n- Closure: strong self by default, use [weak self].\n\n## 2.5 Deep Dive\n- ARC internals? Insert retain/release/autorelease.\n- Detect cycle? Tool/memory analysis.\n","updated":"2025-07-17T10:11:29.165Z","comments":1,"layout":"page","_id":"cmd78fh5n000z5ek78lgeg2q3","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与机制\"><a href=\"#1-1-概念与机制\" class=\"headerlink\" title=\"1.1 概念与机制\"></a>1.1 概念与机制</h2><ul>\n<li>ARC（自动引用计数）：编译器自动插入 retain&#x2F;release，管理对象生命周期。</li>\n<li>循环引用：对象间强引用导致内存无法释放。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123; <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>? &#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123; <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>? &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>视图控制器、闭包、数据模型等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>weak&#x2F;unowned 区别：weak 可为 nil，unowned 不可。</li>\n<li>闭包默认强引用 self，需 [weak self]。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>ARC 底层？插入 retain&#x2F;release&#x2F;autorelease。</li>\n<li>如何检测循环引用？工具&#x2F;内存分析。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Mechanism\"><a href=\"#2-1-Concept-Mechanism\" class=\"headerlink\" title=\"2.1 Concept &amp; Mechanism\"></a>2.1 Concept &amp; Mechanism</h2><ul>\n<li>ARC: compiler inserts retain&#x2F;release, manages lifecycle.</li>\n<li>Retain cycle: strong refs prevent release.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123; <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>? &#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123; <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>? &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>View controller, closure, data model, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>weak: can be nil; unowned: can’t.</li>\n<li>Closure: strong self by default, use [weak self].</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>ARC internals? Insert retain&#x2F;release&#x2F;autorelease.</li>\n<li>Detect cycle? Tool&#x2F;memory analysis.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与机制\"><a href=\"#1-1-概念与机制\" class=\"headerlink\" title=\"1.1 概念与机制\"></a>1.1 概念与机制</h2><ul>\n<li>ARC（自动引用计数）：编译器自动插入 retain&#x2F;release，管理对象生命周期。</li>\n<li>循环引用：对象间强引用导致内存无法释放。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123; <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>? &#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123; <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>? &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>视图控制器、闭包、数据模型等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>weak&#x2F;unowned 区别：weak 可为 nil，unowned 不可。</li>\n<li>闭包默认强引用 self，需 [weak self]。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>ARC 底层？插入 retain&#x2F;release&#x2F;autorelease。</li>\n<li>如何检测循环引用？工具&#x2F;内存分析。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Mechanism\"><a href=\"#2-1-Concept-Mechanism\" class=\"headerlink\" title=\"2.1 Concept &amp; Mechanism\"></a>2.1 Concept &amp; Mechanism</h2><ul>\n<li>ARC: compiler inserts retain&#x2F;release, manages lifecycle.</li>\n<li>Retain cycle: strong refs prevent release.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123; <span class=\"keyword\">var</span> b: <span class=\"type\">B</span>? &#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123; <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> a: <span class=\"type\">A</span>? &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>View controller, closure, data model, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>weak: can be nil; unowned: can’t.</li>\n<li>Closure: strong self by default, use [weak self].</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>ARC internals? Insert retain&#x2F;release&#x2F;autorelease.</li>\n<li>Detect cycle? Tool&#x2F;memory analysis.</li>\n</ul>\n"},{"title":"函数参数类型（inout/默认值/可变参数）","date":"2025-07-16T16:00:00.000Z","path":"iOS/函数参数类型.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与用法\n- inout：传引用，函数内可修改外部变量。\n- 默认值：参数有默认值，可省略。\n- 可变参数：用 ...，可传多个同类型参数。\n\n## 1.2 代码示例\n```swift\nfunc add(_ a: inout Int) { a += 1 }\nfunc greet(name: String = \"Tom\") { print(name) }\nfunc sum(_ nums: Int...) -> Int { nums.reduce(0, +) }\n```\n\n## 1.3 业务场景\n- inout：交换、排序等。\n- 默认值：API 友好。\n- 可变参数：聚合、批量处理。\n\n## 1.4 易混淆点\n- inout 需 & 传参，不能有默认值。\n- 可变参数只能有一个，且在最后。\n\n## 1.5 深挖追问\n- inout 实现原理？本质是引用传递。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\n- inout: pass by reference, can modify external var.\n- Default value: param can be omitted.\n- Variadic: ... for multiple same-type params.\n\n## 2.2 Code Example\n```swift\nfunc add(_ a: inout Int) { a += 1 }\nfunc greet(name: String = \"Tom\") { print(name) }\nfunc sum(_ nums: Int...) -> Int { nums.reduce(0, +) }\n```\n\n## 2.3 Business Scenarios\n- inout: swap, sort, etc.\n- Default: API friendly.\n- Variadic: aggregation, batch.\n\n## 2.4 Common Confusions\n- inout: use & to pass, no default value.\n- Only one variadic, must be last.\n\n## 2.5 Deep Dive\n- inout principle: reference passing.\n","source":"iOS/函数参数类型.md","raw":"---\ntitle: 函数参数类型（inout/默认值/可变参数）\ndate: 2025-07-17\npath: source/iOS/函数参数类型.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与用法\n- inout：传引用，函数内可修改外部变量。\n- 默认值：参数有默认值，可省略。\n- 可变参数：用 ...，可传多个同类型参数。\n\n## 1.2 代码示例\n```swift\nfunc add(_ a: inout Int) { a += 1 }\nfunc greet(name: String = \"Tom\") { print(name) }\nfunc sum(_ nums: Int...) -> Int { nums.reduce(0, +) }\n```\n\n## 1.3 业务场景\n- inout：交换、排序等。\n- 默认值：API 友好。\n- 可变参数：聚合、批量处理。\n\n## 1.4 易混淆点\n- inout 需 & 传参，不能有默认值。\n- 可变参数只能有一个，且在最后。\n\n## 1.5 深挖追问\n- inout 实现原理？本质是引用传递。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\n- inout: pass by reference, can modify external var.\n- Default value: param can be omitted.\n- Variadic: ... for multiple same-type params.\n\n## 2.2 Code Example\n```swift\nfunc add(_ a: inout Int) { a += 1 }\nfunc greet(name: String = \"Tom\") { print(name) }\nfunc sum(_ nums: Int...) -> Int { nums.reduce(0, +) }\n```\n\n## 2.3 Business Scenarios\n- inout: swap, sort, etc.\n- Default: API friendly.\n- Variadic: aggregation, batch.\n\n## 2.4 Common Confusions\n- inout: use & to pass, no default value.\n- Only one variadic, must be last.\n\n## 2.5 Deep Dive\n- inout principle: reference passing.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5n00105ek78mu3e0bk","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><ul>\n<li>inout：传引用，函数内可修改外部变量。</li>\n<li>默认值：参数有默认值，可省略。</li>\n<li>可变参数：用 …，可传多个同类型参数。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">add</span>(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">Int</span>) &#123; a <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span>) &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">sum</span>(<span class=\"keyword\">_</span> <span class=\"params\">nums</span>: <span class=\"type\">Int</span>...) -&gt; <span class=\"type\">Int</span> &#123; nums.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>inout：交换、排序等。</li>\n<li>默认值：API 友好。</li>\n<li>可变参数：聚合、批量处理。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>inout 需 &amp; 传参，不能有默认值。</li>\n<li>可变参数只能有一个，且在最后。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>inout 实现原理？本质是引用传递。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><ul>\n<li>inout: pass by reference, can modify external var.</li>\n<li>Default value: param can be omitted.</li>\n<li>Variadic: … for multiple same-type params.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">add</span>(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">Int</span>) &#123; a <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span>) &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">sum</span>(<span class=\"keyword\">_</span> <span class=\"params\">nums</span>: <span class=\"type\">Int</span>...) -&gt; <span class=\"type\">Int</span> &#123; nums.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>inout: swap, sort, etc.</li>\n<li>Default: API friendly.</li>\n<li>Variadic: aggregation, batch.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>inout: use &amp; to pass, no default value.</li>\n<li>Only one variadic, must be last.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>inout principle: reference passing.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><ul>\n<li>inout：传引用，函数内可修改外部变量。</li>\n<li>默认值：参数有默认值，可省略。</li>\n<li>可变参数：用 …，可传多个同类型参数。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">add</span>(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">Int</span>) &#123; a <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span>) &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">sum</span>(<span class=\"keyword\">_</span> <span class=\"params\">nums</span>: <span class=\"type\">Int</span>...) -&gt; <span class=\"type\">Int</span> &#123; nums.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>inout：交换、排序等。</li>\n<li>默认值：API 友好。</li>\n<li>可变参数：聚合、批量处理。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>inout 需 &amp; 传参，不能有默认值。</li>\n<li>可变参数只能有一个，且在最后。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>inout 实现原理？本质是引用传递。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><ul>\n<li>inout: pass by reference, can modify external var.</li>\n<li>Default value: param can be omitted.</li>\n<li>Variadic: … for multiple same-type params.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">add</span>(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">Int</span>) &#123; a <span class=\"operator\">+=</span> <span class=\"number\">1</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span>) &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">sum</span>(<span class=\"keyword\">_</span> <span class=\"params\">nums</span>: <span class=\"type\">Int</span>...) -&gt; <span class=\"type\">Int</span> &#123; nums.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>inout: swap, sort, etc.</li>\n<li>Default: API friendly.</li>\n<li>Variadic: aggregation, batch.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>inout: use &amp; to pass, no default value.</li>\n<li>Only one variadic, must be last.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>inout principle: reference passing.</li>\n</ul>\n"},{"title":"iOS 动画与渲染机制","date":"2025-07-16T16:00:00.000Z","path":"iOS/动画与渲染机制.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 核心机制\n- Core Animation：基于 CALayer，支持隐式/显式动画。\n- 渲染流程：CPU 计算、GPU 合成、双缓冲、VSync。\n\n## 1.2 代码示例\n```swift\nUIView.animate(withDuration: 0.3) {\n    view.alpha = 0\n}\n```\n\n## 1.3 业务场景\n- 页面切换、交互动效、性能优化。\n\n## 1.4 易混淆点\n- 隐式动画：直接修改属性。\n- 显式动画：CABasicAnimation、CAKeyframeAnimation。\n\n## 1.5 深挖追问\n- 动画掉帧原因？主线程阻塞、GPU 过载。\n- 如何优化？异步、合成层级、图片压缩。\n\n# 2. English Answer\n\n## 2.1 Core Mechanism\n- Core Animation: CALayer-based, implicit/explicit.\n- Render: CPU, GPU, double buffer, VSync.\n\n## 2.2 Code Example\n```swift\nUIView.animate(withDuration: 0.3) {\n    view.alpha = 0\n}\n```\n\n## 2.3 Business Scenarios\n- Page switch, interaction, perf tuning.\n\n## 2.4 Common Confusions\n- Implicit: direct property change.\n- Explicit: CABasicAnimation, CAKeyframeAnimation.\n\n## 2.5 Deep Dive\n- Drop frame? Main thread block, GPU overload.\n- Optimize? Async, flatten layer, compress image.\n","source":"iOS/动画与渲染机制.md","raw":"---\ntitle: iOS 动画与渲染机制\ndate: 2025-07-17\npath: source/iOS/动画与渲染机制.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 核心机制\n- Core Animation：基于 CALayer，支持隐式/显式动画。\n- 渲染流程：CPU 计算、GPU 合成、双缓冲、VSync。\n\n## 1.2 代码示例\n```swift\nUIView.animate(withDuration: 0.3) {\n    view.alpha = 0\n}\n```\n\n## 1.3 业务场景\n- 页面切换、交互动效、性能优化。\n\n## 1.4 易混淆点\n- 隐式动画：直接修改属性。\n- 显式动画：CABasicAnimation、CAKeyframeAnimation。\n\n## 1.5 深挖追问\n- 动画掉帧原因？主线程阻塞、GPU 过载。\n- 如何优化？异步、合成层级、图片压缩。\n\n# 2. English Answer\n\n## 2.1 Core Mechanism\n- Core Animation: CALayer-based, implicit/explicit.\n- Render: CPU, GPU, double buffer, VSync.\n\n## 2.2 Code Example\n```swift\nUIView.animate(withDuration: 0.3) {\n    view.alpha = 0\n}\n```\n\n## 2.3 Business Scenarios\n- Page switch, interaction, perf tuning.\n\n## 2.4 Common Confusions\n- Implicit: direct property change.\n- Explicit: CABasicAnimation, CAKeyframeAnimation.\n\n## 2.5 Deep Dive\n- Drop frame? Main thread block, GPU overload.\n- Optimize? Async, flatten layer, compress image.\n","updated":"2025-07-17T10:11:29.216Z","comments":1,"layout":"page","_id":"cmd78fh5o00115ek7an4hfujq","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-核心机制\"><a href=\"#1-1-核心机制\" class=\"headerlink\" title=\"1.1 核心机制\"></a>1.1 核心机制</h2><ul>\n<li>Core Animation：基于 CALayer，支持隐式&#x2F;显式动画。</li>\n<li>渲染流程：CPU 计算、GPU 合成、双缓冲、VSync。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>页面切换、交互动效、性能优化。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>隐式动画：直接修改属性。</li>\n<li>显式动画：CABasicAnimation、CAKeyframeAnimation。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>动画掉帧原因？主线程阻塞、GPU 过载。</li>\n<li>如何优化？异步、合成层级、图片压缩。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Core-Mechanism\"><a href=\"#2-1-Core-Mechanism\" class=\"headerlink\" title=\"2.1 Core Mechanism\"></a>2.1 Core Mechanism</h2><ul>\n<li>Core Animation: CALayer-based, implicit&#x2F;explicit.</li>\n<li>Render: CPU, GPU, double buffer, VSync.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Page switch, interaction, perf tuning.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Implicit: direct property change.</li>\n<li>Explicit: CABasicAnimation, CAKeyframeAnimation.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Drop frame? Main thread block, GPU overload.</li>\n<li>Optimize? Async, flatten layer, compress image.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-核心机制\"><a href=\"#1-1-核心机制\" class=\"headerlink\" title=\"1.1 核心机制\"></a>1.1 核心机制</h2><ul>\n<li>Core Animation：基于 CALayer，支持隐式&#x2F;显式动画。</li>\n<li>渲染流程：CPU 计算、GPU 合成、双缓冲、VSync。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>页面切换、交互动效、性能优化。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>隐式动画：直接修改属性。</li>\n<li>显式动画：CABasicAnimation、CAKeyframeAnimation。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>动画掉帧原因？主线程阻塞、GPU 过载。</li>\n<li>如何优化？异步、合成层级、图片压缩。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Core-Mechanism\"><a href=\"#2-1-Core-Mechanism\" class=\"headerlink\" title=\"2.1 Core Mechanism\"></a>2.1 Core Mechanism</h2><ul>\n<li>Core Animation: CALayer-based, implicit&#x2F;explicit.</li>\n<li>Render: CPU, GPU, double buffer, VSync.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Page switch, interaction, perf tuning.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Implicit: direct property change.</li>\n<li>Explicit: CABasicAnimation, CAKeyframeAnimation.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Drop frame? Main thread block, GPU overload.</li>\n<li>Optimize? Async, flatten layer, compress image.</li>\n</ul>\n"},{"title":"协议可选设计","date":"2025-07-16T16:00:00.000Z","path":"iOS/协议可选设计.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与实现\n- Swift 协议默认所有方法必须实现。\n- 可选协议方法需加 `@objc`，并用 `optional` 修饰，仅限 class 类型。\n\n## 1.2 代码示例\n```swift\n@objc protocol MyDelegate {\n    @objc optional func didClick()\n}\n\nclass MyClass: MyDelegate {\n    // 可不实现 didClick\n}\n```\n\n## 1.3 业务场景\n- 代理回调、事件通知等。\n\n## 1.4 易混淆点\n- 纯 Swift 协议不支持 optional，需 @objc。\n- 仅 class 可用，struct/enum 不支持。\n\n## 1.5 深挖追问\n- 为什么 Swift 不直接支持？类型安全、编译期检查。\n- 如何用默认实现替代？extension 提供默认实现。\n\n# 2. English Answer\n\n## 2.1 Concept & Implementation\n- Swift protocols: all methods required by default.\n- Optional: use `@objc` and `optional`, class-only.\n\n## 2.2 Code Example\n```swift\n@objc protocol MyDelegate {\n    @objc optional func didClick()\n}\n\nclass MyClass: MyDelegate {\n    // didClick is optional\n}\n```\n\n## 2.3 Business Scenarios\n- Delegate callbacks, event notification, etc.\n\n## 2.4 Common Confusions\n- Pure Swift protocol: no optional, need @objc.\n- Only class, not struct/enum.\n\n## 2.5 Deep Dive\n- Why not in Swift? Type safety, compile check.\n- How to use default implementation? Use extension.\n","source":"iOS/协议可选设计.md","raw":"---\ntitle: 协议可选设计\ndate: 2025-07-17\npath: source/iOS/协议可选设计.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与实现\n- Swift 协议默认所有方法必须实现。\n- 可选协议方法需加 `@objc`，并用 `optional` 修饰，仅限 class 类型。\n\n## 1.2 代码示例\n```swift\n@objc protocol MyDelegate {\n    @objc optional func didClick()\n}\n\nclass MyClass: MyDelegate {\n    // 可不实现 didClick\n}\n```\n\n## 1.3 业务场景\n- 代理回调、事件通知等。\n\n## 1.4 易混淆点\n- 纯 Swift 协议不支持 optional，需 @objc。\n- 仅 class 可用，struct/enum 不支持。\n\n## 1.5 深挖追问\n- 为什么 Swift 不直接支持？类型安全、编译期检查。\n- 如何用默认实现替代？extension 提供默认实现。\n\n# 2. English Answer\n\n## 2.1 Concept & Implementation\n- Swift protocols: all methods required by default.\n- Optional: use `@objc` and `optional`, class-only.\n\n## 2.2 Code Example\n```swift\n@objc protocol MyDelegate {\n    @objc optional func didClick()\n}\n\nclass MyClass: MyDelegate {\n    // didClick is optional\n}\n```\n\n## 2.3 Business Scenarios\n- Delegate callbacks, event notification, etc.\n\n## 2.4 Common Confusions\n- Pure Swift protocol: no optional, need @objc.\n- Only class, not struct/enum.\n\n## 2.5 Deep Dive\n- Why not in Swift? Type safety, compile check.\n- How to use default implementation? Use extension.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5o00125ek7hztwgpj8","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与实现\"><a href=\"#1-1-概念与实现\" class=\"headerlink\" title=\"1.1 概念与实现\"></a>1.1 概念与实现</h2><ul>\n<li>Swift 协议默认所有方法必须实现。</li>\n<li>可选协议方法需加 <code>@objc</code>，并用 <code>optional</code> 修饰，仅限 class 类型。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@objc</span> <span class=\"keyword\">protocol</span> <span class=\"title class_\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"keyword\">func</span> <span class=\"title function_\">didClick</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span>: <span class=\"title class_ inherited__\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可不实现 didClick</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>代理回调、事件通知等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>纯 Swift 协议不支持 optional，需 @objc。</li>\n<li>仅 class 可用，struct&#x2F;enum 不支持。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>为什么 Swift 不直接支持？类型安全、编译期检查。</li>\n<li>如何用默认实现替代？extension 提供默认实现。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Implementation\"><a href=\"#2-1-Concept-Implementation\" class=\"headerlink\" title=\"2.1 Concept &amp; Implementation\"></a>2.1 Concept &amp; Implementation</h2><ul>\n<li>Swift protocols: all methods required by default.</li>\n<li>Optional: use <code>@objc</code> and <code>optional</code>, class-only.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@objc</span> <span class=\"keyword\">protocol</span> <span class=\"title class_\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"keyword\">func</span> <span class=\"title function_\">didClick</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span>: <span class=\"title class_ inherited__\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// didClick is optional</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Delegate callbacks, event notification, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Pure Swift protocol: no optional, need @objc.</li>\n<li>Only class, not struct&#x2F;enum.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Why not in Swift? Type safety, compile check.</li>\n<li>How to use default implementation? Use extension.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与实现\"><a href=\"#1-1-概念与实现\" class=\"headerlink\" title=\"1.1 概念与实现\"></a>1.1 概念与实现</h2><ul>\n<li>Swift 协议默认所有方法必须实现。</li>\n<li>可选协议方法需加 <code>@objc</code>，并用 <code>optional</code> 修饰，仅限 class 类型。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@objc</span> <span class=\"keyword\">protocol</span> <span class=\"title class_\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"keyword\">func</span> <span class=\"title function_\">didClick</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span>: <span class=\"title class_ inherited__\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可不实现 didClick</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>代理回调、事件通知等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>纯 Swift 协议不支持 optional，需 @objc。</li>\n<li>仅 class 可用，struct&#x2F;enum 不支持。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>为什么 Swift 不直接支持？类型安全、编译期检查。</li>\n<li>如何用默认实现替代？extension 提供默认实现。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Implementation\"><a href=\"#2-1-Concept-Implementation\" class=\"headerlink\" title=\"2.1 Concept &amp; Implementation\"></a>2.1 Concept &amp; Implementation</h2><ul>\n<li>Swift protocols: all methods required by default.</li>\n<li>Optional: use <code>@objc</code> and <code>optional</code>, class-only.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@objc</span> <span class=\"keyword\">protocol</span> <span class=\"title class_\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"keyword\">func</span> <span class=\"title function_\">didClick</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span>: <span class=\"title class_ inherited__\">MyDelegate</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// didClick is optional</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Delegate callbacks, event notification, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Pure Swift protocol: no optional, need @objc.</li>\n<li>Only class, not struct&#x2F;enum.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Why not in Swift? Type safety, compile check.</li>\n<li>How to use default implementation? Use extension.</li>\n</ul>\n"},{"title":"iOS App 启动流程与冷启动优化","date":"2025-07-16T16:00:00.000Z","path":"iOS/启动流程与冷启动优化.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 启动流程\n- 加载可执行文件、动态库、main()、UIApplicationMain、AppDelegate、首屏渲染。\n\n## 1.2 冷启动优化\n- 精简启动代码、延迟初始化、异步加载、图片压缩、预加载。\n\n## 1.3 业务场景\n- 大型 App、复杂首页、弱网环境。\n\n## 1.4 易混淆点\n- 冷启动/热启动/唤醒区别。\n- 优化需量化指标（Time Profiler、埋点）。\n\n## 1.5 深挖追问\n- 启动慢的常见原因？I/O、主线程阻塞、资源大。\n- 如何监控？Instruments、日志、A/B 测试。\n\n# 2. English Answer\n\n## 2.1 Launch Flow\n- Load binary, dylib, main(), UIApplicationMain, AppDelegate, first render.\n\n## 2.2 Cold Start Optimization\n- Slim code, lazy init, async load, image compress, preload.\n\n## 2.3 Business Scenarios\n- Large app, complex home, weak network.\n\n## 2.4 Common Confusions\n- Cold/warm/resume diff.\n- Need metrics (Time Profiler, log).\n\n## 2.5 Deep Dive\n- Slow reason? I/O, main block, big resource.\n- Monitor? Instruments, log, A/B test.\n","source":"iOS/启动流程与冷启动优化.md","raw":"---\ntitle: iOS App 启动流程与冷启动优化\ndate: 2025-07-17\npath: source/iOS/启动流程与冷启动优化.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 启动流程\n- 加载可执行文件、动态库、main()、UIApplicationMain、AppDelegate、首屏渲染。\n\n## 1.2 冷启动优化\n- 精简启动代码、延迟初始化、异步加载、图片压缩、预加载。\n\n## 1.3 业务场景\n- 大型 App、复杂首页、弱网环境。\n\n## 1.4 易混淆点\n- 冷启动/热启动/唤醒区别。\n- 优化需量化指标（Time Profiler、埋点）。\n\n## 1.5 深挖追问\n- 启动慢的常见原因？I/O、主线程阻塞、资源大。\n- 如何监控？Instruments、日志、A/B 测试。\n\n# 2. English Answer\n\n## 2.1 Launch Flow\n- Load binary, dylib, main(), UIApplicationMain, AppDelegate, first render.\n\n## 2.2 Cold Start Optimization\n- Slim code, lazy init, async load, image compress, preload.\n\n## 2.3 Business Scenarios\n- Large app, complex home, weak network.\n\n## 2.4 Common Confusions\n- Cold/warm/resume diff.\n- Need metrics (Time Profiler, log).\n\n## 2.5 Deep Dive\n- Slow reason? I/O, main block, big resource.\n- Monitor? Instruments, log, A/B test.\n","updated":"2025-07-17T10:11:29.222Z","comments":1,"layout":"page","_id":"cmd78fh5o00135ek735pi0g2v","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-启动流程\"><a href=\"#1-1-启动流程\" class=\"headerlink\" title=\"1.1 启动流程\"></a>1.1 启动流程</h2><ul>\n<li>加载可执行文件、动态库、main()、UIApplicationMain、AppDelegate、首屏渲染。</li>\n</ul>\n<h2 id=\"1-2-冷启动优化\"><a href=\"#1-2-冷启动优化\" class=\"headerlink\" title=\"1.2 冷启动优化\"></a>1.2 冷启动优化</h2><ul>\n<li>精简启动代码、延迟初始化、异步加载、图片压缩、预加载。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、复杂首页、弱网环境。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>冷启动&#x2F;热启动&#x2F;唤醒区别。</li>\n<li>优化需量化指标（Time Profiler、埋点）。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>启动慢的常见原因？I&#x2F;O、主线程阻塞、资源大。</li>\n<li>如何监控？Instruments、日志、A&#x2F;B 测试。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Launch-Flow\"><a href=\"#2-1-Launch-Flow\" class=\"headerlink\" title=\"2.1 Launch Flow\"></a>2.1 Launch Flow</h2><ul>\n<li>Load binary, dylib, main(), UIApplicationMain, AppDelegate, first render.</li>\n</ul>\n<h2 id=\"2-2-Cold-Start-Optimization\"><a href=\"#2-2-Cold-Start-Optimization\" class=\"headerlink\" title=\"2.2 Cold Start Optimization\"></a>2.2 Cold Start Optimization</h2><ul>\n<li>Slim code, lazy init, async load, image compress, preload.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, complex home, weak network.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Cold&#x2F;warm&#x2F;resume diff.</li>\n<li>Need metrics (Time Profiler, log).</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Slow reason? I&#x2F;O, main block, big resource.</li>\n<li>Monitor? Instruments, log, A&#x2F;B test.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-启动流程\"><a href=\"#1-1-启动流程\" class=\"headerlink\" title=\"1.1 启动流程\"></a>1.1 启动流程</h2><ul>\n<li>加载可执行文件、动态库、main()、UIApplicationMain、AppDelegate、首屏渲染。</li>\n</ul>\n<h2 id=\"1-2-冷启动优化\"><a href=\"#1-2-冷启动优化\" class=\"headerlink\" title=\"1.2 冷启动优化\"></a>1.2 冷启动优化</h2><ul>\n<li>精简启动代码、延迟初始化、异步加载、图片压缩、预加载。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、复杂首页、弱网环境。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>冷启动&#x2F;热启动&#x2F;唤醒区别。</li>\n<li>优化需量化指标（Time Profiler、埋点）。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>启动慢的常见原因？I&#x2F;O、主线程阻塞、资源大。</li>\n<li>如何监控？Instruments、日志、A&#x2F;B 测试。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Launch-Flow\"><a href=\"#2-1-Launch-Flow\" class=\"headerlink\" title=\"2.1 Launch Flow\"></a>2.1 Launch Flow</h2><ul>\n<li>Load binary, dylib, main(), UIApplicationMain, AppDelegate, first render.</li>\n</ul>\n<h2 id=\"2-2-Cold-Start-Optimization\"><a href=\"#2-2-Cold-Start-Optimization\" class=\"headerlink\" title=\"2.2 Cold Start Optimization\"></a>2.2 Cold Start Optimization</h2><ul>\n<li>Slim code, lazy init, async load, image compress, preload.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, complex home, weak network.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Cold&#x2F;warm&#x2F;resume diff.</li>\n<li>Need metrics (Time Profiler, log).</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Slow reason? I&#x2F;O, main block, big resource.</li>\n<li>Monitor? Instruments, log, A&#x2F;B test.</li>\n</ul>\n"},{"title":"iOS 国际化与多语言适配","date":"2025-07-16T16:00:00.000Z","path":"iOS/国际化与多语言适配.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 核心点\n- Localizable.strings、NSLocalizedString、自动布局、时区/货币适配。\n\n## 1.2 代码示例\n```swift\nlet str = NSLocalizedString(\"hello\", comment: \"问候\")\n```\n\n## 1.3 业务场景\n- 海外市场、定制化、合规。\n\n## 1.4 易混淆点\n- 需区分本地化与国际化。\n- 资源文件命名、格式需统一。\n\n## 1.5 深挖追问\n- 如何动态切换语言？重启/刷新 UI。\n- 多语言测试如何自动化？脚本、快照。\n\n# 2. English Answer\n\n## 2.1 Key Points\n- Localizable.strings, NSLocalizedString, auto layout, timezone/currency.\n\n## 2.2 Code Example\n```swift\nlet str = NSLocalizedString(\"hello\", comment: \"greet\")\n```\n\n## 2.3 Business Scenarios\n- Overseas, customization, compliance.\n\n## 2.4 Common Confusions\n- Localization vs internationalization.\n- Resource file name/format.\n\n## 2.5 Deep Dive\n- Dynamic switch? Restart/refresh UI.\n- Auto test? Script, snapshot.\n","source":"iOS/国际化与多语言适配.md","raw":"---\ntitle: iOS 国际化与多语言适配\ndate: 2025-07-17\npath: source/iOS/国际化与多语言适配.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 核心点\n- Localizable.strings、NSLocalizedString、自动布局、时区/货币适配。\n\n## 1.2 代码示例\n```swift\nlet str = NSLocalizedString(\"hello\", comment: \"问候\")\n```\n\n## 1.3 业务场景\n- 海外市场、定制化、合规。\n\n## 1.4 易混淆点\n- 需区分本地化与国际化。\n- 资源文件命名、格式需统一。\n\n## 1.5 深挖追问\n- 如何动态切换语言？重启/刷新 UI。\n- 多语言测试如何自动化？脚本、快照。\n\n# 2. English Answer\n\n## 2.1 Key Points\n- Localizable.strings, NSLocalizedString, auto layout, timezone/currency.\n\n## 2.2 Code Example\n```swift\nlet str = NSLocalizedString(\"hello\", comment: \"greet\")\n```\n\n## 2.3 Business Scenarios\n- Overseas, customization, compliance.\n\n## 2.4 Common Confusions\n- Localization vs internationalization.\n- Resource file name/format.\n\n## 2.5 Deep Dive\n- Dynamic switch? Restart/refresh UI.\n- Auto test? Script, snapshot.\n","updated":"2025-07-17T10:11:29.219Z","comments":1,"layout":"page","_id":"cmd78fh5o00145ek7fcxy3l5h","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-核心点\"><a href=\"#1-1-核心点\" class=\"headerlink\" title=\"1.1 核心点\"></a>1.1 核心点</h2><ul>\n<li>Localizable.strings、NSLocalizedString、自动布局、时区&#x2F;货币适配。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"type\">NSLocalizedString</span>(<span class=\"string\">&quot;hello&quot;</span>, comment: <span class=\"string\">&quot;问候&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>海外市场、定制化、合规。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>需区分本地化与国际化。</li>\n<li>资源文件命名、格式需统一。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何动态切换语言？重启&#x2F;刷新 UI。</li>\n<li>多语言测试如何自动化？脚本、快照。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Points\"><a href=\"#2-1-Key-Points\" class=\"headerlink\" title=\"2.1 Key Points\"></a>2.1 Key Points</h2><ul>\n<li>Localizable.strings, NSLocalizedString, auto layout, timezone&#x2F;currency.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"type\">NSLocalizedString</span>(<span class=\"string\">&quot;hello&quot;</span>, comment: <span class=\"string\">&quot;greet&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Overseas, customization, compliance.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Localization vs internationalization.</li>\n<li>Resource file name&#x2F;format.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Dynamic switch? Restart&#x2F;refresh UI.</li>\n<li>Auto test? Script, snapshot.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-核心点\"><a href=\"#1-1-核心点\" class=\"headerlink\" title=\"1.1 核心点\"></a>1.1 核心点</h2><ul>\n<li>Localizable.strings、NSLocalizedString、自动布局、时区&#x2F;货币适配。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"type\">NSLocalizedString</span>(<span class=\"string\">&quot;hello&quot;</span>, comment: <span class=\"string\">&quot;问候&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>海外市场、定制化、合规。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>需区分本地化与国际化。</li>\n<li>资源文件命名、格式需统一。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何动态切换语言？重启&#x2F;刷新 UI。</li>\n<li>多语言测试如何自动化？脚本、快照。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Points\"><a href=\"#2-1-Key-Points\" class=\"headerlink\" title=\"2.1 Key Points\"></a>2.1 Key Points</h2><ul>\n<li>Localizable.strings, NSLocalizedString, auto layout, timezone&#x2F;currency.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str <span class=\"operator\">=</span> <span class=\"type\">NSLocalizedString</span>(<span class=\"string\">&quot;hello&quot;</span>, comment: <span class=\"string\">&quot;greet&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Overseas, customization, compliance.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Localization vs internationalization.</li>\n<li>Resource file name&#x2F;format.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Dynamic switch? Restart&#x2F;refresh UI.</li>\n<li>Auto test? Script, snapshot.</li>\n</ul>\n"},{"title":"属性观察器（willSet/didSet）","date":"2025-07-16T16:00:00.000Z","path":"iOS/属性观察器.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与作用\n属性观察器（Property Observers）用于监控属性值的变化，常见的有 `willSet`（将要设置）和 `didSet`（已经设置）。它们可以在属性值发生变化前后执行自定义逻辑。\n\n## 1.2 代码示例\n```swift\nclass User {\n    var name: String = \"\" {\n        willSet {\n            print(\"即将设置name为\\(newValue)\")\n        }\n        didSet {\n            print(\"name已从\\(oldValue)变为\\(name)\")\n        }\n    }\n}\n```\n\n## 1.3 业务场景\n- 表单输入校验、UI联动、数据同步等。\n\n## 1.4 易混淆点\n- 只适用于存储属性，不能用于计算属性。\n- 初始化时不会触发观察器。\n\n## 1.5 深挖追问\n- 如何避免 didSet 中递归触发？可用 guard 或条件判断。\n- KVO 与属性观察器区别？KVO更适合跨对象、动态监听，属性观察器更轻量。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nProperty observers (`willSet`/`didSet`) monitor changes to property values, allowing custom logic before/after value changes.\n\n## 2.2 Code Example\n```swift\nclass User {\n    var name: String = \"\" {\n        willSet {\n            print(\"Will set name to \\(newValue)\")\n        }\n        didSet {\n            print(\"Name changed from \\(oldValue) to \\(name)\")\n        }\n    }\n}\n```\n\n## 2.3 Business Scenarios\n- Form validation, UI updates, data sync, etc.\n\n## 2.4 Common Confusions\n- Only for stored properties, not computed ones.\n- Not triggered during initialization.\n\n## 2.5 Deep Dive\n- How to avoid recursion in didSet? Use guard/condition.\n- Difference with KVO? KVO is for cross-object, dynamic; property observers are lightweight.\n","source":"iOS/属性观察器.md","raw":"---\ntitle: 属性观察器（willSet/didSet）\ndate: 2025-07-17\npath: source/iOS/属性观察器.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与作用\n属性观察器（Property Observers）用于监控属性值的变化，常见的有 `willSet`（将要设置）和 `didSet`（已经设置）。它们可以在属性值发生变化前后执行自定义逻辑。\n\n## 1.2 代码示例\n```swift\nclass User {\n    var name: String = \"\" {\n        willSet {\n            print(\"即将设置name为\\(newValue)\")\n        }\n        didSet {\n            print(\"name已从\\(oldValue)变为\\(name)\")\n        }\n    }\n}\n```\n\n## 1.3 业务场景\n- 表单输入校验、UI联动、数据同步等。\n\n## 1.4 易混淆点\n- 只适用于存储属性，不能用于计算属性。\n- 初始化时不会触发观察器。\n\n## 1.5 深挖追问\n- 如何避免 didSet 中递归触发？可用 guard 或条件判断。\n- KVO 与属性观察器区别？KVO更适合跨对象、动态监听，属性观察器更轻量。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nProperty observers (`willSet`/`didSet`) monitor changes to property values, allowing custom logic before/after value changes.\n\n## 2.2 Code Example\n```swift\nclass User {\n    var name: String = \"\" {\n        willSet {\n            print(\"Will set name to \\(newValue)\")\n        }\n        didSet {\n            print(\"Name changed from \\(oldValue) to \\(name)\")\n        }\n    }\n}\n```\n\n## 2.3 Business Scenarios\n- Form validation, UI updates, data sync, etc.\n\n## 2.4 Common Confusions\n- Only for stored properties, not computed ones.\n- Not triggered during initialization.\n\n## 2.5 Deep Dive\n- How to avoid recursion in didSet? Use guard/condition.\n- Difference with KVO? KVO is for cross-object, dynamic; property observers are lightweight.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5o00155ek7694y3a94","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与作用\"><a href=\"#1-1-概念与作用\" class=\"headerlink\" title=\"1.1 概念与作用\"></a>1.1 概念与作用</h2><p>属性观察器（Property Observers）用于监控属性值的变化，常见的有 <code>willSet</code>（将要设置）和 <code>didSet</code>（已经设置）。它们可以在属性值发生变化前后执行自定义逻辑。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;即将设置name为<span class=\"subst\">\\(newValue)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;name已从<span class=\"subst\">\\(oldValue)</span>变为<span class=\"subst\">\\(name)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>表单输入校验、UI联动、数据同步等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>只适用于存储属性，不能用于计算属性。</li>\n<li>初始化时不会触发观察器。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何避免 didSet 中递归触发？可用 guard 或条件判断。</li>\n<li>KVO 与属性观察器区别？KVO更适合跨对象、动态监听，属性观察器更轻量。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Property observers (<code>willSet</code>&#x2F;<code>didSet</code>) monitor changes to property values, allowing custom logic before&#x2F;after value changes.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Will set name to <span class=\"subst\">\\(newValue)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Name changed from <span class=\"subst\">\\(oldValue)</span> to <span class=\"subst\">\\(name)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Form validation, UI updates, data sync, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Only for stored properties, not computed ones.</li>\n<li>Not triggered during initialization.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to avoid recursion in didSet? Use guard&#x2F;condition.</li>\n<li>Difference with KVO? KVO is for cross-object, dynamic; property observers are lightweight.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与作用\"><a href=\"#1-1-概念与作用\" class=\"headerlink\" title=\"1.1 概念与作用\"></a>1.1 概念与作用</h2><p>属性观察器（Property Observers）用于监控属性值的变化，常见的有 <code>willSet</code>（将要设置）和 <code>didSet</code>（已经设置）。它们可以在属性值发生变化前后执行自定义逻辑。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;即将设置name为<span class=\"subst\">\\(newValue)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;name已从<span class=\"subst\">\\(oldValue)</span>变为<span class=\"subst\">\\(name)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>表单输入校验、UI联动、数据同步等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>只适用于存储属性，不能用于计算属性。</li>\n<li>初始化时不会触发观察器。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何避免 didSet 中递归触发？可用 guard 或条件判断。</li>\n<li>KVO 与属性观察器区别？KVO更适合跨对象、动态监听，属性观察器更轻量。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Property observers (<code>willSet</code>&#x2F;<code>didSet</code>) monitor changes to property values, allowing custom logic before&#x2F;after value changes.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Will set name to <span class=\"subst\">\\(newValue)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Name changed from <span class=\"subst\">\\(oldValue)</span> to <span class=\"subst\">\\(name)</span>&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Form validation, UI updates, data sync, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Only for stored properties, not computed ones.</li>\n<li>Not triggered during initialization.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to avoid recursion in didSet? Use guard&#x2F;condition.</li>\n<li>Difference with KVO? KVO is for cross-object, dynamic; property observers are lightweight.</li>\n</ul>\n"},{"title":"iOS App 崩溃监控与异常处理","date":"2025-07-16T16:00:00.000Z","path":"iOS/崩溃监控与异常处理.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 监控与处理\n- 崩溃监控：Crashlytics、Bugly、Xcode Organizer。\n- 异常处理：try/catch、do/try、全局捕获、埋点。\n\n## 1.2 代码/方案示例\n- Swift try/catch、NSSetUncaughtExceptionHandler。\n\n## 1.3 业务场景\n- 线上稳定性、用户体验、快速定位。\n\n## 1.4 易混淆点\n- 崩溃与异常区别：崩溃不可恢复，异常可捕获。\n- 监控需保护用户隐私。\n\n## 1.5 深挖追问\n- 如何提升定位效率？符号化、自动上报、日志。\n- 崩溃率与业务目标如何平衡？容错、降级。\n\n# 2. English Answer\n\n## 2.1 Monitor & Handle\n- Crash: Crashlytics, Bugly, Xcode Organizer.\n- Exception: try/catch, do/try, global, log.\n\n## 2.2 Code/Solution Example\n- Swift try/catch, NSSetUncaughtExceptionHandler.\n\n## 2.3 Business Scenarios\n- Stability, UX, quick locate.\n\n## 2.4 Common Confusions\n- Crash vs exception: crash unrecoverable, exception catchable.\n- Monitor: protect privacy.\n\n## 2.5 Deep Dive\n- Locate? Symbolicate, auto report, log.\n- Crash rate vs business? Tolerance, degrade.\n","source":"iOS/崩溃监控与异常处理.md","raw":"---\ntitle: iOS App 崩溃监控与异常处理\ndate: 2025-07-17\npath: source/iOS/崩溃监控与异常处理.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 监控与处理\n- 崩溃监控：Crashlytics、Bugly、Xcode Organizer。\n- 异常处理：try/catch、do/try、全局捕获、埋点。\n\n## 1.2 代码/方案示例\n- Swift try/catch、NSSetUncaughtExceptionHandler。\n\n## 1.3 业务场景\n- 线上稳定性、用户体验、快速定位。\n\n## 1.4 易混淆点\n- 崩溃与异常区别：崩溃不可恢复，异常可捕获。\n- 监控需保护用户隐私。\n\n## 1.5 深挖追问\n- 如何提升定位效率？符号化、自动上报、日志。\n- 崩溃率与业务目标如何平衡？容错、降级。\n\n# 2. English Answer\n\n## 2.1 Monitor & Handle\n- Crash: Crashlytics, Bugly, Xcode Organizer.\n- Exception: try/catch, do/try, global, log.\n\n## 2.2 Code/Solution Example\n- Swift try/catch, NSSetUncaughtExceptionHandler.\n\n## 2.3 Business Scenarios\n- Stability, UX, quick locate.\n\n## 2.4 Common Confusions\n- Crash vs exception: crash unrecoverable, exception catchable.\n- Monitor: protect privacy.\n\n## 2.5 Deep Dive\n- Locate? Symbolicate, auto report, log.\n- Crash rate vs business? Tolerance, degrade.\n","updated":"2025-07-17T10:11:29.231Z","comments":1,"layout":"page","_id":"cmd78fh5o00165ek77rti9dlc","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-监控与处理\"><a href=\"#1-1-监控与处理\" class=\"headerlink\" title=\"1.1 监控与处理\"></a>1.1 监控与处理</h2><ul>\n<li>崩溃监控：Crashlytics、Bugly、Xcode Organizer。</li>\n<li>异常处理：try&#x2F;catch、do&#x2F;try、全局捕获、埋点。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>Swift try&#x2F;catch、NSSetUncaughtExceptionHandler。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>线上稳定性、用户体验、快速定位。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>崩溃与异常区别：崩溃不可恢复，异常可捕获。</li>\n<li>监控需保护用户隐私。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升定位效率？符号化、自动上报、日志。</li>\n<li>崩溃率与业务目标如何平衡？容错、降级。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Monitor-Handle\"><a href=\"#2-1-Monitor-Handle\" class=\"headerlink\" title=\"2.1 Monitor &amp; Handle\"></a>2.1 Monitor &amp; Handle</h2><ul>\n<li>Crash: Crashlytics, Bugly, Xcode Organizer.</li>\n<li>Exception: try&#x2F;catch, do&#x2F;try, global, log.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>Swift try&#x2F;catch, NSSetUncaughtExceptionHandler.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Stability, UX, quick locate.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Crash vs exception: crash unrecoverable, exception catchable.</li>\n<li>Monitor: protect privacy.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Locate? Symbolicate, auto report, log.</li>\n<li>Crash rate vs business? Tolerance, degrade.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-监控与处理\"><a href=\"#1-1-监控与处理\" class=\"headerlink\" title=\"1.1 监控与处理\"></a>1.1 监控与处理</h2><ul>\n<li>崩溃监控：Crashlytics、Bugly、Xcode Organizer。</li>\n<li>异常处理：try&#x2F;catch、do&#x2F;try、全局捕获、埋点。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>Swift try&#x2F;catch、NSSetUncaughtExceptionHandler。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>线上稳定性、用户体验、快速定位。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>崩溃与异常区别：崩溃不可恢复，异常可捕获。</li>\n<li>监控需保护用户隐私。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升定位效率？符号化、自动上报、日志。</li>\n<li>崩溃率与业务目标如何平衡？容错、降级。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Monitor-Handle\"><a href=\"#2-1-Monitor-Handle\" class=\"headerlink\" title=\"2.1 Monitor &amp; Handle\"></a>2.1 Monitor &amp; Handle</h2><ul>\n<li>Crash: Crashlytics, Bugly, Xcode Organizer.</li>\n<li>Exception: try&#x2F;catch, do&#x2F;try, global, log.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>Swift try&#x2F;catch, NSSetUncaughtExceptionHandler.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Stability, UX, quick locate.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Crash vs exception: crash unrecoverable, exception catchable.</li>\n<li>Monitor: protect privacy.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Locate? Symbolicate, auto report, log.</li>\n<li>Crash rate vs business? Tolerance, degrade.</li>\n</ul>\n"},{"title":"延迟存储属性（Lazy Stored Property）","date":"2025-07-16T16:00:00.000Z","path":"iOS/延迟存储属性.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念\n1. 延迟存储属性（lazy var）在第一次访问时才初始化。\n2. 只能用于 var，不能用于 let。\n3. 常用于依赖外部资源、初始化开销大、或需要 self 的场景。\n\n## 1.2 为什么要用？\n- 提升性能，节省内存。\n- 避免不必要的初始化，提升启动速度。\n\n## 1.3 实际代码示例\n```swift\nclass DataManager {\n    lazy var data: [String] = self.loadData()\n    func loadData() -> [String] {\n        print(\"加载数据\")\n        return [\"A\", \"B\", \"C\"]\n    }\n}\nlet manager = DataManager()\n// 此时 data 未初始化\nlet d = manager.data // 第一次访问，才初始化\n```\n\n## 1.4 业务/用户价值\n- 优化资源分配，提升用户体验。\n- 适合大数据、图片、网络等场景。\n\n## 1.5 易混淆点\n- lazy 不能用于 let。\n- lazy 属性不能在构造器中直接访问。\n\n# 2. English Answer\n\n## 2.1 Concept\n1. Lazy stored property (lazy var) is initialized on first access.\n2. Only for var, not let.\n3. Used for expensive, external, or self-dependent resources.\n\n## 2.2 Why use it?\n- Improves performance, saves memory.\n- Avoids unnecessary initialization, faster startup.\n\n## 2.3 Code Example\n```swift\nclass DataManager {\n    lazy var data: [String] = self.loadData()\n    func loadData() -> [String] {\n        print(\"Loading data\")\n        return [\"A\", \"B\", \"C\"]\n    }\n}\nlet manager = DataManager()\n// data not initialized yet\nlet d = manager.data // initialized on first access\n```\n\n## 2.4 Business/User Value\n- Optimizes resource allocation, better UX.\n- Good for big data, images, network, etc.\n\n## 2.5 Common Confusion\n- lazy can't be used with let.\n- lazy property can't be accessed in initializer.\n","source":"iOS/延迟存储属性.md","raw":"---\ntitle: 延迟存储属性（Lazy Stored Property）\ndate: 2025-07-17\npath: source/iOS/延迟存储属性.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念\n1. 延迟存储属性（lazy var）在第一次访问时才初始化。\n2. 只能用于 var，不能用于 let。\n3. 常用于依赖外部资源、初始化开销大、或需要 self 的场景。\n\n## 1.2 为什么要用？\n- 提升性能，节省内存。\n- 避免不必要的初始化，提升启动速度。\n\n## 1.3 实际代码示例\n```swift\nclass DataManager {\n    lazy var data: [String] = self.loadData()\n    func loadData() -> [String] {\n        print(\"加载数据\")\n        return [\"A\", \"B\", \"C\"]\n    }\n}\nlet manager = DataManager()\n// 此时 data 未初始化\nlet d = manager.data // 第一次访问，才初始化\n```\n\n## 1.4 业务/用户价值\n- 优化资源分配，提升用户体验。\n- 适合大数据、图片、网络等场景。\n\n## 1.5 易混淆点\n- lazy 不能用于 let。\n- lazy 属性不能在构造器中直接访问。\n\n# 2. English Answer\n\n## 2.1 Concept\n1. Lazy stored property (lazy var) is initialized on first access.\n2. Only for var, not let.\n3. Used for expensive, external, or self-dependent resources.\n\n## 2.2 Why use it?\n- Improves performance, saves memory.\n- Avoids unnecessary initialization, faster startup.\n\n## 2.3 Code Example\n```swift\nclass DataManager {\n    lazy var data: [String] = self.loadData()\n    func loadData() -> [String] {\n        print(\"Loading data\")\n        return [\"A\", \"B\", \"C\"]\n    }\n}\nlet manager = DataManager()\n// data not initialized yet\nlet d = manager.data // initialized on first access\n```\n\n## 2.4 Business/User Value\n- Optimizes resource allocation, better UX.\n- Good for big data, images, network, etc.\n\n## 2.5 Common Confusion\n- lazy can't be used with let.\n- lazy property can't be accessed in initializer.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5o00175ek75j84fbjk","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ol>\n<li>延迟存储属性（lazy var）在第一次访问时才初始化。</li>\n<li>只能用于 var，不能用于 let。</li>\n<li>常用于依赖外部资源、初始化开销大、或需要 self 的场景。</li>\n</ol>\n<h2 id=\"1-2-为什么要用？\"><a href=\"#1-2-为什么要用？\" class=\"headerlink\" title=\"1.2 为什么要用？\"></a>1.2 为什么要用？</h2><ul>\n<li>提升性能，节省内存。</li>\n<li>避免不必要的初始化，提升启动速度。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;加载数据&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> manager <span class=\"operator\">=</span> <span class=\"type\">DataManager</span>()</span><br><span class=\"line\"><span class=\"comment\">// 此时 data 未初始化</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> d <span class=\"operator\">=</span> manager.data <span class=\"comment\">// 第一次访问，才初始化</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>优化资源分配，提升用户体验。</li>\n<li>适合大数据、图片、网络等场景。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>lazy 不能用于 let。</li>\n<li>lazy 属性不能在构造器中直接访问。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ol>\n<li>Lazy stored property (lazy var) is initialized on first access.</li>\n<li>Only for var, not let.</li>\n<li>Used for expensive, external, or self-dependent resources.</li>\n</ol>\n<h2 id=\"2-2-Why-use-it\"><a href=\"#2-2-Why-use-it\" class=\"headerlink\" title=\"2.2 Why use it?\"></a>2.2 Why use it?</h2><ul>\n<li>Improves performance, saves memory.</li>\n<li>Avoids unnecessary initialization, faster startup.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Loading data&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> manager <span class=\"operator\">=</span> <span class=\"type\">DataManager</span>()</span><br><span class=\"line\"><span class=\"comment\">// data not initialized yet</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> d <span class=\"operator\">=</span> manager.data <span class=\"comment\">// initialized on first access</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Optimizes resource allocation, better UX.</li>\n<li>Good for big data, images, network, etc.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>lazy can’t be used with let.</li>\n<li>lazy property can’t be accessed in initializer.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ol>\n<li>延迟存储属性（lazy var）在第一次访问时才初始化。</li>\n<li>只能用于 var，不能用于 let。</li>\n<li>常用于依赖外部资源、初始化开销大、或需要 self 的场景。</li>\n</ol>\n<h2 id=\"1-2-为什么要用？\"><a href=\"#1-2-为什么要用？\" class=\"headerlink\" title=\"1.2 为什么要用？\"></a>1.2 为什么要用？</h2><ul>\n<li>提升性能，节省内存。</li>\n<li>避免不必要的初始化，提升启动速度。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;加载数据&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> manager <span class=\"operator\">=</span> <span class=\"type\">DataManager</span>()</span><br><span class=\"line\"><span class=\"comment\">// 此时 data 未初始化</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> d <span class=\"operator\">=</span> manager.data <span class=\"comment\">// 第一次访问，才初始化</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>优化资源分配，提升用户体验。</li>\n<li>适合大数据、图片、网络等场景。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>lazy 不能用于 let。</li>\n<li>lazy 属性不能在构造器中直接访问。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ol>\n<li>Lazy stored property (lazy var) is initialized on first access.</li>\n<li>Only for var, not let.</li>\n<li>Used for expensive, external, or self-dependent resources.</li>\n</ol>\n<h2 id=\"2-2-Why-use-it\"><a href=\"#2-2-Why-use-it\" class=\"headerlink\" title=\"2.2 Why use it?\"></a>2.2 Why use it?</h2><ul>\n<li>Improves performance, saves memory.</li>\n<li>Avoids unnecessary initialization, faster startup.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DataManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">lazy</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>] <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.loadData()</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">loadData</span>() -&gt; [<span class=\"type\">String</span>] &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Loading data&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> manager <span class=\"operator\">=</span> <span class=\"type\">DataManager</span>()</span><br><span class=\"line\"><span class=\"comment\">// data not initialized yet</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> d <span class=\"operator\">=</span> manager.data <span class=\"comment\">// initialized on first access</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Optimizes resource allocation, better UX.</li>\n<li>Good for big data, images, network, etc.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>lazy can’t be used with let.</li>\n<li>lazy property can’t be accessed in initializer.</li>\n</ul>\n"},{"title":"iOS 性能优化核心点","date":"2025-07-16T16:00:00.000Z","path":"iOS/性能优化核心点.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 主要优化点\n- 启动速度、内存、卡顿、耗电、包体积、网络、渲染、线程。\n\n## 1.2 代码/方案示例\n- 懒加载、异步、图片压缩、表格复用、缓存、合并网络请求等。\n\n## 1.3 业务场景\n- 大型 App、复杂 UI、弱网、老设备。\n\n## 1.4 易混淆点\n- 优化需量化指标，避免过度优化。\n- 不同业务关注点不同。\n\n## 1.5 深挖追问\n- 如何定位性能瓶颈？Instruments、埋点、日志。\n- 优化与业务目标如何平衡？结合用户体验、成本。\n\n# 2. English Answer\n\n## 2.1 Key Optimization Points\n- Launch, memory, lag, battery, size, network, render, thread.\n\n## 2.2 Code/Solution Example\n- Lazy load, async, image compress, table reuse, cache, merge network, etc.\n\n## 2.3 Business Scenarios\n- Large app, complex UI, weak network, old device.\n\n## 2.4 Common Confusions\n- Need metrics, avoid over-optimize.\n- Focus varies by business.\n\n## 2.5 Deep Dive\n- How to locate bottleneck? Instruments, log, analytics.\n- Balance with business? User experience, cost.\n","source":"iOS/性能优化核心点.md","raw":"---\ntitle: iOS 性能优化核心点\ndate: 2025-07-17\npath: source/iOS/性能优化核心点.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 主要优化点\n- 启动速度、内存、卡顿、耗电、包体积、网络、渲染、线程。\n\n## 1.2 代码/方案示例\n- 懒加载、异步、图片压缩、表格复用、缓存、合并网络请求等。\n\n## 1.3 业务场景\n- 大型 App、复杂 UI、弱网、老设备。\n\n## 1.4 易混淆点\n- 优化需量化指标，避免过度优化。\n- 不同业务关注点不同。\n\n## 1.5 深挖追问\n- 如何定位性能瓶颈？Instruments、埋点、日志。\n- 优化与业务目标如何平衡？结合用户体验、成本。\n\n# 2. English Answer\n\n## 2.1 Key Optimization Points\n- Launch, memory, lag, battery, size, network, render, thread.\n\n## 2.2 Code/Solution Example\n- Lazy load, async, image compress, table reuse, cache, merge network, etc.\n\n## 2.3 Business Scenarios\n- Large app, complex UI, weak network, old device.\n\n## 2.4 Common Confusions\n- Need metrics, avoid over-optimize.\n- Focus varies by business.\n\n## 2.5 Deep Dive\n- How to locate bottleneck? Instruments, log, analytics.\n- Balance with business? User experience, cost.\n","updated":"2025-07-17T10:11:29.165Z","comments":1,"layout":"page","_id":"cmd78fh5o00185ek7fwb0he39","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-主要优化点\"><a href=\"#1-1-主要优化点\" class=\"headerlink\" title=\"1.1 主要优化点\"></a>1.1 主要优化点</h2><ul>\n<li>启动速度、内存、卡顿、耗电、包体积、网络、渲染、线程。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>懒加载、异步、图片压缩、表格复用、缓存、合并网络请求等。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、复杂 UI、弱网、老设备。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>优化需量化指标，避免过度优化。</li>\n<li>不同业务关注点不同。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何定位性能瓶颈？Instruments、埋点、日志。</li>\n<li>优化与业务目标如何平衡？结合用户体验、成本。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Optimization-Points\"><a href=\"#2-1-Key-Optimization-Points\" class=\"headerlink\" title=\"2.1 Key Optimization Points\"></a>2.1 Key Optimization Points</h2><ul>\n<li>Launch, memory, lag, battery, size, network, render, thread.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>Lazy load, async, image compress, table reuse, cache, merge network, etc.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, complex UI, weak network, old device.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Need metrics, avoid over-optimize.</li>\n<li>Focus varies by business.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to locate bottleneck? Instruments, log, analytics.</li>\n<li>Balance with business? User experience, cost.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-主要优化点\"><a href=\"#1-1-主要优化点\" class=\"headerlink\" title=\"1.1 主要优化点\"></a>1.1 主要优化点</h2><ul>\n<li>启动速度、内存、卡顿、耗电、包体积、网络、渲染、线程。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>懒加载、异步、图片压缩、表格复用、缓存、合并网络请求等。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、复杂 UI、弱网、老设备。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>优化需量化指标，避免过度优化。</li>\n<li>不同业务关注点不同。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何定位性能瓶颈？Instruments、埋点、日志。</li>\n<li>优化与业务目标如何平衡？结合用户体验、成本。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Optimization-Points\"><a href=\"#2-1-Key-Optimization-Points\" class=\"headerlink\" title=\"2.1 Key Optimization Points\"></a>2.1 Key Optimization Points</h2><ul>\n<li>Launch, memory, lag, battery, size, network, render, thread.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>Lazy load, async, image compress, table reuse, cache, merge network, etc.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, complex UI, weak network, old device.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Need metrics, avoid over-optimize.</li>\n<li>Focus varies by business.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to locate bottleneck? Instruments, log, analytics.</li>\n<li>Balance with business? User experience, cost.</li>\n</ul>\n"},{"title":"iOS 性能监控与优化工具","date":"2025-07-16T16:00:00.000Z","path":"iOS/性能监控与优化工具.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 常用工具\n- Instruments（Time Profiler、Leaks、Allocations、Core Animation）。\n- Xcode Organizer、Console、第三方 SDK（Bugly、Crashlytics）。\n\n## 1.2 代码/操作示例\n- Instruments 采集性能数据、分析内存泄漏。\n\n## 1.3 业务场景\n- 启动慢、卡顿、内存泄漏、崩溃定位。\n\n## 1.4 易混淆点\n- 工具需结合埋点、日志、A/B 测试。\n- 线上/线下监控手段不同。\n\n## 1.5 深挖追问\n- 如何自动化监控？SDK、埋点、报警。\n- 性能数据如何转化为优化方案？定期分析、量化目标。\n\n# 2. English Answer\n\n## 2.1 Common Tools\n- Instruments (Time Profiler, Leaks, Allocations, Core Animation).\n- Xcode Organizer, Console, 3rd SDK (Bugly, Crashlytics).\n\n## 2.2 Code/Operation Example\n- Instruments for perf data, memory leak.\n\n## 2.3 Business Scenarios\n- Slow launch, lag, leak, crash.\n\n## 2.4 Common Confusions\n- Combine with log, analytics, A/B.\n- Online/offline diff.\n\n## 2.5 Deep Dive\n- Auto monitor? SDK, log, alert.\n- Perf data to plan? Analyze, quantify.\n","source":"iOS/性能监控与优化工具.md","raw":"---\ntitle: iOS 性能监控与优化工具\ndate: 2025-07-17\npath: source/iOS/性能监控与优化工具.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 常用工具\n- Instruments（Time Profiler、Leaks、Allocations、Core Animation）。\n- Xcode Organizer、Console、第三方 SDK（Bugly、Crashlytics）。\n\n## 1.2 代码/操作示例\n- Instruments 采集性能数据、分析内存泄漏。\n\n## 1.3 业务场景\n- 启动慢、卡顿、内存泄漏、崩溃定位。\n\n## 1.4 易混淆点\n- 工具需结合埋点、日志、A/B 测试。\n- 线上/线下监控手段不同。\n\n## 1.5 深挖追问\n- 如何自动化监控？SDK、埋点、报警。\n- 性能数据如何转化为优化方案？定期分析、量化目标。\n\n# 2. English Answer\n\n## 2.1 Common Tools\n- Instruments (Time Profiler, Leaks, Allocations, Core Animation).\n- Xcode Organizer, Console, 3rd SDK (Bugly, Crashlytics).\n\n## 2.2 Code/Operation Example\n- Instruments for perf data, memory leak.\n\n## 2.3 Business Scenarios\n- Slow launch, lag, leak, crash.\n\n## 2.4 Common Confusions\n- Combine with log, analytics, A/B.\n- Online/offline diff.\n\n## 2.5 Deep Dive\n- Auto monitor? SDK, log, alert.\n- Perf data to plan? Analyze, quantify.\n","updated":"2025-07-17T10:11:29.231Z","comments":1,"layout":"page","_id":"cmd78fh5o00195ek76x9nh133","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常用工具\"><a href=\"#1-1-常用工具\" class=\"headerlink\" title=\"1.1 常用工具\"></a>1.1 常用工具</h2><ul>\n<li>Instruments（Time Profiler、Leaks、Allocations、Core Animation）。</li>\n<li>Xcode Organizer、Console、第三方 SDK（Bugly、Crashlytics）。</li>\n</ul>\n<h2 id=\"1-2-代码-操作示例\"><a href=\"#1-2-代码-操作示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;操作示例\"></a>1.2 代码&#x2F;操作示例</h2><ul>\n<li>Instruments 采集性能数据、分析内存泄漏。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>启动慢、卡顿、内存泄漏、崩溃定位。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>工具需结合埋点、日志、A&#x2F;B 测试。</li>\n<li>线上&#x2F;线下监控手段不同。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何自动化监控？SDK、埋点、报警。</li>\n<li>性能数据如何转化为优化方案？定期分析、量化目标。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Tools\"><a href=\"#2-1-Common-Tools\" class=\"headerlink\" title=\"2.1 Common Tools\"></a>2.1 Common Tools</h2><ul>\n<li>Instruments (Time Profiler, Leaks, Allocations, Core Animation).</li>\n<li>Xcode Organizer, Console, 3rd SDK (Bugly, Crashlytics).</li>\n</ul>\n<h2 id=\"2-2-Code-Operation-Example\"><a href=\"#2-2-Code-Operation-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Operation Example\"></a>2.2 Code&#x2F;Operation Example</h2><ul>\n<li>Instruments for perf data, memory leak.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Slow launch, lag, leak, crash.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Combine with log, analytics, A&#x2F;B.</li>\n<li>Online&#x2F;offline diff.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Auto monitor? SDK, log, alert.</li>\n<li>Perf data to plan? Analyze, quantify.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常用工具\"><a href=\"#1-1-常用工具\" class=\"headerlink\" title=\"1.1 常用工具\"></a>1.1 常用工具</h2><ul>\n<li>Instruments（Time Profiler、Leaks、Allocations、Core Animation）。</li>\n<li>Xcode Organizer、Console、第三方 SDK（Bugly、Crashlytics）。</li>\n</ul>\n<h2 id=\"1-2-代码-操作示例\"><a href=\"#1-2-代码-操作示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;操作示例\"></a>1.2 代码&#x2F;操作示例</h2><ul>\n<li>Instruments 采集性能数据、分析内存泄漏。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>启动慢、卡顿、内存泄漏、崩溃定位。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>工具需结合埋点、日志、A&#x2F;B 测试。</li>\n<li>线上&#x2F;线下监控手段不同。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何自动化监控？SDK、埋点、报警。</li>\n<li>性能数据如何转化为优化方案？定期分析、量化目标。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Tools\"><a href=\"#2-1-Common-Tools\" class=\"headerlink\" title=\"2.1 Common Tools\"></a>2.1 Common Tools</h2><ul>\n<li>Instruments (Time Profiler, Leaks, Allocations, Core Animation).</li>\n<li>Xcode Organizer, Console, 3rd SDK (Bugly, Crashlytics).</li>\n</ul>\n<h2 id=\"2-2-Code-Operation-Example\"><a href=\"#2-2-Code-Operation-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Operation Example\"></a>2.2 Code&#x2F;Operation Example</h2><ul>\n<li>Instruments for perf data, memory leak.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Slow launch, lag, leak, crash.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Combine with log, analytics, A&#x2F;B.</li>\n<li>Online&#x2F;offline diff.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Auto monitor? SDK, log, alert.</li>\n<li>Perf data to plan? Analyze, quantify.</li>\n</ul>\n"},{"title":"iOS 推送与本地通知机制","date":"2025-07-16T16:00:00.000Z","path":"iOS/推送与本地通知机制.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与流程\n- 远程推送：APNs，服务端推送到设备。\n- 本地通知：App 内定时/事件触发。\n\n## 1.2 代码示例\n```swift\n// 本地通知\nlet content = UNMutableNotificationContent()\ncontent.body = \"Hello\"\nlet req = UNNotificationRequest(identifier: \"id\", content: content, trigger: nil)\nUNUserNotificationCenter.current().add(req)\n```\n\n## 1.3 业务场景\n- 消息提醒、营销、定时任务。\n\n## 1.4 易混淆点\n- 推送需证书、token，通知权限需用户授权。\n- 后台/前台处理方式不同。\n\n## 1.5 深挖追问\n- 如何提升送达率？APNs 配置、重试、前后台策略。\n- 通知与隐私合规？需用户同意、可选关闭。\n\n# 2. English Answer\n\n## 2.1 Concept & Flow\n- Remote: APNs, server to device.\n- Local: in-app, timer/event.\n\n## 2.2 Code Example\n```swift\n// Local notification\nlet content = UNMutableNotificationContent()\ncontent.body = \"Hello\"\nlet req = UNNotificationRequest(identifier: \"id\", content: content, trigger: nil)\nUNUserNotificationCenter.current().add(req)\n```\n\n## 2.3 Business Scenarios\n- Message, marketing, timer.\n\n## 2.4 Common Confusions\n- Push: cert/token, permission.\n- Fore/background handle diff.\n\n## 2.5 Deep Dive\n- Improve delivery? APNs config, retry, fg/bg.\n- Privacy? User consent, opt-out.\n","source":"iOS/推送与本地通知机制.md","raw":"---\ntitle: iOS 推送与本地通知机制\ndate: 2025-07-17\npath: source/iOS/推送与本地通知机制.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与流程\n- 远程推送：APNs，服务端推送到设备。\n- 本地通知：App 内定时/事件触发。\n\n## 1.2 代码示例\n```swift\n// 本地通知\nlet content = UNMutableNotificationContent()\ncontent.body = \"Hello\"\nlet req = UNNotificationRequest(identifier: \"id\", content: content, trigger: nil)\nUNUserNotificationCenter.current().add(req)\n```\n\n## 1.3 业务场景\n- 消息提醒、营销、定时任务。\n\n## 1.4 易混淆点\n- 推送需证书、token，通知权限需用户授权。\n- 后台/前台处理方式不同。\n\n## 1.5 深挖追问\n- 如何提升送达率？APNs 配置、重试、前后台策略。\n- 通知与隐私合规？需用户同意、可选关闭。\n\n# 2. English Answer\n\n## 2.1 Concept & Flow\n- Remote: APNs, server to device.\n- Local: in-app, timer/event.\n\n## 2.2 Code Example\n```swift\n// Local notification\nlet content = UNMutableNotificationContent()\ncontent.body = \"Hello\"\nlet req = UNNotificationRequest(identifier: \"id\", content: content, trigger: nil)\nUNUserNotificationCenter.current().add(req)\n```\n\n## 2.3 Business Scenarios\n- Message, marketing, timer.\n\n## 2.4 Common Confusions\n- Push: cert/token, permission.\n- Fore/background handle diff.\n\n## 2.5 Deep Dive\n- Improve delivery? APNs config, retry, fg/bg.\n- Privacy? User consent, opt-out.\n","updated":"2025-07-17T10:11:29.216Z","comments":1,"layout":"page","_id":"cmd78fh5o001a5ek77ph1dshj","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与流程\"><a href=\"#1-1-概念与流程\" class=\"headerlink\" title=\"1.1 概念与流程\"></a>1.1 概念与流程</h2><ul>\n<li>远程推送：APNs，服务端推送到设备。</li>\n<li>本地通知：App 内定时&#x2F;事件触发。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 本地通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content <span class=\"operator\">=</span> <span class=\"type\">UNMutableNotificationContent</span>()</span><br><span class=\"line\">content.body <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> req <span class=\"operator\">=</span> <span class=\"type\">UNNotificationRequest</span>(identifier: <span class=\"string\">&quot;id&quot;</span>, content: content, trigger: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(req)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>消息提醒、营销、定时任务。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>推送需证书、token，通知权限需用户授权。</li>\n<li>后台&#x2F;前台处理方式不同。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升送达率？APNs 配置、重试、前后台策略。</li>\n<li>通知与隐私合规？需用户同意、可选关闭。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Flow\"><a href=\"#2-1-Concept-Flow\" class=\"headerlink\" title=\"2.1 Concept &amp; Flow\"></a>2.1 Concept &amp; Flow</h2><ul>\n<li>Remote: APNs, server to device.</li>\n<li>Local: in-app, timer&#x2F;event.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Local notification</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content <span class=\"operator\">=</span> <span class=\"type\">UNMutableNotificationContent</span>()</span><br><span class=\"line\">content.body <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> req <span class=\"operator\">=</span> <span class=\"type\">UNNotificationRequest</span>(identifier: <span class=\"string\">&quot;id&quot;</span>, content: content, trigger: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(req)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Message, marketing, timer.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Push: cert&#x2F;token, permission.</li>\n<li>Fore&#x2F;background handle diff.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Improve delivery? APNs config, retry, fg&#x2F;bg.</li>\n<li>Privacy? User consent, opt-out.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与流程\"><a href=\"#1-1-概念与流程\" class=\"headerlink\" title=\"1.1 概念与流程\"></a>1.1 概念与流程</h2><ul>\n<li>远程推送：APNs，服务端推送到设备。</li>\n<li>本地通知：App 内定时&#x2F;事件触发。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 本地通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content <span class=\"operator\">=</span> <span class=\"type\">UNMutableNotificationContent</span>()</span><br><span class=\"line\">content.body <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> req <span class=\"operator\">=</span> <span class=\"type\">UNNotificationRequest</span>(identifier: <span class=\"string\">&quot;id&quot;</span>, content: content, trigger: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(req)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>消息提醒、营销、定时任务。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>推送需证书、token，通知权限需用户授权。</li>\n<li>后台&#x2F;前台处理方式不同。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升送达率？APNs 配置、重试、前后台策略。</li>\n<li>通知与隐私合规？需用户同意、可选关闭。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Flow\"><a href=\"#2-1-Concept-Flow\" class=\"headerlink\" title=\"2.1 Concept &amp; Flow\"></a>2.1 Concept &amp; Flow</h2><ul>\n<li>Remote: APNs, server to device.</li>\n<li>Local: in-app, timer&#x2F;event.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Local notification</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> content <span class=\"operator\">=</span> <span class=\"type\">UNMutableNotificationContent</span>()</span><br><span class=\"line\">content.body <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> req <span class=\"operator\">=</span> <span class=\"type\">UNNotificationRequest</span>(identifier: <span class=\"string\">&quot;id&quot;</span>, content: content, trigger: <span class=\"literal\">nil</span>)</span><br><span class=\"line\"><span class=\"type\">UNUserNotificationCenter</span>.current().add(req)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Message, marketing, timer.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Push: cert&#x2F;token, permission.</li>\n<li>Fore&#x2F;background handle diff.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Improve delivery? APNs config, retry, fg&#x2F;bg.</li>\n<li>Privacy? User consent, opt-out.</li>\n</ul>\n"},{"title":"数组与字典下标区别","date":"2025-07-16T16:00:00.000Z","path":"iOS/数组字典下标区别.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与本质\n- 数组下标：基于 Int 索引，越界会崩溃。\n- 字典下标：基于 Key，查不到返回 nil，不会崩溃。\n\n## 1.2 代码示例\n```swift\nlet arr = [1,2,3]\nlet v1 = arr[1] // 2\n// let v2 = arr[10] // ❌ 崩溃\n\nlet dict = [\"a\":1]\nlet v3 = dict[\"a\"] // Optional(1)\nlet v4 = dict[\"b\"] // nil\n```\n\n## 1.3 业务场景\n- 数组适合有序集合，字典适合键值映射。\n\n## 1.4 易混淆点\n- 字典下标返回可选类型，需安全解包。\n- 数组下标越界直接崩溃，需判断 count。\n\n## 1.5 深挖追问\n- 为什么设计成这样？数组追求性能，字典追求安全。\n\n# 2. English Answer\n\n## 2.1 Concept & Essence\n- Array subscript: Int index, out-of-bounds crash.\n- Dictionary subscript: Key, returns nil if not found.\n\n## 2.2 Code Example\n```swift\nlet arr = [1,2,3]\nlet v1 = arr[1] // 2\n// let v2 = arr[10] // ❌ crash\n\nlet dict = [\"a\":1]\nlet v3 = dict[\"a\"] // Optional(1)\nlet v4 = dict[\"b\"] // nil\n```\n\n## 2.3 Business Scenarios\n- Array: ordered collection; Dictionary: key-value mapping.\n\n## 2.4 Common Confusions\n- Dictionary subscript returns optional, need unwrapping.\n- Array out-of-bounds crashes, check count.\n\n## 2.5 Deep Dive\n- Why design this way? Array for performance, dictionary for safety.\n","source":"iOS/数组字典下标区别.md","raw":"---\ntitle: 数组与字典下标区别\ndate: 2025-07-17\npath: source/iOS/数组字典下标区别.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与本质\n- 数组下标：基于 Int 索引，越界会崩溃。\n- 字典下标：基于 Key，查不到返回 nil，不会崩溃。\n\n## 1.2 代码示例\n```swift\nlet arr = [1,2,3]\nlet v1 = arr[1] // 2\n// let v2 = arr[10] // ❌ 崩溃\n\nlet dict = [\"a\":1]\nlet v3 = dict[\"a\"] // Optional(1)\nlet v4 = dict[\"b\"] // nil\n```\n\n## 1.3 业务场景\n- 数组适合有序集合，字典适合键值映射。\n\n## 1.4 易混淆点\n- 字典下标返回可选类型，需安全解包。\n- 数组下标越界直接崩溃，需判断 count。\n\n## 1.5 深挖追问\n- 为什么设计成这样？数组追求性能，字典追求安全。\n\n# 2. English Answer\n\n## 2.1 Concept & Essence\n- Array subscript: Int index, out-of-bounds crash.\n- Dictionary subscript: Key, returns nil if not found.\n\n## 2.2 Code Example\n```swift\nlet arr = [1,2,3]\nlet v1 = arr[1] // 2\n// let v2 = arr[10] // ❌ crash\n\nlet dict = [\"a\":1]\nlet v3 = dict[\"a\"] // Optional(1)\nlet v4 = dict[\"b\"] // nil\n```\n\n## 2.3 Business Scenarios\n- Array: ordered collection; Dictionary: key-value mapping.\n\n## 2.4 Common Confusions\n- Dictionary subscript returns optional, need unwrapping.\n- Array out-of-bounds crashes, check count.\n\n## 2.5 Deep Dive\n- Why design this way? Array for performance, dictionary for safety.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5o001b5ek74tf4g4hi","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与本质\"><a href=\"#1-1-概念与本质\" class=\"headerlink\" title=\"1.1 概念与本质\"></a>1.1 概念与本质</h2><ul>\n<li>数组下标：基于 Int 索引，越界会崩溃。</li>\n<li>字典下标：基于 Key，查不到返回 nil，不会崩溃。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 <span class=\"operator\">=</span> arr[<span class=\"number\">1</span>] <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// let v2 = arr[10] // ❌ 崩溃</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dict <span class=\"operator\">=</span> [<span class=\"string\">&quot;a&quot;</span>:<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v3 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;a&quot;</span>] <span class=\"comment\">// Optional(1)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> v4 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;b&quot;</span>] <span class=\"comment\">// nil</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>数组适合有序集合，字典适合键值映射。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>字典下标返回可选类型，需安全解包。</li>\n<li>数组下标越界直接崩溃，需判断 count。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>为什么设计成这样？数组追求性能，字典追求安全。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Essence\"><a href=\"#2-1-Concept-Essence\" class=\"headerlink\" title=\"2.1 Concept &amp; Essence\"></a>2.1 Concept &amp; Essence</h2><ul>\n<li>Array subscript: Int index, out-of-bounds crash.</li>\n<li>Dictionary subscript: Key, returns nil if not found.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 <span class=\"operator\">=</span> arr[<span class=\"number\">1</span>] <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// let v2 = arr[10] // ❌ crash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dict <span class=\"operator\">=</span> [<span class=\"string\">&quot;a&quot;</span>:<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v3 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;a&quot;</span>] <span class=\"comment\">// Optional(1)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> v4 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;b&quot;</span>] <span class=\"comment\">// nil</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Array: ordered collection; Dictionary: key-value mapping.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Dictionary subscript returns optional, need unwrapping.</li>\n<li>Array out-of-bounds crashes, check count.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Why design this way? Array for performance, dictionary for safety.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与本质\"><a href=\"#1-1-概念与本质\" class=\"headerlink\" title=\"1.1 概念与本质\"></a>1.1 概念与本质</h2><ul>\n<li>数组下标：基于 Int 索引，越界会崩溃。</li>\n<li>字典下标：基于 Key，查不到返回 nil，不会崩溃。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 <span class=\"operator\">=</span> arr[<span class=\"number\">1</span>] <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// let v2 = arr[10] // ❌ 崩溃</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dict <span class=\"operator\">=</span> [<span class=\"string\">&quot;a&quot;</span>:<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v3 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;a&quot;</span>] <span class=\"comment\">// Optional(1)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> v4 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;b&quot;</span>] <span class=\"comment\">// nil</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>数组适合有序集合，字典适合键值映射。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>字典下标返回可选类型，需安全解包。</li>\n<li>数组下标越界直接崩溃，需判断 count。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>为什么设计成这样？数组追求性能，字典追求安全。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Essence\"><a href=\"#2-1-Concept-Essence\" class=\"headerlink\" title=\"2.1 Concept &amp; Essence\"></a>2.1 Concept &amp; Essence</h2><ul>\n<li>Array subscript: Int index, out-of-bounds crash.</li>\n<li>Dictionary subscript: Key, returns nil if not found.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 <span class=\"operator\">=</span> arr[<span class=\"number\">1</span>] <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// let v2 = arr[10] // ❌ crash</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> dict <span class=\"operator\">=</span> [<span class=\"string\">&quot;a&quot;</span>:<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> v3 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;a&quot;</span>] <span class=\"comment\">// Optional(1)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> v4 <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;b&quot;</span>] <span class=\"comment\">// nil</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Array: ordered collection; Dictionary: key-value mapping.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Dictionary subscript returns optional, need unwrapping.</li>\n<li>Array out-of-bounds crashes, check count.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Why design this way? Array for performance, dictionary for safety.</li>\n</ul>\n"},{"title":"iOS 常见易混淆点辨析","date":"2025-07-16T16:00:00.000Z","path":"iOS/易混淆点辨析.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 常见易混淆点\n- weak/unowned 区别\n- open/public/internal\n- class/static\n- Optional/隐式解包\n- KVO/属性观察器\n- struct/class\n- lazy/延迟存储\n- Swift/OC\n\n## 1.2 业务视角\n- 选型需结合业务需求、性能、安全、可维护性。\n\n## 1.3 深挖追问\n- 如何系统梳理易混淆点？建议画表格、举例、结合源码。\n\n# 2. English Answer\n\n## 2.1 Common Confusions\n- weak/unowned\n- open/public/internal\n- class/static\n- Optional/Implicitly Unwrapped\n- KVO/Property Observer\n- struct/class\n- lazy/lazy stored\n- Swift/OC\n\n## 2.2 Business View\n- Choose by business, performance, safety, maintainability.\n\n## 2.3 Deep Dive\n- How to analyze? Table, example, source code.\n","source":"iOS/易混淆点辨析.md","raw":"---\ntitle: iOS 常见易混淆点辨析\ndate: 2025-07-17\npath: source/iOS/易混淆点辨析.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 常见易混淆点\n- weak/unowned 区别\n- open/public/internal\n- class/static\n- Optional/隐式解包\n- KVO/属性观察器\n- struct/class\n- lazy/延迟存储\n- Swift/OC\n\n## 1.2 业务视角\n- 选型需结合业务需求、性能、安全、可维护性。\n\n## 1.3 深挖追问\n- 如何系统梳理易混淆点？建议画表格、举例、结合源码。\n\n# 2. English Answer\n\n## 2.1 Common Confusions\n- weak/unowned\n- open/public/internal\n- class/static\n- Optional/Implicitly Unwrapped\n- KVO/Property Observer\n- struct/class\n- lazy/lazy stored\n- Swift/OC\n\n## 2.2 Business View\n- Choose by business, performance, safety, maintainability.\n\n## 2.3 Deep Dive\n- How to analyze? Table, example, source code.\n","updated":"2025-07-17T10:11:29.164Z","comments":1,"layout":"page","_id":"cmd78fh5p001c5ek72ttqfm52","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常见易混淆点\"><a href=\"#1-1-常见易混淆点\" class=\"headerlink\" title=\"1.1 常见易混淆点\"></a>1.1 常见易混淆点</h2><ul>\n<li>weak&#x2F;unowned 区别</li>\n<li>open&#x2F;public&#x2F;internal</li>\n<li>class&#x2F;static</li>\n<li>Optional&#x2F;隐式解包</li>\n<li>KVO&#x2F;属性观察器</li>\n<li>struct&#x2F;class</li>\n<li>lazy&#x2F;延迟存储</li>\n<li>Swift&#x2F;OC</li>\n</ul>\n<h2 id=\"1-2-业务视角\"><a href=\"#1-2-业务视角\" class=\"headerlink\" title=\"1.2 业务视角\"></a>1.2 业务视角</h2><ul>\n<li>选型需结合业务需求、性能、安全、可维护性。</li>\n</ul>\n<h2 id=\"1-3-深挖追问\"><a href=\"#1-3-深挖追问\" class=\"headerlink\" title=\"1.3 深挖追问\"></a>1.3 深挖追问</h2><ul>\n<li>如何系统梳理易混淆点？建议画表格、举例、结合源码。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Confusions\"><a href=\"#2-1-Common-Confusions\" class=\"headerlink\" title=\"2.1 Common Confusions\"></a>2.1 Common Confusions</h2><ul>\n<li>weak&#x2F;unowned</li>\n<li>open&#x2F;public&#x2F;internal</li>\n<li>class&#x2F;static</li>\n<li>Optional&#x2F;Implicitly Unwrapped</li>\n<li>KVO&#x2F;Property Observer</li>\n<li>struct&#x2F;class</li>\n<li>lazy&#x2F;lazy stored</li>\n<li>Swift&#x2F;OC</li>\n</ul>\n<h2 id=\"2-2-Business-View\"><a href=\"#2-2-Business-View\" class=\"headerlink\" title=\"2.2 Business View\"></a>2.2 Business View</h2><ul>\n<li>Choose by business, performance, safety, maintainability.</li>\n</ul>\n<h2 id=\"2-3-Deep-Dive\"><a href=\"#2-3-Deep-Dive\" class=\"headerlink\" title=\"2.3 Deep Dive\"></a>2.3 Deep Dive</h2><ul>\n<li>How to analyze? Table, example, source code.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常见易混淆点\"><a href=\"#1-1-常见易混淆点\" class=\"headerlink\" title=\"1.1 常见易混淆点\"></a>1.1 常见易混淆点</h2><ul>\n<li>weak&#x2F;unowned 区别</li>\n<li>open&#x2F;public&#x2F;internal</li>\n<li>class&#x2F;static</li>\n<li>Optional&#x2F;隐式解包</li>\n<li>KVO&#x2F;属性观察器</li>\n<li>struct&#x2F;class</li>\n<li>lazy&#x2F;延迟存储</li>\n<li>Swift&#x2F;OC</li>\n</ul>\n<h2 id=\"1-2-业务视角\"><a href=\"#1-2-业务视角\" class=\"headerlink\" title=\"1.2 业务视角\"></a>1.2 业务视角</h2><ul>\n<li>选型需结合业务需求、性能、安全、可维护性。</li>\n</ul>\n<h2 id=\"1-3-深挖追问\"><a href=\"#1-3-深挖追问\" class=\"headerlink\" title=\"1.3 深挖追问\"></a>1.3 深挖追问</h2><ul>\n<li>如何系统梳理易混淆点？建议画表格、举例、结合源码。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Confusions\"><a href=\"#2-1-Common-Confusions\" class=\"headerlink\" title=\"2.1 Common Confusions\"></a>2.1 Common Confusions</h2><ul>\n<li>weak&#x2F;unowned</li>\n<li>open&#x2F;public&#x2F;internal</li>\n<li>class&#x2F;static</li>\n<li>Optional&#x2F;Implicitly Unwrapped</li>\n<li>KVO&#x2F;Property Observer</li>\n<li>struct&#x2F;class</li>\n<li>lazy&#x2F;lazy stored</li>\n<li>Swift&#x2F;OC</li>\n</ul>\n<h2 id=\"2-2-Business-View\"><a href=\"#2-2-Business-View\" class=\"headerlink\" title=\"2.2 Business View\"></a>2.2 Business View</h2><ul>\n<li>Choose by business, performance, safety, maintainability.</li>\n</ul>\n<h2 id=\"2-3-Deep-Dive\"><a href=\"#2-3-Deep-Dive\" class=\"headerlink\" title=\"2.3 Deep Dive\"></a>2.3 Deep Dive</h2><ul>\n<li>How to analyze? Table, example, source code.</li>\n</ul>\n"},{"title":"构造方法","date":"2025-07-16T16:00:00.000Z","path":"iOS/构造方法.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 Swift 构造方法的分类\n1. 指定构造方法（Designated）：初始化所有属性，调用父类构造方法。\n2. 便利构造方法（Convenience）：简化初始化流程，必须调用本类其他构造方法。\n3. 可失败构造方法（Failable）：`init?`，初始化失败返回 nil。\n\n## 1.2 为什么要这样设计？\n- 保证对象完整初始化，提升类型安全。\n- 支持多种初始化方式，便于扩展和维护。\n\n## 1.3 实际代码示例\n```swift\nclass Car {\n    var brand: String\n    var price: Double\n    // 指定构造方法\n    init(brand: String, price: Double) {\n        self.brand = brand\n        self.price = price\n    }\n    // 便利构造方法\n    convenience init(brand: String) {\n        self.init(brand: brand, price: 0)\n    }\n    // 可失败构造方法\n    init?(dict: [String: Any]) {\n        guard let brand = dict[\"brand\"] as? String,\n              let price = dict[\"price\"] as? Double else { return nil }\n        self.brand = brand\n        self.price = price\n    }\n}\n```\n\n## 1.4 业务/用户价值\n- 保证数据一致性，提升产品健壮性。\n- 支持多样化初始化，提升开发效率。\n\n## 1.5 易混淆点\n- 便利构造方法不能直接初始化属性，必须调用本类其他构造方法。\n- 可失败构造方法需注意解包。\n\n# 2. English Answer\n\n## 2.1 Types of Initializers in Swift\n1. Designated: Initializes all properties, calls superclass initializer.\n2. Convenience: Simplifies init, must call another initializer in the same class.\n3. Failable: `init?`, returns nil if fails.\n\n## 2.2 Why this design?\n- Ensures complete initialization, improves type safety.\n- Supports multiple init patterns, easier to extend/maintain.\n\n## 2.3 Code Example\n```swift\nclass Car {\n    var brand: String\n    var price: Double\n    init(brand: String, price: Double) {\n        self.brand = brand\n        self.price = price\n    }\n    convenience init(brand: String) {\n        self.init(brand: brand, price: 0)\n    }\n    init?(dict: [String: Any]) {\n        guard let brand = dict[\"brand\"] as? String,\n              let price = dict[\"price\"] as? Double else { return nil }\n        self.brand = brand\n        self.price = price\n    }\n}\n```\n\n## 2.4 Business/User Value\n- Ensures data consistency, improves robustness.\n- Supports diverse init patterns, better dev efficiency.\n\n## 2.5 Common Confusion\n- Convenience initializers can't directly init properties, must call another initializer.\n- Failable initializers need unwrapping.\n","source":"iOS/构造方法.md","raw":"---\ntitle: 构造方法\ndate: 2025-07-17\npath: source/iOS/构造方法.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 Swift 构造方法的分类\n1. 指定构造方法（Designated）：初始化所有属性，调用父类构造方法。\n2. 便利构造方法（Convenience）：简化初始化流程，必须调用本类其他构造方法。\n3. 可失败构造方法（Failable）：`init?`，初始化失败返回 nil。\n\n## 1.2 为什么要这样设计？\n- 保证对象完整初始化，提升类型安全。\n- 支持多种初始化方式，便于扩展和维护。\n\n## 1.3 实际代码示例\n```swift\nclass Car {\n    var brand: String\n    var price: Double\n    // 指定构造方法\n    init(brand: String, price: Double) {\n        self.brand = brand\n        self.price = price\n    }\n    // 便利构造方法\n    convenience init(brand: String) {\n        self.init(brand: brand, price: 0)\n    }\n    // 可失败构造方法\n    init?(dict: [String: Any]) {\n        guard let brand = dict[\"brand\"] as? String,\n              let price = dict[\"price\"] as? Double else { return nil }\n        self.brand = brand\n        self.price = price\n    }\n}\n```\n\n## 1.4 业务/用户价值\n- 保证数据一致性，提升产品健壮性。\n- 支持多样化初始化，提升开发效率。\n\n## 1.5 易混淆点\n- 便利构造方法不能直接初始化属性，必须调用本类其他构造方法。\n- 可失败构造方法需注意解包。\n\n# 2. English Answer\n\n## 2.1 Types of Initializers in Swift\n1. Designated: Initializes all properties, calls superclass initializer.\n2. Convenience: Simplifies init, must call another initializer in the same class.\n3. Failable: `init?`, returns nil if fails.\n\n## 2.2 Why this design?\n- Ensures complete initialization, improves type safety.\n- Supports multiple init patterns, easier to extend/maintain.\n\n## 2.3 Code Example\n```swift\nclass Car {\n    var brand: String\n    var price: Double\n    init(brand: String, price: Double) {\n        self.brand = brand\n        self.price = price\n    }\n    convenience init(brand: String) {\n        self.init(brand: brand, price: 0)\n    }\n    init?(dict: [String: Any]) {\n        guard let brand = dict[\"brand\"] as? String,\n              let price = dict[\"price\"] as? Double else { return nil }\n        self.brand = brand\n        self.price = price\n    }\n}\n```\n\n## 2.4 Business/User Value\n- Ensures data consistency, improves robustness.\n- Supports diverse init patterns, better dev efficiency.\n\n## 2.5 Common Confusion\n- Convenience initializers can't directly init properties, must call another initializer.\n- Failable initializers need unwrapping.\n","updated":"2025-07-17T10:11:29.159Z","comments":1,"layout":"page","_id":"cmd78fh5p001d5ek76yof6wxz","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-Swift-构造方法的分类\"><a href=\"#1-1-Swift-构造方法的分类\" class=\"headerlink\" title=\"1.1 Swift 构造方法的分类\"></a>1.1 Swift 构造方法的分类</h2><ol>\n<li>指定构造方法（Designated）：初始化所有属性，调用父类构造方法。</li>\n<li>便利构造方法（Convenience）：简化初始化流程，必须调用本类其他构造方法。</li>\n<li>可失败构造方法（Failable）：<code>init?</code>，初始化失败返回 nil。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证对象完整初始化，提升类型安全。</li>\n<li>支持多种初始化方式，便于扩展和维护。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> brand: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"comment\">// 指定构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>, <span class=\"params\">price</span>: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 便利构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(brand: brand, price: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可失败构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> brand <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;brand&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> price <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;price&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Double</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>保证数据一致性，提升产品健壮性。</li>\n<li>支持多样化初始化，提升开发效率。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>便利构造方法不能直接初始化属性，必须调用本类其他构造方法。</li>\n<li>可失败构造方法需注意解包。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Types-of-Initializers-in-Swift\"><a href=\"#2-1-Types-of-Initializers-in-Swift\" class=\"headerlink\" title=\"2.1 Types of Initializers in Swift\"></a>2.1 Types of Initializers in Swift</h2><ol>\n<li>Designated: Initializes all properties, calls superclass initializer.</li>\n<li>Convenience: Simplifies init, must call another initializer in the same class.</li>\n<li>Failable: <code>init?</code>, returns nil if fails.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures complete initialization, improves type safety.</li>\n<li>Supports multiple init patterns, easier to extend&#x2F;maintain.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> brand: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>, <span class=\"params\">price</span>: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(brand: brand, price: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> brand <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;brand&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> price <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;price&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Double</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Ensures data consistency, improves robustness.</li>\n<li>Supports diverse init patterns, better dev efficiency.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Convenience initializers can’t directly init properties, must call another initializer.</li>\n<li>Failable initializers need unwrapping.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-Swift-构造方法的分类\"><a href=\"#1-1-Swift-构造方法的分类\" class=\"headerlink\" title=\"1.1 Swift 构造方法的分类\"></a>1.1 Swift 构造方法的分类</h2><ol>\n<li>指定构造方法（Designated）：初始化所有属性，调用父类构造方法。</li>\n<li>便利构造方法（Convenience）：简化初始化流程，必须调用本类其他构造方法。</li>\n<li>可失败构造方法（Failable）：<code>init?</code>，初始化失败返回 nil。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证对象完整初始化，提升类型安全。</li>\n<li>支持多种初始化方式，便于扩展和维护。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> brand: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"comment\">// 指定构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>, <span class=\"params\">price</span>: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 便利构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(brand: brand, price: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可失败构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> brand <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;brand&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> price <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;price&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Double</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>保证数据一致性，提升产品健壮性。</li>\n<li>支持多样化初始化，提升开发效率。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>便利构造方法不能直接初始化属性，必须调用本类其他构造方法。</li>\n<li>可失败构造方法需注意解包。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Types-of-Initializers-in-Swift\"><a href=\"#2-1-Types-of-Initializers-in-Swift\" class=\"headerlink\" title=\"2.1 Types of Initializers in Swift\"></a>2.1 Types of Initializers in Swift</h2><ol>\n<li>Designated: Initializes all properties, calls superclass initializer.</li>\n<li>Convenience: Simplifies init, must call another initializer in the same class.</li>\n<li>Failable: <code>init?</code>, returns nil if fails.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures complete initialization, improves type safety.</li>\n<li>Supports multiple init patterns, easier to extend&#x2F;maintain.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Car</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> brand: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>, <span class=\"params\">price</span>: <span class=\"type\">Double</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(<span class=\"params\">brand</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(brand: brand, price: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> brand <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;brand&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> price <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;price&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Double</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.brand <span class=\"operator\">=</span> brand</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.price <span class=\"operator\">=</span> price</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Ensures data consistency, improves robustness.</li>\n<li>Supports diverse init patterns, better dev efficiency.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Convenience initializers can’t directly init properties, must call another initializer.</li>\n<li>Failable initializers need unwrapping.</li>\n</ul>\n"},{"title":"iOS 架构设计核心要点","date":"2025-07-16T16:00:00.000Z","path":"iOS/架构设计核心要点.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 常见架构\n- MVC、MVP、MVVM、VIPER、Clean Swift 等。\n\n## 1.2 代码/结构示例\n- MVC：View-Controller-Model 分层。\n- MVVM：View-ViewModel-Model，数据绑定。\n\n## 1.3 业务场景\n- 大型项目、多人协作、可维护性、可测试性。\n\n## 1.4 易混淆点\n- MVC 控制器易臃肿，MVVM 需数据绑定。\n- 架构选型需结合团队、业务、技术栈。\n\n## 1.5 深挖追问\n- 如何落地架构？结合模块化、解耦、自动化测试。\n- 架构升级的业务驱动力？复杂度、效率、扩展性。\n\n# 2. English Answer\n\n## 2.1 Common Architectures\n- MVC, MVP, MVVM, VIPER, Clean Swift, etc.\n\n## 2.2 Code/Structure Example\n- MVC: View-Controller-Model.\n- MVVM: View-ViewModel-Model, data binding.\n\n## 2.3 Business Scenarios\n- Large project, team, maintainability, testability.\n\n## 2.4 Common Confusions\n- MVC: fat controller; MVVM: data binding.\n- Choose by team, business, tech stack.\n\n## 2.5 Deep Dive\n- How to implement? Modular, decouple, test.\n- Why upgrade? Complexity, efficiency, scalability.\n","source":"iOS/架构设计核心要点.md","raw":"---\ntitle: iOS 架构设计核心要点\ndate: 2025-07-17\npath: source/iOS/架构设计核心要点.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 常见架构\n- MVC、MVP、MVVM、VIPER、Clean Swift 等。\n\n## 1.2 代码/结构示例\n- MVC：View-Controller-Model 分层。\n- MVVM：View-ViewModel-Model，数据绑定。\n\n## 1.3 业务场景\n- 大型项目、多人协作、可维护性、可测试性。\n\n## 1.4 易混淆点\n- MVC 控制器易臃肿，MVVM 需数据绑定。\n- 架构选型需结合团队、业务、技术栈。\n\n## 1.5 深挖追问\n- 如何落地架构？结合模块化、解耦、自动化测试。\n- 架构升级的业务驱动力？复杂度、效率、扩展性。\n\n# 2. English Answer\n\n## 2.1 Common Architectures\n- MVC, MVP, MVVM, VIPER, Clean Swift, etc.\n\n## 2.2 Code/Structure Example\n- MVC: View-Controller-Model.\n- MVVM: View-ViewModel-Model, data binding.\n\n## 2.3 Business Scenarios\n- Large project, team, maintainability, testability.\n\n## 2.4 Common Confusions\n- MVC: fat controller; MVVM: data binding.\n- Choose by team, business, tech stack.\n\n## 2.5 Deep Dive\n- How to implement? Modular, decouple, test.\n- Why upgrade? Complexity, efficiency, scalability.\n","updated":"2025-07-17T10:11:29.165Z","comments":1,"layout":"page","_id":"cmd78fh5p001e5ek7fyai8jer","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常见架构\"><a href=\"#1-1-常见架构\" class=\"headerlink\" title=\"1.1 常见架构\"></a>1.1 常见架构</h2><ul>\n<li>MVC、MVP、MVVM、VIPER、Clean Swift 等。</li>\n</ul>\n<h2 id=\"1-2-代码-结构示例\"><a href=\"#1-2-代码-结构示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;结构示例\"></a>1.2 代码&#x2F;结构示例</h2><ul>\n<li>MVC：View-Controller-Model 分层。</li>\n<li>MVVM：View-ViewModel-Model，数据绑定。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型项目、多人协作、可维护性、可测试性。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>MVC 控制器易臃肿，MVVM 需数据绑定。</li>\n<li>架构选型需结合团队、业务、技术栈。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何落地架构？结合模块化、解耦、自动化测试。</li>\n<li>架构升级的业务驱动力？复杂度、效率、扩展性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Architectures\"><a href=\"#2-1-Common-Architectures\" class=\"headerlink\" title=\"2.1 Common Architectures\"></a>2.1 Common Architectures</h2><ul>\n<li>MVC, MVP, MVVM, VIPER, Clean Swift, etc.</li>\n</ul>\n<h2 id=\"2-2-Code-Structure-Example\"><a href=\"#2-2-Code-Structure-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Structure Example\"></a>2.2 Code&#x2F;Structure Example</h2><ul>\n<li>MVC: View-Controller-Model.</li>\n<li>MVVM: View-ViewModel-Model, data binding.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large project, team, maintainability, testability.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>MVC: fat controller; MVVM: data binding.</li>\n<li>Choose by team, business, tech stack.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to implement? Modular, decouple, test.</li>\n<li>Why upgrade? Complexity, efficiency, scalability.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常见架构\"><a href=\"#1-1-常见架构\" class=\"headerlink\" title=\"1.1 常见架构\"></a>1.1 常见架构</h2><ul>\n<li>MVC、MVP、MVVM、VIPER、Clean Swift 等。</li>\n</ul>\n<h2 id=\"1-2-代码-结构示例\"><a href=\"#1-2-代码-结构示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;结构示例\"></a>1.2 代码&#x2F;结构示例</h2><ul>\n<li>MVC：View-Controller-Model 分层。</li>\n<li>MVVM：View-ViewModel-Model，数据绑定。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型项目、多人协作、可维护性、可测试性。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>MVC 控制器易臃肿，MVVM 需数据绑定。</li>\n<li>架构选型需结合团队、业务、技术栈。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何落地架构？结合模块化、解耦、自动化测试。</li>\n<li>架构升级的业务驱动力？复杂度、效率、扩展性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Architectures\"><a href=\"#2-1-Common-Architectures\" class=\"headerlink\" title=\"2.1 Common Architectures\"></a>2.1 Common Architectures</h2><ul>\n<li>MVC, MVP, MVVM, VIPER, Clean Swift, etc.</li>\n</ul>\n<h2 id=\"2-2-Code-Structure-Example\"><a href=\"#2-2-Code-Structure-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Structure Example\"></a>2.2 Code&#x2F;Structure Example</h2><ul>\n<li>MVC: View-Controller-Model.</li>\n<li>MVVM: View-ViewModel-Model, data binding.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large project, team, maintainability, testability.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>MVC: fat controller; MVVM: data binding.</li>\n<li>Choose by team, business, tech stack.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to implement? Modular, decouple, test.</li>\n<li>Why upgrade? Complexity, efficiency, scalability.</li>\n</ul>\n"},{"title":"iOS App 架构演进与技术选型","date":"2025-07-16T16:00:00.000Z","path":"iOS/架构演进与技术选型.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 架构演进\n- 单体 → 组件化 → 服务化 → 云原生。\n- 技术选型：Swift/OC、SPM/CocoaPods、MVVM/VIPER、SwiftUI/Flutter。\n\n## 1.2 方案/案例\n- 组件化拆分、协议解耦、跨端方案。\n\n## 1.3 业务场景\n- 快速迭代、团队扩张、跨平台需求。\n\n## 1.4 易混淆点\n- 架构升级需兼顾历史包袱。\n- 技术选型需结合团队能力、业务目标。\n\n## 1.5 深挖追问\n- 如何平滑迁移？分阶段、双轨制、自动化测试。\n- 技术选型失误如何补救？灰度、回滚、培训。\n\n# 2. English Answer\n\n## 2.1 Architecture Evolution\n- Monolith → component → service → cloud native.\n- Tech: Swift/OC, SPM/Pods, MVVM/VIPER, SwiftUI/Flutter.\n\n## 2.2 Solution/Case\n- Component split, protocol, cross-platform.\n\n## 2.3 Business Scenarios\n- Fast iteration, team, cross-platform.\n\n## 2.4 Common Confusions\n- Upgrade: legacy burden.\n- Tech: team, business.\n\n## 2.5 Deep Dive\n- Migrate? Stage, dual, auto test.\n- Wrong tech? Gray, rollback, train.\n","source":"iOS/架构演进与技术选型.md","raw":"---\ntitle: iOS App 架构演进与技术选型\ndate: 2025-07-17\npath: source/iOS/架构演进与技术选型.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 架构演进\n- 单体 → 组件化 → 服务化 → 云原生。\n- 技术选型：Swift/OC、SPM/CocoaPods、MVVM/VIPER、SwiftUI/Flutter。\n\n## 1.2 方案/案例\n- 组件化拆分、协议解耦、跨端方案。\n\n## 1.3 业务场景\n- 快速迭代、团队扩张、跨平台需求。\n\n## 1.4 易混淆点\n- 架构升级需兼顾历史包袱。\n- 技术选型需结合团队能力、业务目标。\n\n## 1.5 深挖追问\n- 如何平滑迁移？分阶段、双轨制、自动化测试。\n- 技术选型失误如何补救？灰度、回滚、培训。\n\n# 2. English Answer\n\n## 2.1 Architecture Evolution\n- Monolith → component → service → cloud native.\n- Tech: Swift/OC, SPM/Pods, MVVM/VIPER, SwiftUI/Flutter.\n\n## 2.2 Solution/Case\n- Component split, protocol, cross-platform.\n\n## 2.3 Business Scenarios\n- Fast iteration, team, cross-platform.\n\n## 2.4 Common Confusions\n- Upgrade: legacy burden.\n- Tech: team, business.\n\n## 2.5 Deep Dive\n- Migrate? Stage, dual, auto test.\n- Wrong tech? Gray, rollback, train.\n","updated":"2025-07-17T10:11:29.231Z","comments":1,"layout":"page","_id":"cmd78fh5p001f5ek7dmka4noy","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-架构演进\"><a href=\"#1-1-架构演进\" class=\"headerlink\" title=\"1.1 架构演进\"></a>1.1 架构演进</h2><ul>\n<li>单体 → 组件化 → 服务化 → 云原生。</li>\n<li>技术选型：Swift&#x2F;OC、SPM&#x2F;CocoaPods、MVVM&#x2F;VIPER、SwiftUI&#x2F;Flutter。</li>\n</ul>\n<h2 id=\"1-2-方案-案例\"><a href=\"#1-2-方案-案例\" class=\"headerlink\" title=\"1.2 方案&#x2F;案例\"></a>1.2 方案&#x2F;案例</h2><ul>\n<li>组件化拆分、协议解耦、跨端方案。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>快速迭代、团队扩张、跨平台需求。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>架构升级需兼顾历史包袱。</li>\n<li>技术选型需结合团队能力、业务目标。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何平滑迁移？分阶段、双轨制、自动化测试。</li>\n<li>技术选型失误如何补救？灰度、回滚、培训。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Architecture-Evolution\"><a href=\"#2-1-Architecture-Evolution\" class=\"headerlink\" title=\"2.1 Architecture Evolution\"></a>2.1 Architecture Evolution</h2><ul>\n<li>Monolith → component → service → cloud native.</li>\n<li>Tech: Swift&#x2F;OC, SPM&#x2F;Pods, MVVM&#x2F;VIPER, SwiftUI&#x2F;Flutter.</li>\n</ul>\n<h2 id=\"2-2-Solution-Case\"><a href=\"#2-2-Solution-Case\" class=\"headerlink\" title=\"2.2 Solution&#x2F;Case\"></a>2.2 Solution&#x2F;Case</h2><ul>\n<li>Component split, protocol, cross-platform.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Fast iteration, team, cross-platform.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Upgrade: legacy burden.</li>\n<li>Tech: team, business.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Migrate? Stage, dual, auto test.</li>\n<li>Wrong tech? Gray, rollback, train.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-架构演进\"><a href=\"#1-1-架构演进\" class=\"headerlink\" title=\"1.1 架构演进\"></a>1.1 架构演进</h2><ul>\n<li>单体 → 组件化 → 服务化 → 云原生。</li>\n<li>技术选型：Swift&#x2F;OC、SPM&#x2F;CocoaPods、MVVM&#x2F;VIPER、SwiftUI&#x2F;Flutter。</li>\n</ul>\n<h2 id=\"1-2-方案-案例\"><a href=\"#1-2-方案-案例\" class=\"headerlink\" title=\"1.2 方案&#x2F;案例\"></a>1.2 方案&#x2F;案例</h2><ul>\n<li>组件化拆分、协议解耦、跨端方案。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>快速迭代、团队扩张、跨平台需求。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>架构升级需兼顾历史包袱。</li>\n<li>技术选型需结合团队能力、业务目标。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何平滑迁移？分阶段、双轨制、自动化测试。</li>\n<li>技术选型失误如何补救？灰度、回滚、培训。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Architecture-Evolution\"><a href=\"#2-1-Architecture-Evolution\" class=\"headerlink\" title=\"2.1 Architecture Evolution\"></a>2.1 Architecture Evolution</h2><ul>\n<li>Monolith → component → service → cloud native.</li>\n<li>Tech: Swift&#x2F;OC, SPM&#x2F;Pods, MVVM&#x2F;VIPER, SwiftUI&#x2F;Flutter.</li>\n</ul>\n<h2 id=\"2-2-Solution-Case\"><a href=\"#2-2-Solution-Case\" class=\"headerlink\" title=\"2.2 Solution&#x2F;Case\"></a>2.2 Solution&#x2F;Case</h2><ul>\n<li>Component split, protocol, cross-platform.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Fast iteration, team, cross-platform.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Upgrade: legacy burden.</li>\n<li>Tech: team, business.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Migrate? Stage, dual, auto test.</li>\n<li>Wrong tech? Gray, rollback, train.</li>\n</ul>\n"},{"title":"模式匹配（Pattern Matching）","date":"2025-07-16T16:00:00.000Z","path":"iOS/模式匹配.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与应用\n模式匹配是 Swift 强大的语法特性，常用于 switch、if case、guard case、for case 等，支持对枚举、元组、Optionals、区间等结构的解构和条件判断。\n\n## 1.2 代码示例\n```swift\nlet point = (1, 0)\nswitch point {\ncase (0, 0): print(\"原点\")\ncase (_, 0): print(\"X轴上\")\ncase (0, _): print(\"Y轴上\")\ncase (let x, let y): print(\"其他: \\(x),\\(y)\")\n}\n```\n\n## 1.3 业务场景\n- 复杂数据结构解包、网络响应解析、状态机等。\n\n## 1.4 易混淆点\n- if case/guard case 适合单一条件判断。\n- 可与 where 结合做更复杂判断。\n\n## 1.5 深挖追问\n- 模式匹配与类型检查、解包的关系？本质是语法糖，提升代码可读性。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nPattern matching is a powerful Swift feature, used in switch, if case, guard case, for case, supporting destructuring and conditionals for enums, tuples, optionals, ranges, etc.\n\n## 2.2 Code Example\n```swift\nlet point = (1, 0)\nswitch point {\ncase (0, 0): print(\"Origin\")\ncase (_, 0): print(\"On X axis\")\ncase (0, _): print(\"On Y axis\")\ncase (let x, let y): print(\"Other: \\(x),\\(y)\")\n}\n```\n\n## 2.3 Business Scenarios\n- Unpacking complex data, parsing responses, state machines, etc.\n\n## 2.4 Common Confusions\n- if case/guard case for single condition.\n- Combine with where for complex logic.\n\n## 2.5 Deep Dive\n- Relation to type check/unwrapping? Syntactic sugar for readability.\n","source":"iOS/模式匹配.md","raw":"---\ntitle: 模式匹配（Pattern Matching）\ndate: 2025-07-17\npath: source/iOS/模式匹配.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与应用\n模式匹配是 Swift 强大的语法特性，常用于 switch、if case、guard case、for case 等，支持对枚举、元组、Optionals、区间等结构的解构和条件判断。\n\n## 1.2 代码示例\n```swift\nlet point = (1, 0)\nswitch point {\ncase (0, 0): print(\"原点\")\ncase (_, 0): print(\"X轴上\")\ncase (0, _): print(\"Y轴上\")\ncase (let x, let y): print(\"其他: \\(x),\\(y)\")\n}\n```\n\n## 1.3 业务场景\n- 复杂数据结构解包、网络响应解析、状态机等。\n\n## 1.4 易混淆点\n- if case/guard case 适合单一条件判断。\n- 可与 where 结合做更复杂判断。\n\n## 1.5 深挖追问\n- 模式匹配与类型检查、解包的关系？本质是语法糖，提升代码可读性。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nPattern matching is a powerful Swift feature, used in switch, if case, guard case, for case, supporting destructuring and conditionals for enums, tuples, optionals, ranges, etc.\n\n## 2.2 Code Example\n```swift\nlet point = (1, 0)\nswitch point {\ncase (0, 0): print(\"Origin\")\ncase (_, 0): print(\"On X axis\")\ncase (0, _): print(\"On Y axis\")\ncase (let x, let y): print(\"Other: \\(x),\\(y)\")\n}\n```\n\n## 2.3 Business Scenarios\n- Unpacking complex data, parsing responses, state machines, etc.\n\n## 2.4 Common Confusions\n- if case/guard case for single condition.\n- Combine with where for complex logic.\n\n## 2.5 Deep Dive\n- Relation to type check/unwrapping? Syntactic sugar for readability.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5p001g5ek72c3628cn","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与应用\"><a href=\"#1-1-概念与应用\" class=\"headerlink\" title=\"1.1 概念与应用\"></a>1.1 概念与应用</h2><p>模式匹配是 Swift 强大的语法特性，常用于 switch、if case、guard case、for case 等，支持对枚举、元组、Optionals、区间等结构的解构和条件判断。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> point <span class=\"operator\">=</span> (<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">switch</span> point &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;原点&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;X轴上&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"keyword\">_</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Y轴上&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> x, <span class=\"keyword\">let</span> y): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;其他: <span class=\"subst\">\\(x)</span>,<span class=\"subst\">\\(y)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>复杂数据结构解包、网络响应解析、状态机等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>if case&#x2F;guard case 适合单一条件判断。</li>\n<li>可与 where 结合做更复杂判断。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>模式匹配与类型检查、解包的关系？本质是语法糖，提升代码可读性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Pattern matching is a powerful Swift feature, used in switch, if case, guard case, for case, supporting destructuring and conditionals for enums, tuples, optionals, ranges, etc.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> point <span class=\"operator\">=</span> (<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">switch</span> point &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Origin&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;On X axis&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"keyword\">_</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;On Y axis&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> x, <span class=\"keyword\">let</span> y): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Other: <span class=\"subst\">\\(x)</span>,<span class=\"subst\">\\(y)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Unpacking complex data, parsing responses, state machines, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>if case&#x2F;guard case for single condition.</li>\n<li>Combine with where for complex logic.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Relation to type check&#x2F;unwrapping? Syntactic sugar for readability.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与应用\"><a href=\"#1-1-概念与应用\" class=\"headerlink\" title=\"1.1 概念与应用\"></a>1.1 概念与应用</h2><p>模式匹配是 Swift 强大的语法特性，常用于 switch、if case、guard case、for case 等，支持对枚举、元组、Optionals、区间等结构的解构和条件判断。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> point <span class=\"operator\">=</span> (<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">switch</span> point &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;原点&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;X轴上&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"keyword\">_</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Y轴上&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> x, <span class=\"keyword\">let</span> y): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;其他: <span class=\"subst\">\\(x)</span>,<span class=\"subst\">\\(y)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>复杂数据结构解包、网络响应解析、状态机等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>if case&#x2F;guard case 适合单一条件判断。</li>\n<li>可与 where 结合做更复杂判断。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>模式匹配与类型检查、解包的关系？本质是语法糖，提升代码可读性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Pattern matching is a powerful Swift feature, used in switch, if case, guard case, for case, supporting destructuring and conditionals for enums, tuples, optionals, ranges, etc.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> point <span class=\"operator\">=</span> (<span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">switch</span> point &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Origin&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">_</span>, <span class=\"number\">0</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;On X axis&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"keyword\">_</span>): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;On Y axis&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> x, <span class=\"keyword\">let</span> y): <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Other: <span class=\"subst\">\\(x)</span>,<span class=\"subst\">\\(y)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Unpacking complex data, parsing responses, state machines, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>if case&#x2F;guard case for single condition.</li>\n<li>Combine with where for complex logic.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Relation to type check&#x2F;unwrapping? Syntactic sugar for readability.</li>\n</ul>\n"},{"title":"iOS 热修复与灰度发布","date":"2025-07-16T16:00:00.000Z","path":"iOS/热修复与灰度发布.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与方案\n- 热修复：无需发版，动态修复 bug（JSPatch、Weex、热更新 SDK）。\n- 灰度发布：分批上线，降低风险。\n\n## 1.2 代码/方案示例\n- JSPatch 脚本、A/B 测试、分组发布。\n\n## 1.3 业务场景\n- 紧急 bug 修复、功能试点、A/B 测试。\n\n## 1.4 易混淆点\n- 热修复受苹果审核限制。\n- 灰度需完善监控、回滚机制。\n\n## 1.5 深挖追问\n- 热修复安全风险？代码注入、越权。\n- 灰度发布如何自动化？结合 CI/CD、埋点。\n\n# 2. English Answer\n\n## 2.1 Concept & Solution\n- Hotfix: fix bug without release (JSPatch, Weex, hotfix SDK).\n- Gray release: batch rollout, lower risk.\n\n## 2.2 Code/Solution Example\n- JSPatch script, A/B test, group release.\n\n## 2.3 Business Scenarios\n- Urgent bug, pilot, A/B test.\n\n## 2.4 Common Confusions\n- Hotfix: App Store policy.\n- Gray: need monitor, rollback.\n\n## 2.5 Deep Dive\n- Hotfix risk? Code injection, privilege.\n- Gray automation? CI/CD, analytics.\n","source":"iOS/热修复与灰度发布.md","raw":"---\ntitle: iOS 热修复与灰度发布\ndate: 2025-07-17\npath: source/iOS/热修复与灰度发布.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与方案\n- 热修复：无需发版，动态修复 bug（JSPatch、Weex、热更新 SDK）。\n- 灰度发布：分批上线，降低风险。\n\n## 1.2 代码/方案示例\n- JSPatch 脚本、A/B 测试、分组发布。\n\n## 1.3 业务场景\n- 紧急 bug 修复、功能试点、A/B 测试。\n\n## 1.4 易混淆点\n- 热修复受苹果审核限制。\n- 灰度需完善监控、回滚机制。\n\n## 1.5 深挖追问\n- 热修复安全风险？代码注入、越权。\n- 灰度发布如何自动化？结合 CI/CD、埋点。\n\n# 2. English Answer\n\n## 2.1 Concept & Solution\n- Hotfix: fix bug without release (JSPatch, Weex, hotfix SDK).\n- Gray release: batch rollout, lower risk.\n\n## 2.2 Code/Solution Example\n- JSPatch script, A/B test, group release.\n\n## 2.3 Business Scenarios\n- Urgent bug, pilot, A/B test.\n\n## 2.4 Common Confusions\n- Hotfix: App Store policy.\n- Gray: need monitor, rollback.\n\n## 2.5 Deep Dive\n- Hotfix risk? Code injection, privilege.\n- Gray automation? CI/CD, analytics.\n","updated":"2025-07-17T10:11:29.165Z","comments":1,"layout":"page","_id":"cmd78fh5p001h5ek786y7fe6p","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与方案\"><a href=\"#1-1-概念与方案\" class=\"headerlink\" title=\"1.1 概念与方案\"></a>1.1 概念与方案</h2><ul>\n<li>热修复：无需发版，动态修复 bug（JSPatch、Weex、热更新 SDK）。</li>\n<li>灰度发布：分批上线，降低风险。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>JSPatch 脚本、A&#x2F;B 测试、分组发布。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>紧急 bug 修复、功能试点、A&#x2F;B 测试。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>热修复受苹果审核限制。</li>\n<li>灰度需完善监控、回滚机制。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>热修复安全风险？代码注入、越权。</li>\n<li>灰度发布如何自动化？结合 CI&#x2F;CD、埋点。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Solution\"><a href=\"#2-1-Concept-Solution\" class=\"headerlink\" title=\"2.1 Concept &amp; Solution\"></a>2.1 Concept &amp; Solution</h2><ul>\n<li>Hotfix: fix bug without release (JSPatch, Weex, hotfix SDK).</li>\n<li>Gray release: batch rollout, lower risk.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>JSPatch script, A&#x2F;B test, group release.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Urgent bug, pilot, A&#x2F;B test.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Hotfix: App Store policy.</li>\n<li>Gray: need monitor, rollback.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Hotfix risk? Code injection, privilege.</li>\n<li>Gray automation? CI&#x2F;CD, analytics.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与方案\"><a href=\"#1-1-概念与方案\" class=\"headerlink\" title=\"1.1 概念与方案\"></a>1.1 概念与方案</h2><ul>\n<li>热修复：无需发版，动态修复 bug（JSPatch、Weex、热更新 SDK）。</li>\n<li>灰度发布：分批上线，降低风险。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>JSPatch 脚本、A&#x2F;B 测试、分组发布。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>紧急 bug 修复、功能试点、A&#x2F;B 测试。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>热修复受苹果审核限制。</li>\n<li>灰度需完善监控、回滚机制。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>热修复安全风险？代码注入、越权。</li>\n<li>灰度发布如何自动化？结合 CI&#x2F;CD、埋点。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Solution\"><a href=\"#2-1-Concept-Solution\" class=\"headerlink\" title=\"2.1 Concept &amp; Solution\"></a>2.1 Concept &amp; Solution</h2><ul>\n<li>Hotfix: fix bug without release (JSPatch, Weex, hotfix SDK).</li>\n<li>Gray release: batch rollout, lower risk.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>JSPatch script, A&#x2F;B test, group release.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Urgent bug, pilot, A&#x2F;B test.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Hotfix: App Store policy.</li>\n<li>Gray: need monitor, rollback.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Hotfix risk? Code injection, privilege.</li>\n<li>Gray automation? CI&#x2F;CD, analytics.</li>\n</ul>\n"},{"title":"iOS 组件化与模块化实践","date":"2025-07-16T16:00:00.000Z","path":"iOS/组件化模块化实践.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与目标\n- 组件化：功能拆分为独立模块，解耦、复用、独立开发。\n- 模块化：按业务/技术分层，提升可维护性。\n\n## 1.2 代码/结构示例\n- Pod、SPM、动态库、协议解耦、路由。\n\n## 1.3 业务场景\n- 大型 App、多人协作、插件化、灰度发布。\n\n## 1.4 易混淆点\n- 组件化≠模块化，组件更强调复用。\n- 需统一接口、依赖管理。\n\n## 1.5 深挖追问\n- 如何落地？结合依赖注入、服务发现、自动化。\n- 组件化的挑战？依赖、版本、团队协作。\n\n# 2. English Answer\n\n## 2.1 Concept & Goal\n- Componentization: split into modules, decouple, reuse, independent dev.\n- Modularization: by business/tech, maintainability.\n\n## 2.2 Code/Structure Example\n- Pod, SPM, dynamic lib, protocol, router.\n\n## 2.3 Business Scenarios\n- Large app, team, plugin, gray release.\n\n## 2.4 Common Confusions\n- Component ≠ module, component for reuse.\n- Need unified interface, dependency mgmt.\n\n## 2.5 Deep Dive\n- How to implement? DI, service discovery, automation.\n- Challenges? Dependency, version, team.\n","source":"iOS/组件化模块化实践.md","raw":"---\ntitle: iOS 组件化与模块化实践\ndate: 2025-07-17\npath: source/iOS/组件化模块化实践.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与目标\n- 组件化：功能拆分为独立模块，解耦、复用、独立开发。\n- 模块化：按业务/技术分层，提升可维护性。\n\n## 1.2 代码/结构示例\n- Pod、SPM、动态库、协议解耦、路由。\n\n## 1.3 业务场景\n- 大型 App、多人协作、插件化、灰度发布。\n\n## 1.4 易混淆点\n- 组件化≠模块化，组件更强调复用。\n- 需统一接口、依赖管理。\n\n## 1.5 深挖追问\n- 如何落地？结合依赖注入、服务发现、自动化。\n- 组件化的挑战？依赖、版本、团队协作。\n\n# 2. English Answer\n\n## 2.1 Concept & Goal\n- Componentization: split into modules, decouple, reuse, independent dev.\n- Modularization: by business/tech, maintainability.\n\n## 2.2 Code/Structure Example\n- Pod, SPM, dynamic lib, protocol, router.\n\n## 2.3 Business Scenarios\n- Large app, team, plugin, gray release.\n\n## 2.4 Common Confusions\n- Component ≠ module, component for reuse.\n- Need unified interface, dependency mgmt.\n\n## 2.5 Deep Dive\n- How to implement? DI, service discovery, automation.\n- Challenges? Dependency, version, team.\n","updated":"2025-07-17T10:11:29.165Z","comments":1,"layout":"page","_id":"cmd78fh5p001i5ek70o2k9ld9","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与目标\"><a href=\"#1-1-概念与目标\" class=\"headerlink\" title=\"1.1 概念与目标\"></a>1.1 概念与目标</h2><ul>\n<li>组件化：功能拆分为独立模块，解耦、复用、独立开发。</li>\n<li>模块化：按业务&#x2F;技术分层，提升可维护性。</li>\n</ul>\n<h2 id=\"1-2-代码-结构示例\"><a href=\"#1-2-代码-结构示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;结构示例\"></a>1.2 代码&#x2F;结构示例</h2><ul>\n<li>Pod、SPM、动态库、协议解耦、路由。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、多人协作、插件化、灰度发布。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>组件化≠模块化，组件更强调复用。</li>\n<li>需统一接口、依赖管理。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何落地？结合依赖注入、服务发现、自动化。</li>\n<li>组件化的挑战？依赖、版本、团队协作。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Goal\"><a href=\"#2-1-Concept-Goal\" class=\"headerlink\" title=\"2.1 Concept &amp; Goal\"></a>2.1 Concept &amp; Goal</h2><ul>\n<li>Componentization: split into modules, decouple, reuse, independent dev.</li>\n<li>Modularization: by business&#x2F;tech, maintainability.</li>\n</ul>\n<h2 id=\"2-2-Code-Structure-Example\"><a href=\"#2-2-Code-Structure-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Structure Example\"></a>2.2 Code&#x2F;Structure Example</h2><ul>\n<li>Pod, SPM, dynamic lib, protocol, router.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, team, plugin, gray release.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Component ≠ module, component for reuse.</li>\n<li>Need unified interface, dependency mgmt.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to implement? DI, service discovery, automation.</li>\n<li>Challenges? Dependency, version, team.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与目标\"><a href=\"#1-1-概念与目标\" class=\"headerlink\" title=\"1.1 概念与目标\"></a>1.1 概念与目标</h2><ul>\n<li>组件化：功能拆分为独立模块，解耦、复用、独立开发。</li>\n<li>模块化：按业务&#x2F;技术分层，提升可维护性。</li>\n</ul>\n<h2 id=\"1-2-代码-结构示例\"><a href=\"#1-2-代码-结构示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;结构示例\"></a>1.2 代码&#x2F;结构示例</h2><ul>\n<li>Pod、SPM、动态库、协议解耦、路由。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>大型 App、多人协作、插件化、灰度发布。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>组件化≠模块化，组件更强调复用。</li>\n<li>需统一接口、依赖管理。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何落地？结合依赖注入、服务发现、自动化。</li>\n<li>组件化的挑战？依赖、版本、团队协作。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Goal\"><a href=\"#2-1-Concept-Goal\" class=\"headerlink\" title=\"2.1 Concept &amp; Goal\"></a>2.1 Concept &amp; Goal</h2><ul>\n<li>Componentization: split into modules, decouple, reuse, independent dev.</li>\n<li>Modularization: by business&#x2F;tech, maintainability.</li>\n</ul>\n<h2 id=\"2-2-Code-Structure-Example\"><a href=\"#2-2-Code-Structure-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Structure Example\"></a>2.2 Code&#x2F;Structure Example</h2><ul>\n<li>Pod, SPM, dynamic lib, protocol, router.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Large app, team, plugin, gray release.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Component ≠ module, component for reuse.</li>\n<li>Need unified interface, dependency mgmt.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to implement? DI, service discovery, automation.</li>\n<li>Challenges? Dependency, version, team.</li>\n</ul>\n"},{"title":"iOS 线程与并发（GCD/Operation）","date":"2025-07-16T16:00:00.000Z","path":"iOS/线程与并发.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与机制\n- GCD（Grand Central Dispatch）：基于队列的并发方案，dispatch_async/dispatch_sync。\n- Operation：面向对象的并发抽象，支持依赖、取消、优先级。\n\n## 1.2 代码示例\n```swift\nDispatchQueue.global().async {\n    print(\"子线程\")\n}\nlet op = BlockOperation { print(\"op\") }\nOperationQueue().addOperation(op)\n```\n\n## 1.3 业务场景\n- 网络请求、图片处理、批量任务、UI 切换等。\n\n## 1.4 易混淆点\n- GCD 轻量，Operation 更灵活。\n- UI 更新需回主线程。\n\n## 1.5 深挖追问\n- GCD/Operation 底层？GCD 基于 libdispatch，Operation 封装 GCD。\n- 线程安全如何保障？加锁、串行队列、原子操作。\n\n# 2. English Answer\n\n## 2.1 Concept & Mechanism\n- GCD: queue-based concurrency, dispatch_async/dispatch_sync.\n- Operation: OOP abstraction, supports dependency, cancel, priority.\n\n## 2.2 Code Example\n```swift\nDispatchQueue.global().async {\n    print(\"background\")\n}\nlet op = BlockOperation { print(\"op\") }\nOperationQueue().addOperation(op)\n```\n\n## 2.3 Business Scenarios\n- Network, image, batch, UI switch, etc.\n\n## 2.4 Common Confusions\n- GCD: lightweight; Operation: flexible.\n- UI update on main thread.\n\n## 2.5 Deep Dive\n- GCD/Operation internals? GCD: libdispatch; Operation wraps GCD.\n- Thread safety? Lock, serial queue, atomic op.\n","source":"iOS/线程与并发.md","raw":"---\ntitle: iOS 线程与并发（GCD/Operation）\ndate: 2025-07-17\npath: source/iOS/线程与并发.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与机制\n- GCD（Grand Central Dispatch）：基于队列的并发方案，dispatch_async/dispatch_sync。\n- Operation：面向对象的并发抽象，支持依赖、取消、优先级。\n\n## 1.2 代码示例\n```swift\nDispatchQueue.global().async {\n    print(\"子线程\")\n}\nlet op = BlockOperation { print(\"op\") }\nOperationQueue().addOperation(op)\n```\n\n## 1.3 业务场景\n- 网络请求、图片处理、批量任务、UI 切换等。\n\n## 1.4 易混淆点\n- GCD 轻量，Operation 更灵活。\n- UI 更新需回主线程。\n\n## 1.5 深挖追问\n- GCD/Operation 底层？GCD 基于 libdispatch，Operation 封装 GCD。\n- 线程安全如何保障？加锁、串行队列、原子操作。\n\n# 2. English Answer\n\n## 2.1 Concept & Mechanism\n- GCD: queue-based concurrency, dispatch_async/dispatch_sync.\n- Operation: OOP abstraction, supports dependency, cancel, priority.\n\n## 2.2 Code Example\n```swift\nDispatchQueue.global().async {\n    print(\"background\")\n}\nlet op = BlockOperation { print(\"op\") }\nOperationQueue().addOperation(op)\n```\n\n## 2.3 Business Scenarios\n- Network, image, batch, UI switch, etc.\n\n## 2.4 Common Confusions\n- GCD: lightweight; Operation: flexible.\n- UI update on main thread.\n\n## 2.5 Deep Dive\n- GCD/Operation internals? GCD: libdispatch; Operation wraps GCD.\n- Thread safety? Lock, serial queue, atomic op.\n","updated":"2025-07-17T10:11:29.165Z","comments":1,"layout":"page","_id":"cmd78fh5p001j5ek7fh6hbhm5","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与机制\"><a href=\"#1-1-概念与机制\" class=\"headerlink\" title=\"1.1 概念与机制\"></a>1.1 概念与机制</h2><ul>\n<li>GCD（Grand Central Dispatch）：基于队列的并发方案，dispatch_async&#x2F;dispatch_sync。</li>\n<li>Operation：面向对象的并发抽象，支持依赖、取消、优先级。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;子线程&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> op <span class=\"operator\">=</span> <span class=\"type\">BlockOperation</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;op&quot;</span>) &#125;</span><br><span class=\"line\"><span class=\"type\">OperationQueue</span>().addOperation(op)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>网络请求、图片处理、批量任务、UI 切换等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>GCD 轻量，Operation 更灵活。</li>\n<li>UI 更新需回主线程。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>GCD&#x2F;Operation 底层？GCD 基于 libdispatch，Operation 封装 GCD。</li>\n<li>线程安全如何保障？加锁、串行队列、原子操作。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Mechanism\"><a href=\"#2-1-Concept-Mechanism\" class=\"headerlink\" title=\"2.1 Concept &amp; Mechanism\"></a>2.1 Concept &amp; Mechanism</h2><ul>\n<li>GCD: queue-based concurrency, dispatch_async&#x2F;dispatch_sync.</li>\n<li>Operation: OOP abstraction, supports dependency, cancel, priority.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;background&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> op <span class=\"operator\">=</span> <span class=\"type\">BlockOperation</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;op&quot;</span>) &#125;</span><br><span class=\"line\"><span class=\"type\">OperationQueue</span>().addOperation(op)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Network, image, batch, UI switch, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>GCD: lightweight; Operation: flexible.</li>\n<li>UI update on main thread.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>GCD&#x2F;Operation internals? GCD: libdispatch; Operation wraps GCD.</li>\n<li>Thread safety? Lock, serial queue, atomic op.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与机制\"><a href=\"#1-1-概念与机制\" class=\"headerlink\" title=\"1.1 概念与机制\"></a>1.1 概念与机制</h2><ul>\n<li>GCD（Grand Central Dispatch）：基于队列的并发方案，dispatch_async&#x2F;dispatch_sync。</li>\n<li>Operation：面向对象的并发抽象，支持依赖、取消、优先级。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;子线程&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> op <span class=\"operator\">=</span> <span class=\"type\">BlockOperation</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;op&quot;</span>) &#125;</span><br><span class=\"line\"><span class=\"type\">OperationQueue</span>().addOperation(op)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>网络请求、图片处理、批量任务、UI 切换等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>GCD 轻量，Operation 更灵活。</li>\n<li>UI 更新需回主线程。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>GCD&#x2F;Operation 底层？GCD 基于 libdispatch，Operation 封装 GCD。</li>\n<li>线程安全如何保障？加锁、串行队列、原子操作。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Mechanism\"><a href=\"#2-1-Concept-Mechanism\" class=\"headerlink\" title=\"2.1 Concept &amp; Mechanism\"></a>2.1 Concept &amp; Mechanism</h2><ul>\n<li>GCD: queue-based concurrency, dispatch_async&#x2F;dispatch_sync.</li>\n<li>Operation: OOP abstraction, supports dependency, cancel, priority.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;background&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> op <span class=\"operator\">=</span> <span class=\"type\">BlockOperation</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;op&quot;</span>) &#125;</span><br><span class=\"line\"><span class=\"type\">OperationQueue</span>().addOperation(op)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Network, image, batch, UI switch, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>GCD: lightweight; Operation: flexible.</li>\n<li>UI update on main thread.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>GCD&#x2F;Operation internals? GCD: libdispatch; Operation wraps GCD.</li>\n<li>Thread safety? Lock, serial queue, atomic op.</li>\n</ul>\n"},{"title":"自定义下标","date":"2025-07-16T16:00:00.000Z","path":"iOS/自定义下标.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与实现\nSwift 支持自定义下标（subscript），让对象像数组一样用 [] 访问和赋值，常用于集合、缓存等。\n\n## 1.2 代码示例\n```swift\nstruct Matrix {\n    var grid: [[Int]]\n    subscript(row: Int, col: Int) -> Int {\n        get { grid[row][col] }\n        set { grid[row][col] = newValue }\n    }\n}\n```\n\n## 1.3 业务场景\n- 二维数组、缓存、DSL 等。\n\n## 1.4 易混淆点\n- 可定义多参数/多类型下标。\n- 可只读或可读写。\n\n## 1.5 深挖追问\n- 下标和方法的区别？语法糖，提升可读性。\n\n# 2. English Answer\n\n## 2.1 Concept & Implementation\nSwift supports custom subscript, allowing objects to be accessed like arrays, useful for collections, cache, etc.\n\n## 2.2 Code Example\n```swift\nstruct Matrix {\n    var grid: [[Int]]\n    subscript(row: Int, col: Int) -> Int {\n        get { grid[row][col] }\n        set { grid[row][col] = newValue }\n    }\n}\n```\n\n## 2.3 Business Scenarios\n- 2D array, cache, DSL, etc.\n\n## 2.4 Common Confusions\n- Multi-parameter/type subscript.\n- Read-only or read-write.\n\n## 2.5 Deep Dive\n- Difference with method? Syntactic sugar for readability.\n","source":"iOS/自定义下标.md","raw":"---\ntitle: 自定义下标\ndate: 2025-07-17\npath: source/iOS/自定义下标.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与实现\nSwift 支持自定义下标（subscript），让对象像数组一样用 [] 访问和赋值，常用于集合、缓存等。\n\n## 1.2 代码示例\n```swift\nstruct Matrix {\n    var grid: [[Int]]\n    subscript(row: Int, col: Int) -> Int {\n        get { grid[row][col] }\n        set { grid[row][col] = newValue }\n    }\n}\n```\n\n## 1.3 业务场景\n- 二维数组、缓存、DSL 等。\n\n## 1.4 易混淆点\n- 可定义多参数/多类型下标。\n- 可只读或可读写。\n\n## 1.5 深挖追问\n- 下标和方法的区别？语法糖，提升可读性。\n\n# 2. English Answer\n\n## 2.1 Concept & Implementation\nSwift supports custom subscript, allowing objects to be accessed like arrays, useful for collections, cache, etc.\n\n## 2.2 Code Example\n```swift\nstruct Matrix {\n    var grid: [[Int]]\n    subscript(row: Int, col: Int) -> Int {\n        get { grid[row][col] }\n        set { grid[row][col] = newValue }\n    }\n}\n```\n\n## 2.3 Business Scenarios\n- 2D array, cache, DSL, etc.\n\n## 2.4 Common Confusions\n- Multi-parameter/type subscript.\n- Read-only or read-write.\n\n## 2.5 Deep Dive\n- Difference with method? Syntactic sugar for readability.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5p001k5ek77i2p5w0k","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与实现\"><a href=\"#1-1-概念与实现\" class=\"headerlink\" title=\"1.1 概念与实现\"></a>1.1 概念与实现</h2><p>Swift 支持自定义下标（subscript），让对象像数组一样用 [] 访问和赋值，常用于集合、缓存等。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Matrix</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> grid: [[<span class=\"type\">Int</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>(<span class=\"params\">row</span>: <span class=\"type\">Int</span>, <span class=\"params\">col</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; grid[row][col] &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; grid[row][col] <span class=\"operator\">=</span> newValue &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>二维数组、缓存、DSL 等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>可定义多参数&#x2F;多类型下标。</li>\n<li>可只读或可读写。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>下标和方法的区别？语法糖，提升可读性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Implementation\"><a href=\"#2-1-Concept-Implementation\" class=\"headerlink\" title=\"2.1 Concept &amp; Implementation\"></a>2.1 Concept &amp; Implementation</h2><p>Swift supports custom subscript, allowing objects to be accessed like arrays, useful for collections, cache, etc.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Matrix</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> grid: [[<span class=\"type\">Int</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>(<span class=\"params\">row</span>: <span class=\"type\">Int</span>, <span class=\"params\">col</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; grid[row][col] &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; grid[row][col] <span class=\"operator\">=</span> newValue &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>2D array, cache, DSL, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Multi-parameter&#x2F;type subscript.</li>\n<li>Read-only or read-write.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Difference with method? Syntactic sugar for readability.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与实现\"><a href=\"#1-1-概念与实现\" class=\"headerlink\" title=\"1.1 概念与实现\"></a>1.1 概念与实现</h2><p>Swift 支持自定义下标（subscript），让对象像数组一样用 [] 访问和赋值，常用于集合、缓存等。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Matrix</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> grid: [[<span class=\"type\">Int</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>(<span class=\"params\">row</span>: <span class=\"type\">Int</span>, <span class=\"params\">col</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; grid[row][col] &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; grid[row][col] <span class=\"operator\">=</span> newValue &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>二维数组、缓存、DSL 等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>可定义多参数&#x2F;多类型下标。</li>\n<li>可只读或可读写。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>下标和方法的区别？语法糖，提升可读性。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Implementation\"><a href=\"#2-1-Concept-Implementation\" class=\"headerlink\" title=\"2.1 Concept &amp; Implementation\"></a>2.1 Concept &amp; Implementation</h2><p>Swift supports custom subscript, allowing objects to be accessed like arrays, useful for collections, cache, etc.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Matrix</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> grid: [[<span class=\"type\">Int</span>]]</span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>(<span class=\"params\">row</span>: <span class=\"type\">Int</span>, <span class=\"params\">col</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; grid[row][col] &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123; grid[row][col] <span class=\"operator\">=</span> newValue &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>2D array, cache, DSL, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Multi-parameter&#x2F;type subscript.</li>\n<li>Read-only or read-write.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Difference with method? Syntactic sugar for readability.</li>\n</ul>\n"},{"title":"iOS 网络安全与数据加密","date":"2025-07-16T16:00:00.000Z","path":"iOS/网络安全与数据加密.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 核心点\n- HTTPS、ATS、证书校验、防中间人攻击。\n- 数据加密：Keychain、AES、RSA、本地加密。\n\n## 1.2 代码/方案示例\n- URLSession 支持 ATS。\n- Keychain 存储敏感信息。\n\n## 1.3 业务场景\n- 登录、支付、隐私数据、API 通信。\n\n## 1.4 易混淆点\n- ATS 默认强制 HTTPS。\n- 加密算法选型需结合场景。\n\n## 1.5 深挖追问\n- 如何防止证书伪造？双向认证、证书锁定。\n- 加密与性能如何权衡？分级加密、异步处理。\n\n# 2. English Answer\n\n## 2.1 Key Points\n- HTTPS, ATS, cert validation, MITM defense.\n- Data encryption: Keychain, AES, RSA, local.\n\n## 2.2 Code/Solution Example\n- URLSession supports ATS.\n- Keychain for sensitive info.\n\n## 2.3 Business Scenarios\n- Login, payment, privacy, API.\n\n## 2.4 Common Confusions\n- ATS enforces HTTPS by default.\n- Choose encryption by scenario.\n\n## 2.5 Deep Dive\n- Prevent cert spoof? Mutual auth, pinning.\n- Encryption vs perf? Level, async.\n","source":"iOS/网络安全与数据加密.md","raw":"---\ntitle: iOS 网络安全与数据加密\ndate: 2025-07-17\npath: source/iOS/网络安全与数据加密.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 核心点\n- HTTPS、ATS、证书校验、防中间人攻击。\n- 数据加密：Keychain、AES、RSA、本地加密。\n\n## 1.2 代码/方案示例\n- URLSession 支持 ATS。\n- Keychain 存储敏感信息。\n\n## 1.3 业务场景\n- 登录、支付、隐私数据、API 通信。\n\n## 1.4 易混淆点\n- ATS 默认强制 HTTPS。\n- 加密算法选型需结合场景。\n\n## 1.5 深挖追问\n- 如何防止证书伪造？双向认证、证书锁定。\n- 加密与性能如何权衡？分级加密、异步处理。\n\n# 2. English Answer\n\n## 2.1 Key Points\n- HTTPS, ATS, cert validation, MITM defense.\n- Data encryption: Keychain, AES, RSA, local.\n\n## 2.2 Code/Solution Example\n- URLSession supports ATS.\n- Keychain for sensitive info.\n\n## 2.3 Business Scenarios\n- Login, payment, privacy, API.\n\n## 2.4 Common Confusions\n- ATS enforces HTTPS by default.\n- Choose encryption by scenario.\n\n## 2.5 Deep Dive\n- Prevent cert spoof? Mutual auth, pinning.\n- Encryption vs perf? Level, async.\n","updated":"2025-07-17T10:11:29.198Z","comments":1,"layout":"page","_id":"cmd78fh5p001l5ek737pubgcc","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-核心点\"><a href=\"#1-1-核心点\" class=\"headerlink\" title=\"1.1 核心点\"></a>1.1 核心点</h2><ul>\n<li>HTTPS、ATS、证书校验、防中间人攻击。</li>\n<li>数据加密：Keychain、AES、RSA、本地加密。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>URLSession 支持 ATS。</li>\n<li>Keychain 存储敏感信息。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>登录、支付、隐私数据、API 通信。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>ATS 默认强制 HTTPS。</li>\n<li>加密算法选型需结合场景。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何防止证书伪造？双向认证、证书锁定。</li>\n<li>加密与性能如何权衡？分级加密、异步处理。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Points\"><a href=\"#2-1-Key-Points\" class=\"headerlink\" title=\"2.1 Key Points\"></a>2.1 Key Points</h2><ul>\n<li>HTTPS, ATS, cert validation, MITM defense.</li>\n<li>Data encryption: Keychain, AES, RSA, local.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>URLSession supports ATS.</li>\n<li>Keychain for sensitive info.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Login, payment, privacy, API.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>ATS enforces HTTPS by default.</li>\n<li>Choose encryption by scenario.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Prevent cert spoof? Mutual auth, pinning.</li>\n<li>Encryption vs perf? Level, async.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-核心点\"><a href=\"#1-1-核心点\" class=\"headerlink\" title=\"1.1 核心点\"></a>1.1 核心点</h2><ul>\n<li>HTTPS、ATS、证书校验、防中间人攻击。</li>\n<li>数据加密：Keychain、AES、RSA、本地加密。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>URLSession 支持 ATS。</li>\n<li>Keychain 存储敏感信息。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>登录、支付、隐私数据、API 通信。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>ATS 默认强制 HTTPS。</li>\n<li>加密算法选型需结合场景。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何防止证书伪造？双向认证、证书锁定。</li>\n<li>加密与性能如何权衡？分级加密、异步处理。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Key-Points\"><a href=\"#2-1-Key-Points\" class=\"headerlink\" title=\"2.1 Key Points\"></a>2.1 Key Points</h2><ul>\n<li>HTTPS, ATS, cert validation, MITM defense.</li>\n<li>Data encryption: Keychain, AES, RSA, local.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>URLSession supports ATS.</li>\n<li>Keychain for sensitive info.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Login, payment, privacy, API.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>ATS enforces HTTPS by default.</li>\n<li>Choose encryption by scenario.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Prevent cert spoof? Mutual auth, pinning.</li>\n<li>Encryption vs perf? Level, async.</li>\n</ul>\n"},{"title":"Swift自定义构造方法","date":"2025-07-16T16:00:00.000Z","path":"iOS/自定义构造方法.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 自定义构造方法的意义\n1. 满足业务需求，灵活初始化对象。\n2. 支持参数校验、默认值、依赖注入等。\n\n## 1.2 如何实现\n- 在类/结构体中自定义 `init` 方法，设置属性、校验参数。\n- 可结合便利构造方法、可失败构造方法。\n\n## 1.3 实际代码示例\n```swift\nstruct User {\n    var name: String\n    var age: Int\n    // 自定义构造方法\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = max(0, age) // 参数校验\n    }\n    // 便利构造方法\n    init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    // 可失败构造方法\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 1.4 业务/用户价值\n- 满足多样化初始化需求，提升产品灵活性。\n- 保证数据有效性，减少 bug。\n\n## 1.5 易混淆点\n- 自定义构造方法可与默认构造方法共存。\n- 结构体有自动合成的成员构造方法，类没有。\n\n# 2. English Answer\n\n## 2.1 Why Custom Initializers?\n1. Meet business needs, flexible object creation.\n2. Support param validation, default values, DI, etc.\n\n## 2.2 How to implement\n- Define `init` in class/struct, set properties, validate params.\n- Can use with convenience/failable initializers.\n\n## 2.3 Code Example\n```swift\nstruct User {\n    var name: String\n    var age: Int\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = max(0, age)\n    }\n    init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 2.4 Business/User Value\n- Flexible init, better product flexibility.\n- Ensures data validity, fewer bugs.\n\n## 2.5 Common Confusion\n- Custom initializers can coexist with default ones.\n- Structs auto-synthesize memberwise init, classes do not.\n","source":"iOS/自定义构造方法.md","raw":"---\ntitle: Swift自定义构造方法\ndate: 2025-07-17\npath: source/iOS/自定义构造方法.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 自定义构造方法的意义\n1. 满足业务需求，灵活初始化对象。\n2. 支持参数校验、默认值、依赖注入等。\n\n## 1.2 如何实现\n- 在类/结构体中自定义 `init` 方法，设置属性、校验参数。\n- 可结合便利构造方法、可失败构造方法。\n\n## 1.3 实际代码示例\n```swift\nstruct User {\n    var name: String\n    var age: Int\n    // 自定义构造方法\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = max(0, age) // 参数校验\n    }\n    // 便利构造方法\n    init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    // 可失败构造方法\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 1.4 业务/用户价值\n- 满足多样化初始化需求，提升产品灵活性。\n- 保证数据有效性，减少 bug。\n\n## 1.5 易混淆点\n- 自定义构造方法可与默认构造方法共存。\n- 结构体有自动合成的成员构造方法，类没有。\n\n# 2. English Answer\n\n## 2.1 Why Custom Initializers?\n1. Meet business needs, flexible object creation.\n2. Support param validation, default values, DI, etc.\n\n## 2.2 How to implement\n- Define `init` in class/struct, set properties, validate params.\n- Can use with convenience/failable initializers.\n\n## 2.3 Code Example\n```swift\nstruct User {\n    var name: String\n    var age: Int\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = max(0, age)\n    }\n    init(name: String) {\n        self.init(name: name, age: 0)\n    }\n    init?(dict: [String: Any]) {\n        guard let name = dict[\"name\"] as? String,\n              let age = dict[\"age\"] as? Int else { return nil }\n        self.name = name\n        self.age = age\n    }\n}\n```\n\n## 2.4 Business/User Value\n- Flexible init, better product flexibility.\n- Ensures data validity, fewer bugs.\n\n## 2.5 Common Confusion\n- Custom initializers can coexist with default ones.\n- Structs auto-synthesize memberwise init, classes do not.\n","updated":"2025-07-17T10:11:29.160Z","comments":1,"layout":"page","_id":"cmd78fh5p001m5ek7bybdb0zn","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-自定义构造方法的意义\"><a href=\"#1-1-自定义构造方法的意义\" class=\"headerlink\" title=\"1.1 自定义构造方法的意义\"></a>1.1 自定义构造方法的意义</h2><ol>\n<li>满足业务需求，灵活初始化对象。</li>\n<li>支持参数校验、默认值、依赖注入等。</li>\n</ol>\n<h2 id=\"1-2-如何实现\"><a href=\"#1-2-如何实现\" class=\"headerlink\" title=\"1.2 如何实现\"></a>1.2 如何实现</h2><ul>\n<li>在类&#x2F;结构体中自定义 <code>init</code> 方法，设置属性、校验参数。</li>\n<li>可结合便利构造方法、可失败构造方法。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"comment\">// 自定义构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, age) <span class=\"comment\">// 参数校验</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 便利构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可失败构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>满足多样化初始化需求，提升产品灵活性。</li>\n<li>保证数据有效性，减少 bug。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>自定义构造方法可与默认构造方法共存。</li>\n<li>结构体有自动合成的成员构造方法，类没有。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Why-Custom-Initializers\"><a href=\"#2-1-Why-Custom-Initializers\" class=\"headerlink\" title=\"2.1 Why Custom Initializers?\"></a>2.1 Why Custom Initializers?</h2><ol>\n<li>Meet business needs, flexible object creation.</li>\n<li>Support param validation, default values, DI, etc.</li>\n</ol>\n<h2 id=\"2-2-How-to-implement\"><a href=\"#2-2-How-to-implement\" class=\"headerlink\" title=\"2.2 How to implement\"></a>2.2 How to implement</h2><ul>\n<li>Define <code>init</code> in class&#x2F;struct, set properties, validate params.</li>\n<li>Can use with convenience&#x2F;failable initializers.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Flexible init, better product flexibility.</li>\n<li>Ensures data validity, fewer bugs.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Custom initializers can coexist with default ones.</li>\n<li>Structs auto-synthesize memberwise init, classes do not.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-自定义构造方法的意义\"><a href=\"#1-1-自定义构造方法的意义\" class=\"headerlink\" title=\"1.1 自定义构造方法的意义\"></a>1.1 自定义构造方法的意义</h2><ol>\n<li>满足业务需求，灵活初始化对象。</li>\n<li>支持参数校验、默认值、依赖注入等。</li>\n</ol>\n<h2 id=\"1-2-如何实现\"><a href=\"#1-2-如何实现\" class=\"headerlink\" title=\"1.2 如何实现\"></a>1.2 如何实现</h2><ul>\n<li>在类&#x2F;结构体中自定义 <code>init</code> 方法，设置属性、校验参数。</li>\n<li>可结合便利构造方法、可失败构造方法。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"comment\">// 自定义构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, age) <span class=\"comment\">// 参数校验</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 便利构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 可失败构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>满足多样化初始化需求，提升产品灵活性。</li>\n<li>保证数据有效性，减少 bug。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>自定义构造方法可与默认构造方法共存。</li>\n<li>结构体有自动合成的成员构造方法，类没有。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Why-Custom-Initializers\"><a href=\"#2-1-Why-Custom-Initializers\" class=\"headerlink\" title=\"2.1 Why Custom Initializers?\"></a>2.1 Why Custom Initializers?</h2><ol>\n<li>Meet business needs, flexible object creation.</li>\n<li>Support param validation, default values, DI, etc.</li>\n</ol>\n<h2 id=\"2-2-How-to-implement\"><a href=\"#2-2-How-to-implement\" class=\"headerlink\" title=\"2.2 How to implement\"></a>2.2 How to implement</h2><ul>\n<li>Define <code>init</code> in class&#x2F;struct, set properties, validate params.</li>\n<li>Can use with convenience&#x2F;failable initializers.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>, <span class=\"params\">age</span>: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, age)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, age: <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init?</span>(<span class=\"params\">dict</span>: [<span class=\"params\">String</span>: <span class=\"keyword\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;name&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">String</span>,</span><br><span class=\"line\">              <span class=\"keyword\">let</span> age <span class=\"operator\">=</span> dict[<span class=\"string\">&quot;age&quot;</span>] <span class=\"keyword\">as?</span> <span class=\"type\">Int</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age <span class=\"operator\">=</span> age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Flexible init, better product flexibility.</li>\n<li>Ensures data validity, fewer bugs.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Custom initializers can coexist with default ones.</li>\n<li>Structs auto-synthesize memberwise init, classes do not.</li>\n</ul>\n"},{"title":"获取当前代码的函数名和行号","date":"2025-07-16T16:00:00.000Z","path":"iOS/获取当前函数名和行号.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与用途\nSwift 提供了 `#function`、`#line`、`#file`、`#column` 编译器指令，用于获取当前代码的函数名、行号、文件名和列号，常用于日志、调试、埋点等场景。\n\n## 1.2 代码示例\n```swift\nfunc logInfo(_ message: String,\n             function: String = #function,\n             line: Int = #line) {\n    print(\"[\\(function):\\(line)] \\(message)\")\n}\n\nlogInfo(\"Hello\")\n```\n\n## 1.3 业务场景\n- 日志追踪、异常定位、自动埋点。\n\n## 1.4 易混淆点\n- 这些指令在编译时展开，非运行时获取。\n- 也可用于 Objective-C（__FUNCTION__、__LINE__）。\n\n## 1.5 深挖追问\n- 如何自定义日志格式？可结合 Date、Thread 等信息。\n- 如何在生产环境关闭？可用编译宏控制。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nSwift provides `#function`, `#line`, `#file`, `#column` for getting function name, line, file, column—useful for logging, debugging, analytics.\n\n## 2.2 Code Example\n```swift\nfunc logInfo(_ message: String,\n             function: String = #function,\n             line: Int = #line) {\n    print(\"[\\(function):\\(line)] \\(message)\")\n}\n\nlogInfo(\"Hello\")\n```\n\n## 2.3 Business Scenarios\n- Log tracing, error location, auto analytics.\n\n## 2.4 Common Confusions\n- These are compile-time, not runtime.\n- Also available in Objective-C (`__FUNCTION__`, `__LINE__`).\n\n## 2.5 Deep Dive\n- How to customize log format? Combine with Date, Thread, etc.\n- How to disable in production? Use compile macros.\n","source":"iOS/获取当前函数名和行号.md","raw":"---\ntitle: 获取当前代码的函数名和行号\ndate: 2025-07-17\npath: source/iOS/获取当前函数名和行号.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与用途\nSwift 提供了 `#function`、`#line`、`#file`、`#column` 编译器指令，用于获取当前代码的函数名、行号、文件名和列号，常用于日志、调试、埋点等场景。\n\n## 1.2 代码示例\n```swift\nfunc logInfo(_ message: String,\n             function: String = #function,\n             line: Int = #line) {\n    print(\"[\\(function):\\(line)] \\(message)\")\n}\n\nlogInfo(\"Hello\")\n```\n\n## 1.3 业务场景\n- 日志追踪、异常定位、自动埋点。\n\n## 1.4 易混淆点\n- 这些指令在编译时展开，非运行时获取。\n- 也可用于 Objective-C（__FUNCTION__、__LINE__）。\n\n## 1.5 深挖追问\n- 如何自定义日志格式？可结合 Date、Thread 等信息。\n- 如何在生产环境关闭？可用编译宏控制。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nSwift provides `#function`, `#line`, `#file`, `#column` for getting function name, line, file, column—useful for logging, debugging, analytics.\n\n## 2.2 Code Example\n```swift\nfunc logInfo(_ message: String,\n             function: String = #function,\n             line: Int = #line) {\n    print(\"[\\(function):\\(line)] \\(message)\")\n}\n\nlogInfo(\"Hello\")\n```\n\n## 2.3 Business Scenarios\n- Log tracing, error location, auto analytics.\n\n## 2.4 Common Confusions\n- These are compile-time, not runtime.\n- Also available in Objective-C (`__FUNCTION__`, `__LINE__`).\n\n## 2.5 Deep Dive\n- How to customize log format? Combine with Date, Thread, etc.\n- How to disable in production? Use compile macros.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5p001n5ek71uu1265s","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用途\"><a href=\"#1-1-概念与用途\" class=\"headerlink\" title=\"1.1 概念与用途\"></a>1.1 概念与用途</h2><p>Swift 提供了 <code>#function</code>、<code>#line</code>、<code>#file</code>、<code>#column</code> 编译器指令，用于获取当前代码的函数名、行号、文件名和列号，常用于日志、调试、埋点等场景。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">logInfo</span>(<span class=\"keyword\">_</span> <span class=\"params\">message</span>: <span class=\"type\">String</span>,</span><br><span class=\"line\">             <span class=\"params\">function</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"keyword\">#function</span>,</span><br><span class=\"line\">             <span class=\"params\">line</span>: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"keyword\">#line</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[<span class=\"subst\">\\(function)</span>:<span class=\"subst\">\\(line)</span>] <span class=\"subst\">\\(message)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">logInfo(<span class=\"string\">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>日志追踪、异常定位、自动埋点。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>这些指令在编译时展开，非运行时获取。</li>\n<li>也可用于 Objective-C（__FUNCTION__、__LINE__）。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何自定义日志格式？可结合 Date、Thread 等信息。</li>\n<li>如何在生产环境关闭？可用编译宏控制。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Swift provides <code>#function</code>, <code>#line</code>, <code>#file</code>, <code>#column</code> for getting function name, line, file, column—useful for logging, debugging, analytics.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">logInfo</span>(<span class=\"keyword\">_</span> <span class=\"params\">message</span>: <span class=\"type\">String</span>,</span><br><span class=\"line\">             <span class=\"params\">function</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"keyword\">#function</span>,</span><br><span class=\"line\">             <span class=\"params\">line</span>: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"keyword\">#line</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[<span class=\"subst\">\\(function)</span>:<span class=\"subst\">\\(line)</span>] <span class=\"subst\">\\(message)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">logInfo(<span class=\"string\">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Log tracing, error location, auto analytics.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>These are compile-time, not runtime.</li>\n<li>Also available in Objective-C (<code>__FUNCTION__</code>, <code>__LINE__</code>).</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to customize log format? Combine with Date, Thread, etc.</li>\n<li>How to disable in production? Use compile macros.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用途\"><a href=\"#1-1-概念与用途\" class=\"headerlink\" title=\"1.1 概念与用途\"></a>1.1 概念与用途</h2><p>Swift 提供了 <code>#function</code>、<code>#line</code>、<code>#file</code>、<code>#column</code> 编译器指令，用于获取当前代码的函数名、行号、文件名和列号，常用于日志、调试、埋点等场景。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">logInfo</span>(<span class=\"keyword\">_</span> <span class=\"params\">message</span>: <span class=\"type\">String</span>,</span><br><span class=\"line\">             <span class=\"params\">function</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"keyword\">#function</span>,</span><br><span class=\"line\">             <span class=\"params\">line</span>: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"keyword\">#line</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[<span class=\"subst\">\\(function)</span>:<span class=\"subst\">\\(line)</span>] <span class=\"subst\">\\(message)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">logInfo(<span class=\"string\">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>日志追踪、异常定位、自动埋点。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>这些指令在编译时展开，非运行时获取。</li>\n<li>也可用于 Objective-C（__FUNCTION__、__LINE__）。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何自定义日志格式？可结合 Date、Thread 等信息。</li>\n<li>如何在生产环境关闭？可用编译宏控制。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Swift provides <code>#function</code>, <code>#line</code>, <code>#file</code>, <code>#column</code> for getting function name, line, file, column—useful for logging, debugging, analytics.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">logInfo</span>(<span class=\"keyword\">_</span> <span class=\"params\">message</span>: <span class=\"type\">String</span>,</span><br><span class=\"line\">             <span class=\"params\">function</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"keyword\">#function</span>,</span><br><span class=\"line\">             <span class=\"params\">line</span>: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"keyword\">#line</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;[<span class=\"subst\">\\(function)</span>:<span class=\"subst\">\\(line)</span>] <span class=\"subst\">\\(message)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">logInfo(<span class=\"string\">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Log tracing, error location, auto analytics.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>These are compile-time, not runtime.</li>\n<li>Also available in Objective-C (<code>__FUNCTION__</code>, <code>__LINE__</code>).</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>How to customize log format? Combine with Date, Thread, etc.</li>\n<li>How to disable in production? Use compile macros.</li>\n</ul>\n"},{"title":"iOS 自动化测试与持续集成","date":"2025-07-16T16:00:00.000Z","path":"iOS/自动化测试与持续集成.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与工具\n- 单元/UI测试：XCTest、XCUITest。\n- 持续集成：Jenkins、GitHub Actions、Fastlane。\n\n## 1.2 代码/方案示例\n- XCTestCase、UI 测试脚本、自动打包脚本。\n\n## 1.3 业务场景\n- 回归测试、自动打包、质量保障。\n\n## 1.4 易混淆点\n- 单元测试关注逻辑，UI 测试关注交互。\n- 持续集成需结合自动化测试。\n\n## 1.5 深挖追问\n- 如何提升测试覆盖率？Mock、依赖注入。\n- 持续集成如何落地？自动触发、结果反馈。\n\n# 2. English Answer\n\n## 2.1 Concept & Tools\n- Unit/UI test: XCTest, XCUITest.\n- CI: Jenkins, GitHub Actions, Fastlane.\n\n## 2.2 Code/Solution Example\n- XCTestCase, UI test script, auto package script.\n\n## 2.3 Business Scenarios\n- Regression, auto package, quality.\n\n## 2.4 Common Confusions\n- Unit: logic; UI: interaction.\n- CI needs auto test.\n\n## 2.5 Deep Dive\n- Improve coverage? Mock, DI.\n- CI implementation? Auto trigger, feedback.\n","source":"iOS/自动化测试与持续集成.md","raw":"---\ntitle: iOS 自动化测试与持续集成\ndate: 2025-07-17\npath: source/iOS/自动化测试与持续集成.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与工具\n- 单元/UI测试：XCTest、XCUITest。\n- 持续集成：Jenkins、GitHub Actions、Fastlane。\n\n## 1.2 代码/方案示例\n- XCTestCase、UI 测试脚本、自动打包脚本。\n\n## 1.3 业务场景\n- 回归测试、自动打包、质量保障。\n\n## 1.4 易混淆点\n- 单元测试关注逻辑，UI 测试关注交互。\n- 持续集成需结合自动化测试。\n\n## 1.5 深挖追问\n- 如何提升测试覆盖率？Mock、依赖注入。\n- 持续集成如何落地？自动触发、结果反馈。\n\n# 2. English Answer\n\n## 2.1 Concept & Tools\n- Unit/UI test: XCTest, XCUITest.\n- CI: Jenkins, GitHub Actions, Fastlane.\n\n## 2.2 Code/Solution Example\n- XCTestCase, UI test script, auto package script.\n\n## 2.3 Business Scenarios\n- Regression, auto package, quality.\n\n## 2.4 Common Confusions\n- Unit: logic; UI: interaction.\n- CI needs auto test.\n\n## 2.5 Deep Dive\n- Improve coverage? Mock, DI.\n- CI implementation? Auto trigger, feedback.\n","updated":"2025-07-17T10:11:29.204Z","comments":1,"layout":"page","_id":"cmd78fh5q001o5ek7g0sn3qnd","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与工具\"><a href=\"#1-1-概念与工具\" class=\"headerlink\" title=\"1.1 概念与工具\"></a>1.1 概念与工具</h2><ul>\n<li>单元&#x2F;UI测试：XCTest、XCUITest。</li>\n<li>持续集成：Jenkins、GitHub Actions、Fastlane。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>XCTestCase、UI 测试脚本、自动打包脚本。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>回归测试、自动打包、质量保障。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>单元测试关注逻辑，UI 测试关注交互。</li>\n<li>持续集成需结合自动化测试。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升测试覆盖率？Mock、依赖注入。</li>\n<li>持续集成如何落地？自动触发、结果反馈。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Tools\"><a href=\"#2-1-Concept-Tools\" class=\"headerlink\" title=\"2.1 Concept &amp; Tools\"></a>2.1 Concept &amp; Tools</h2><ul>\n<li>Unit&#x2F;UI test: XCTest, XCUITest.</li>\n<li>CI: Jenkins, GitHub Actions, Fastlane.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>XCTestCase, UI test script, auto package script.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Regression, auto package, quality.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Unit: logic; UI: interaction.</li>\n<li>CI needs auto test.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Improve coverage? Mock, DI.</li>\n<li>CI implementation? Auto trigger, feedback.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与工具\"><a href=\"#1-1-概念与工具\" class=\"headerlink\" title=\"1.1 概念与工具\"></a>1.1 概念与工具</h2><ul>\n<li>单元&#x2F;UI测试：XCTest、XCUITest。</li>\n<li>持续集成：Jenkins、GitHub Actions、Fastlane。</li>\n</ul>\n<h2 id=\"1-2-代码-方案示例\"><a href=\"#1-2-代码-方案示例\" class=\"headerlink\" title=\"1.2 代码&#x2F;方案示例\"></a>1.2 代码&#x2F;方案示例</h2><ul>\n<li>XCTestCase、UI 测试脚本、自动打包脚本。</li>\n</ul>\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>回归测试、自动打包、质量保障。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>单元测试关注逻辑，UI 测试关注交互。</li>\n<li>持续集成需结合自动化测试。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何提升测试覆盖率？Mock、依赖注入。</li>\n<li>持续集成如何落地？自动触发、结果反馈。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Tools\"><a href=\"#2-1-Concept-Tools\" class=\"headerlink\" title=\"2.1 Concept &amp; Tools\"></a>2.1 Concept &amp; Tools</h2><ul>\n<li>Unit&#x2F;UI test: XCTest, XCUITest.</li>\n<li>CI: Jenkins, GitHub Actions, Fastlane.</li>\n</ul>\n<h2 id=\"2-2-Code-Solution-Example\"><a href=\"#2-2-Code-Solution-Example\" class=\"headerlink\" title=\"2.2 Code&#x2F;Solution Example\"></a>2.2 Code&#x2F;Solution Example</h2><ul>\n<li>XCTestCase, UI test script, auto package script.</li>\n</ul>\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Regression, auto package, quality.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Unit: logic; UI: interaction.</li>\n<li>CI needs auto test.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Improve coverage? Mock, DI.</li>\n<li>CI implementation? Auto trigger, feedback.</li>\n</ul>\n"},{"title":"iOS 设计模式与最佳实践","date":"2025-07-16T16:00:00.000Z","path":"iOS/设计模式与最佳实践.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 常用设计模式\n- 单例、工厂、观察者、策略、装饰器、适配器、责任链、命令。\n\n## 1.2 代码示例\n```swift\nclass Singleton {\n    static let shared = Singleton()\n    private init() {}\n}\n```\n\n## 1.3 业务场景\n- 配置中心、事件分发、UI 主题、网络层。\n\n## 1.4 易混淆点\n- 模式选型需结合业务。\n- 滥用设计模式会增加复杂度。\n\n## 1.5 深挖追问\n- 如何落地最佳实践？结合 SOLID、重构、自动化测试。\n- 设计模式与架构的关系？模式是架构的基础。\n\n# 2. English Answer\n\n## 2.1 Common Patterns\n- Singleton, factory, observer, strategy, decorator, adapter, chain, command.\n\n## 2.2 Code Example\n```swift\nclass Singleton {\n    static let shared = Singleton()\n    private init() {}\n}\n```\n\n## 2.3 Business Scenarios\n- Config, event, UI theme, network.\n\n## 2.4 Common Confusions\n- Choose by business.\n- Overuse adds complexity.\n\n## 2.5 Deep Dive\n- Best practice? SOLID, refactor, test.\n- Pattern vs arch? Pattern is base.\n","source":"iOS/设计模式与最佳实践.md","raw":"---\ntitle: iOS 设计模式与最佳实践\ndate: 2025-07-17\npath: source/iOS/设计模式与最佳实践.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 常用设计模式\n- 单例、工厂、观察者、策略、装饰器、适配器、责任链、命令。\n\n## 1.2 代码示例\n```swift\nclass Singleton {\n    static let shared = Singleton()\n    private init() {}\n}\n```\n\n## 1.3 业务场景\n- 配置中心、事件分发、UI 主题、网络层。\n\n## 1.4 易混淆点\n- 模式选型需结合业务。\n- 滥用设计模式会增加复杂度。\n\n## 1.5 深挖追问\n- 如何落地最佳实践？结合 SOLID、重构、自动化测试。\n- 设计模式与架构的关系？模式是架构的基础。\n\n# 2. English Answer\n\n## 2.1 Common Patterns\n- Singleton, factory, observer, strategy, decorator, adapter, chain, command.\n\n## 2.2 Code Example\n```swift\nclass Singleton {\n    static let shared = Singleton()\n    private init() {}\n}\n```\n\n## 2.3 Business Scenarios\n- Config, event, UI theme, network.\n\n## 2.4 Common Confusions\n- Choose by business.\n- Overuse adds complexity.\n\n## 2.5 Deep Dive\n- Best practice? SOLID, refactor, test.\n- Pattern vs arch? Pattern is base.\n","updated":"2025-07-17T10:11:29.236Z","comments":1,"layout":"page","_id":"cmd78fh5q001p5ek7gyr1136q","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常用设计模式\"><a href=\"#1-1-常用设计模式\" class=\"headerlink\" title=\"1.1 常用设计模式\"></a>1.1 常用设计模式</h2><ul>\n<li>单例、工厂、观察者、策略、装饰器、适配器、责任链、命令。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared <span class=\"operator\">=</span> <span class=\"type\">Singleton</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>配置中心、事件分发、UI 主题、网络层。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>模式选型需结合业务。</li>\n<li>滥用设计模式会增加复杂度。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何落地最佳实践？结合 SOLID、重构、自动化测试。</li>\n<li>设计模式与架构的关系？模式是架构的基础。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Patterns\"><a href=\"#2-1-Common-Patterns\" class=\"headerlink\" title=\"2.1 Common Patterns\"></a>2.1 Common Patterns</h2><ul>\n<li>Singleton, factory, observer, strategy, decorator, adapter, chain, command.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared <span class=\"operator\">=</span> <span class=\"type\">Singleton</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Config, event, UI theme, network.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Choose by business.</li>\n<li>Overuse adds complexity.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Best practice? SOLID, refactor, test.</li>\n<li>Pattern vs arch? Pattern is base.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-常用设计模式\"><a href=\"#1-1-常用设计模式\" class=\"headerlink\" title=\"1.1 常用设计模式\"></a>1.1 常用设计模式</h2><ul>\n<li>单例、工厂、观察者、策略、装饰器、适配器、责任链、命令。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared <span class=\"operator\">=</span> <span class=\"type\">Singleton</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>配置中心、事件分发、UI 主题、网络层。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>模式选型需结合业务。</li>\n<li>滥用设计模式会增加复杂度。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>如何落地最佳实践？结合 SOLID、重构、自动化测试。</li>\n<li>设计模式与架构的关系？模式是架构的基础。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Common-Patterns\"><a href=\"#2-1-Common-Patterns\" class=\"headerlink\" title=\"2.1 Common Patterns\"></a>2.1 Common Patterns</h2><ul>\n<li>Singleton, factory, observer, strategy, decorator, adapter, chain, command.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> shared <span class=\"operator\">=</span> <span class=\"type\">Singleton</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Config, event, UI theme, network.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Choose by business.</li>\n<li>Overuse adds complexity.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Best practice? SOLID, refactor, test.</li>\n<li>Pattern vs arch? Pattern is base.</li>\n</ul>\n"},{"title":"Open、Public、Internal、File-private、Private的区别","path":"iOS/访问控制区别.html","date":"2025-07-16T16:00:00.000Z","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 五种访问控制的定义与区别\n1. **open**：最高级别，允许模块外继承和重写。常用于框架/库的API暴露。\n2. **public**：允许模块外访问，但不允许继承和重写。适合只读API暴露。\n3. **internal**（默认）：仅限当前模块内访问。适合大多数业务代码。\n4. **fileprivate**：仅限当前文件内访问。用于同文件内的细粒度封装。\n5. **private**：仅限当前作用域（如类/结构体/扩展）内访问。最严格的封装。\n\n## 1.2 为什么要这样设计？\n- 保证封装性，防止外部误用或破坏内部实现。\n- 便于团队协作，明确API边界。\n- 提高代码安全性和可维护性。\n\n## 1.3 实际代码示例\n```swift\nopen class Animal {\n    open func speak() {}\n}\n\npublic class Person {\n    public var name: String\n    public init(name: String) { self.name = name }\n}\n\ninternal struct Order {\n    var id: Int\n}\n\nfileprivate class FileHelper {\n    fileprivate func doSomething() {}\n}\n\nprivate struct Secret {\n    private var key: String\n}\n```\n\n## 1.4 用户体验/业务价值\n- 只暴露必要API，减少误用风险。\n- 便于SDK/组件化开发，提升产品稳定性。\n\n## 1.5 易混淆点\n- open 和 public 的区别：open 允许继承和重写，public 不允许。\n- fileprivate 和 private 的区别：fileprivate 跨类型/扩展可见，private 仅限本作用域。\n\n# 2. English Answer\n\n## 2.1 Definitions and Differences\n1. **open**: Highest level, allows subclassing/overriding outside the module.\n2. **public**: Accessible outside the module, but no subclassing/overriding.\n3. **internal**: Default, accessible only within the module.\n4. **fileprivate**: Accessible only within the same file.\n5. **private**: Accessible only within the same scope.\n\n## 2.2 Why this design?\n- Ensures encapsulation and prevents misuse.\n- Clarifies API boundaries for teamwork.\n- Improves code safety and maintainability.\n\n## 2.3 Code Example\n```swift\nopen class Animal {\n    open func speak() {}\n}\n\npublic class Person {\n    public var name: String\n    public init(name: String) { self.name = name }\n}\n\ninternal struct Order {\n    var id: Int\n}\n\nfileprivate class FileHelper {\n    fileprivate func doSomething() {}\n}\n\nprivate struct Secret {\n    private var key: String\n}\n```\n\n## 2.4 User/Business Value\n- Expose only necessary APIs, reduce misuse risk.\n- Useful for SDK/component development, improves product stability.\n\n## 2.5 Common Confusions\n- open vs public: open allows subclassing/overriding, public does not.\n- fileprivate vs private: fileprivate is visible across types/extensions in the same file, private is not.\n","source":"iOS/访问控制区别.md","raw":"---\ntitle: Open、Public、Internal、File-private、Private的区别\npath: source/iOS/访问控制区别.md\ndate: 2025-07-17\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 五种访问控制的定义与区别\n1. **open**：最高级别，允许模块外继承和重写。常用于框架/库的API暴露。\n2. **public**：允许模块外访问，但不允许继承和重写。适合只读API暴露。\n3. **internal**（默认）：仅限当前模块内访问。适合大多数业务代码。\n4. **fileprivate**：仅限当前文件内访问。用于同文件内的细粒度封装。\n5. **private**：仅限当前作用域（如类/结构体/扩展）内访问。最严格的封装。\n\n## 1.2 为什么要这样设计？\n- 保证封装性，防止外部误用或破坏内部实现。\n- 便于团队协作，明确API边界。\n- 提高代码安全性和可维护性。\n\n## 1.3 实际代码示例\n```swift\nopen class Animal {\n    open func speak() {}\n}\n\npublic class Person {\n    public var name: String\n    public init(name: String) { self.name = name }\n}\n\ninternal struct Order {\n    var id: Int\n}\n\nfileprivate class FileHelper {\n    fileprivate func doSomething() {}\n}\n\nprivate struct Secret {\n    private var key: String\n}\n```\n\n## 1.4 用户体验/业务价值\n- 只暴露必要API，减少误用风险。\n- 便于SDK/组件化开发，提升产品稳定性。\n\n## 1.5 易混淆点\n- open 和 public 的区别：open 允许继承和重写，public 不允许。\n- fileprivate 和 private 的区别：fileprivate 跨类型/扩展可见，private 仅限本作用域。\n\n# 2. English Answer\n\n## 2.1 Definitions and Differences\n1. **open**: Highest level, allows subclassing/overriding outside the module.\n2. **public**: Accessible outside the module, but no subclassing/overriding.\n3. **internal**: Default, accessible only within the module.\n4. **fileprivate**: Accessible only within the same file.\n5. **private**: Accessible only within the same scope.\n\n## 2.2 Why this design?\n- Ensures encapsulation and prevents misuse.\n- Clarifies API boundaries for teamwork.\n- Improves code safety and maintainability.\n\n## 2.3 Code Example\n```swift\nopen class Animal {\n    open func speak() {}\n}\n\npublic class Person {\n    public var name: String\n    public init(name: String) { self.name = name }\n}\n\ninternal struct Order {\n    var id: Int\n}\n\nfileprivate class FileHelper {\n    fileprivate func doSomething() {}\n}\n\nprivate struct Secret {\n    private var key: String\n}\n```\n\n## 2.4 User/Business Value\n- Expose only necessary APIs, reduce misuse risk.\n- Useful for SDK/component development, improves product stability.\n\n## 2.5 Common Confusions\n- open vs public: open allows subclassing/overriding, public does not.\n- fileprivate vs private: fileprivate is visible across types/extensions in the same file, private is not.\n","updated":"2025-07-17T08:09:07.806Z","comments":1,"layout":"page","_id":"cmd78fh5q001q5ek7cbou1vmy","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-五种访问控制的定义与区别\"><a href=\"#1-1-五种访问控制的定义与区别\" class=\"headerlink\" title=\"1.1 五种访问控制的定义与区别\"></a>1.1 五种访问控制的定义与区别</h2><ol>\n<li><strong>open</strong>：最高级别，允许模块外继承和重写。常用于框架&#x2F;库的API暴露。</li>\n<li><strong>public</strong>：允许模块外访问，但不允许继承和重写。适合只读API暴露。</li>\n<li><strong>internal</strong>（默认）：仅限当前模块内访问。适合大多数业务代码。</li>\n<li><strong>fileprivate</strong>：仅限当前文件内访问。用于同文件内的细粒度封装。</li>\n<li><strong>private</strong>：仅限当前作用域（如类&#x2F;结构体&#x2F;扩展）内访问。最严格的封装。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证封装性，防止外部误用或破坏内部实现。</li>\n<li>便于团队协作，明确API边界。</li>\n<li>提高代码安全性和可维护性。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">doSomething</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Secret</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验-业务价值\"><a href=\"#1-4-用户体验-业务价值\" class=\"headerlink\" title=\"1.4 用户体验&#x2F;业务价值\"></a>1.4 用户体验&#x2F;业务价值</h2><ul>\n<li>只暴露必要API，减少误用风险。</li>\n<li>便于SDK&#x2F;组件化开发，提升产品稳定性。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>open 和 public 的区别：open 允许继承和重写，public 不允许。</li>\n<li>fileprivate 和 private 的区别：fileprivate 跨类型&#x2F;扩展可见，private 仅限本作用域。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Definitions-and-Differences\"><a href=\"#2-1-Definitions-and-Differences\" class=\"headerlink\" title=\"2.1 Definitions and Differences\"></a>2.1 Definitions and Differences</h2><ol>\n<li><strong>open</strong>: Highest level, allows subclassing&#x2F;overriding outside the module.</li>\n<li><strong>public</strong>: Accessible outside the module, but no subclassing&#x2F;overriding.</li>\n<li><strong>internal</strong>: Default, accessible only within the module.</li>\n<li><strong>fileprivate</strong>: Accessible only within the same file.</li>\n<li><strong>private</strong>: Accessible only within the same scope.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures encapsulation and prevents misuse.</li>\n<li>Clarifies API boundaries for teamwork.</li>\n<li>Improves code safety and maintainability.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">doSomething</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Secret</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Business-Value\"><a href=\"#2-4-User-Business-Value\" class=\"headerlink\" title=\"2.4 User&#x2F;Business Value\"></a>2.4 User&#x2F;Business Value</h2><ul>\n<li>Expose only necessary APIs, reduce misuse risk.</li>\n<li>Useful for SDK&#x2F;component development, improves product stability.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusions\"><a href=\"#2-5-Common-Confusions\" class=\"headerlink\" title=\"2.5 Common Confusions\"></a>2.5 Common Confusions</h2><ul>\n<li>open vs public: open allows subclassing&#x2F;overriding, public does not.</li>\n<li>fileprivate vs private: fileprivate is visible across types&#x2F;extensions in the same file, private is not.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-五种访问控制的定义与区别\"><a href=\"#1-1-五种访问控制的定义与区别\" class=\"headerlink\" title=\"1.1 五种访问控制的定义与区别\"></a>1.1 五种访问控制的定义与区别</h2><ol>\n<li><strong>open</strong>：最高级别，允许模块外继承和重写。常用于框架&#x2F;库的API暴露。</li>\n<li><strong>public</strong>：允许模块外访问，但不允许继承和重写。适合只读API暴露。</li>\n<li><strong>internal</strong>（默认）：仅限当前模块内访问。适合大多数业务代码。</li>\n<li><strong>fileprivate</strong>：仅限当前文件内访问。用于同文件内的细粒度封装。</li>\n<li><strong>private</strong>：仅限当前作用域（如类&#x2F;结构体&#x2F;扩展）内访问。最严格的封装。</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>保证封装性，防止外部误用或破坏内部实现。</li>\n<li>便于团队协作，明确API边界。</li>\n<li>提高代码安全性和可维护性。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">doSomething</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Secret</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验-业务价值\"><a href=\"#1-4-用户体验-业务价值\" class=\"headerlink\" title=\"1.4 用户体验&#x2F;业务价值\"></a>1.4 用户体验&#x2F;业务价值</h2><ul>\n<li>只暴露必要API，减少误用风险。</li>\n<li>便于SDK&#x2F;组件化开发，提升产品稳定性。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>open 和 public 的区别：open 允许继承和重写，public 不允许。</li>\n<li>fileprivate 和 private 的区别：fileprivate 跨类型&#x2F;扩展可见，private 仅限本作用域。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Definitions-and-Differences\"><a href=\"#2-1-Definitions-and-Differences\" class=\"headerlink\" title=\"2.1 Definitions and Differences\"></a>2.1 Definitions and Differences</h2><ol>\n<li><strong>open</strong>: Highest level, allows subclassing&#x2F;overriding outside the module.</li>\n<li><strong>public</strong>: Accessible outside the module, but no subclassing&#x2F;overriding.</li>\n<li><strong>internal</strong>: Default, accessible only within the module.</li>\n<li><strong>fileprivate</strong>: Accessible only within the same file.</li>\n<li><strong>private</strong>: Accessible only within the same scope.</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Ensures encapsulation and prevents misuse.</li>\n<li>Clarifies API boundaries for teamwork.</li>\n<li>Improves code safety and maintainability.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Order</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id: <span class=\"type\">Int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">doSomething</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">Secret</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> key: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Business-Value\"><a href=\"#2-4-User-Business-Value\" class=\"headerlink\" title=\"2.4 User&#x2F;Business Value\"></a>2.4 User&#x2F;Business Value</h2><ul>\n<li>Expose only necessary APIs, reduce misuse risk.</li>\n<li>Useful for SDK&#x2F;component development, improves product stability.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusions\"><a href=\"#2-5-Common-Confusions\" class=\"headerlink\" title=\"2.5 Common Confusions\"></a>2.5 Common Confusions</h2><ul>\n<li>open vs public: open allows subclassing&#x2F;overriding, public does not.</li>\n<li>fileprivate vs private: fileprivate is visible across types&#x2F;extensions in the same file, private is not.</li>\n</ul>\n"},{"title":"选项类型（Optional）","date":"2025-07-16T16:00:00.000Z","path":"iOS/选项类型.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与作用\nOptional 用于表示变量可能有值或为 nil，Swift 通过 ? 和 ! 明确区分可选和非可选，提升类型安全。\n\n## 1.2 代码示例\n```swift\nvar name: String? = nil\nname = \"Tom\"\nif let n = name { print(n) }\n```\n\n## 1.3 业务场景\n- 网络数据解析、表单输入、接口兼容等。\n\n## 1.4 易混淆点\n- Optional 不是 null，是枚举（.some/.none）。\n- 强制解包（!）有风险，推荐可选绑定/??。\n\n## 1.5 深挖追问\n- Optional 的本质？enum Optional<Wrapped>。\n- 为什么 Swift 强推 Optional？防止野指针、崩溃。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nOptional means a variable may be nil or have value. Swift uses ? and ! for type safety.\n\n## 2.2 Code Example\n```swift\nvar name: String? = nil\nname = \"Tom\"\nif let n = name { print(n) }\n```\n\n## 2.3 Business Scenarios\n- Network parsing, form input, API compatibility, etc.\n\n## 2.4 Common Confusions\n- Optional is enum (.some/.none), not null.\n- Force unwrap (!) is risky, prefer binding/??.\n\n## 2.5 Deep Dive\n- Optional is enum Optional<Wrapped>.\n- Why Swift enforces Optional? Prevents crash/pointer bugs.\n","source":"iOS/选项类型.md","raw":"---\ntitle: 选项类型（Optional）\ndate: 2025-07-17\npath: source/iOS/选项类型.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与作用\nOptional 用于表示变量可能有值或为 nil，Swift 通过 ? 和 ! 明确区分可选和非可选，提升类型安全。\n\n## 1.2 代码示例\n```swift\nvar name: String? = nil\nname = \"Tom\"\nif let n = name { print(n) }\n```\n\n## 1.3 业务场景\n- 网络数据解析、表单输入、接口兼容等。\n\n## 1.4 易混淆点\n- Optional 不是 null，是枚举（.some/.none）。\n- 强制解包（!）有风险，推荐可选绑定/??。\n\n## 1.5 深挖追问\n- Optional 的本质？enum Optional<Wrapped>。\n- 为什么 Swift 强推 Optional？防止野指针、崩溃。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nOptional means a variable may be nil or have value. Swift uses ? and ! for type safety.\n\n## 2.2 Code Example\n```swift\nvar name: String? = nil\nname = \"Tom\"\nif let n = name { print(n) }\n```\n\n## 2.3 Business Scenarios\n- Network parsing, form input, API compatibility, etc.\n\n## 2.4 Common Confusions\n- Optional is enum (.some/.none), not null.\n- Force unwrap (!) is risky, prefer binding/??.\n\n## 2.5 Deep Dive\n- Optional is enum Optional<Wrapped>.\n- Why Swift enforces Optional? Prevents crash/pointer bugs.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5q001r5ek70bsn2sbr","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与作用\"><a href=\"#1-1-概念与作用\" class=\"headerlink\" title=\"1.1 概念与作用\"></a>1.1 概念与作用</h2><p>Optional 用于表示变量可能有值或为 nil，Swift 通过 ? 和 ! 明确区分可选和非可选，提升类型安全。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">name <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name &#123; <span class=\"built_in\">print</span>(n) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>网络数据解析、表单输入、接口兼容等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>Optional 不是 null，是枚举（.some&#x2F;.none）。</li>\n<li>强制解包（!）有风险，推荐可选绑定&#x2F;??。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>Optional 的本质？enum Optional<Wrapped>。</li>\n<li>为什么 Swift 强推 Optional？防止野指针、崩溃。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Optional means a variable may be nil or have value. Swift uses ? and ! for type safety.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">name <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name &#123; <span class=\"built_in\">print</span>(n) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Network parsing, form input, API compatibility, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Optional is enum (.some&#x2F;.none), not null.</li>\n<li>Force unwrap (!) is risky, prefer binding&#x2F;??.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Optional is enum Optional<Wrapped>.</li>\n<li>Why Swift enforces Optional? Prevents crash&#x2F;pointer bugs.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与作用\"><a href=\"#1-1-概念与作用\" class=\"headerlink\" title=\"1.1 概念与作用\"></a>1.1 概念与作用</h2><p>Optional 用于表示变量可能有值或为 nil，Swift 通过 ? 和 ! 明确区分可选和非可选，提升类型安全。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">name <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name &#123; <span class=\"built_in\">print</span>(n) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>网络数据解析、表单输入、接口兼容等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>Optional 不是 null，是枚举（.some&#x2F;.none）。</li>\n<li>强制解包（!）有风险，推荐可选绑定&#x2F;??。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>Optional 的本质？enum Optional<Wrapped>。</li>\n<li>为什么 Swift 强推 Optional？防止野指针、崩溃。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Optional means a variable may be nil or have value. Swift uses ? and ! for type safety.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">name <span class=\"operator\">=</span> <span class=\"string\">&quot;Tom&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> n <span class=\"operator\">=</span> name &#123; <span class=\"built_in\">print</span>(n) &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Network parsing, form input, API compatibility, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>Optional is enum (.some&#x2F;.none), not null.</li>\n<li>Force unwrap (!) is risky, prefer binding&#x2F;??.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Optional is enum Optional<Wrapped>.</li>\n<li>Why Swift enforces Optional? Prevents crash&#x2F;pointer bugs.</li>\n</ul>\n"},{"title":"运算符重载（Operator Overload）","date":"2025-07-16T16:00:00.000Z","path":"iOS/运算符重载.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念\n1. 运算符重载允许为自定义类型定义运算符的行为。\n2. Swift 支持自定义一元、二元、前缀、后缀等运算符。\n\n## 1.2 为什么要用？\n- 让自定义类型的操作更直观、易用。\n- 提升代码可读性和表达力。\n\n## 1.3 实际代码示例\n```swift\nstruct Vector2D {\n    var x: Double\n    var y: Double\n    static func +(lhs: Vector2D, rhs: Vector2D) -> Vector2D {\n        return Vector2D(x: lhs.x + rhs.x, y: lhs.y + rhs.y)\n    }\n}\nlet a = Vector2D(x: 1, y: 2)\nlet b = Vector2D(x: 3, y: 4)\nlet c = a + b // (4, 6)\n```\n\n## 1.4 业务/用户价值\n- 让 API 更自然，提升开发效率。\n- 便于数学/图形/数据结构等领域建模。\n\n## 1.5 易混淆点\n- 运算符重载需保证语义清晰，避免滥用导致代码难懂。\n- Swift 不允许重载部分运算符（如 =、.）。\n\n# 2. English Answer\n\n## 2.1 Concept\n1. Operator overloading lets you define operator behavior for custom types.\n2. Swift supports custom unary, binary, prefix, postfix operators.\n\n## 2.2 Why use it?\n- Makes custom types more intuitive to use.\n- Improves code readability and expressiveness.\n\n## 2.3 Code Example\n```swift\nstruct Vector2D {\n    var x: Double\n    var y: Double\n    static func +(lhs: Vector2D, rhs: Vector2D) -> Vector2D {\n        return Vector2D(x: lhs.x + rhs.x, y: lhs.y + rhs.y)\n    }\n}\nlet a = Vector2D(x: 1, y: 2)\nlet b = Vector2D(x: 3, y: 4)\nlet c = a + b // (4, 6)\n```\n\n## 2.4 Business/User Value\n- More natural API, better dev efficiency.\n- Useful for math/graphics/data modeling.\n\n## 2.5 Common Confusion\n- Overloading should keep semantics clear, avoid abuse.\n- Some operators (like =, .) can't be overloaded in Swift.\n","source":"iOS/运算符重载.md","raw":"---\ntitle: 运算符重载（Operator Overload）\ndate: 2025-07-17\npath: source/iOS/运算符重载.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念\n1. 运算符重载允许为自定义类型定义运算符的行为。\n2. Swift 支持自定义一元、二元、前缀、后缀等运算符。\n\n## 1.2 为什么要用？\n- 让自定义类型的操作更直观、易用。\n- 提升代码可读性和表达力。\n\n## 1.3 实际代码示例\n```swift\nstruct Vector2D {\n    var x: Double\n    var y: Double\n    static func +(lhs: Vector2D, rhs: Vector2D) -> Vector2D {\n        return Vector2D(x: lhs.x + rhs.x, y: lhs.y + rhs.y)\n    }\n}\nlet a = Vector2D(x: 1, y: 2)\nlet b = Vector2D(x: 3, y: 4)\nlet c = a + b // (4, 6)\n```\n\n## 1.4 业务/用户价值\n- 让 API 更自然，提升开发效率。\n- 便于数学/图形/数据结构等领域建模。\n\n## 1.5 易混淆点\n- 运算符重载需保证语义清晰，避免滥用导致代码难懂。\n- Swift 不允许重载部分运算符（如 =、.）。\n\n# 2. English Answer\n\n## 2.1 Concept\n1. Operator overloading lets you define operator behavior for custom types.\n2. Swift supports custom unary, binary, prefix, postfix operators.\n\n## 2.2 Why use it?\n- Makes custom types more intuitive to use.\n- Improves code readability and expressiveness.\n\n## 2.3 Code Example\n```swift\nstruct Vector2D {\n    var x: Double\n    var y: Double\n    static func +(lhs: Vector2D, rhs: Vector2D) -> Vector2D {\n        return Vector2D(x: lhs.x + rhs.x, y: lhs.y + rhs.y)\n    }\n}\nlet a = Vector2D(x: 1, y: 2)\nlet b = Vector2D(x: 3, y: 4)\nlet c = a + b // (4, 6)\n```\n\n## 2.4 Business/User Value\n- More natural API, better dev efficiency.\n- Useful for math/graphics/data modeling.\n\n## 2.5 Common Confusion\n- Overloading should keep semantics clear, avoid abuse.\n- Some operators (like =, .) can't be overloaded in Swift.\n","updated":"2025-07-17T08:12:29.921Z","comments":1,"layout":"page","_id":"cmd78fh5q001s5ek71rut8n40","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ol>\n<li>运算符重载允许为自定义类型定义运算符的行为。</li>\n<li>Swift 支持自定义一元、二元、前缀、后缀等运算符。</li>\n</ol>\n<h2 id=\"1-2-为什么要用？\"><a href=\"#1-2-为什么要用？\" class=\"headerlink\" title=\"1.2 为什么要用？\"></a>1.2 为什么要用？</h2><ul>\n<li>让自定义类型的操作更直观、易用。</li>\n<li>提升代码可读性和表达力。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Vector2D</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> y: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">+</span>(<span class=\"params\">lhs</span>: <span class=\"type\">Vector2D</span>, <span class=\"params\">rhs</span>: <span class=\"type\">Vector2D</span>) -&gt; <span class=\"type\">Vector2D</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Vector2D</span>(x: lhs.x <span class=\"operator\">+</span> rhs.x, y: lhs.y <span class=\"operator\">+</span> rhs.y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> b <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> c <span class=\"operator\">=</span> a <span class=\"operator\">+</span> b <span class=\"comment\">// (4, 6)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>让 API 更自然，提升开发效率。</li>\n<li>便于数学&#x2F;图形&#x2F;数据结构等领域建模。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>运算符重载需保证语义清晰，避免滥用导致代码难懂。</li>\n<li>Swift 不允许重载部分运算符（如 &#x3D;、.）。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ol>\n<li>Operator overloading lets you define operator behavior for custom types.</li>\n<li>Swift supports custom unary, binary, prefix, postfix operators.</li>\n</ol>\n<h2 id=\"2-2-Why-use-it\"><a href=\"#2-2-Why-use-it\" class=\"headerlink\" title=\"2.2 Why use it?\"></a>2.2 Why use it?</h2><ul>\n<li>Makes custom types more intuitive to use.</li>\n<li>Improves code readability and expressiveness.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Vector2D</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> y: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">+</span>(<span class=\"params\">lhs</span>: <span class=\"type\">Vector2D</span>, <span class=\"params\">rhs</span>: <span class=\"type\">Vector2D</span>) -&gt; <span class=\"type\">Vector2D</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Vector2D</span>(x: lhs.x <span class=\"operator\">+</span> rhs.x, y: lhs.y <span class=\"operator\">+</span> rhs.y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> b <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> c <span class=\"operator\">=</span> a <span class=\"operator\">+</span> b <span class=\"comment\">// (4, 6)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>More natural API, better dev efficiency.</li>\n<li>Useful for math&#x2F;graphics&#x2F;data modeling.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Overloading should keep semantics clear, avoid abuse.</li>\n<li>Some operators (like &#x3D;, .) can’t be overloaded in Swift.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ol>\n<li>运算符重载允许为自定义类型定义运算符的行为。</li>\n<li>Swift 支持自定义一元、二元、前缀、后缀等运算符。</li>\n</ol>\n<h2 id=\"1-2-为什么要用？\"><a href=\"#1-2-为什么要用？\" class=\"headerlink\" title=\"1.2 为什么要用？\"></a>1.2 为什么要用？</h2><ul>\n<li>让自定义类型的操作更直观、易用。</li>\n<li>提升代码可读性和表达力。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Vector2D</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> y: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">+</span>(<span class=\"params\">lhs</span>: <span class=\"type\">Vector2D</span>, <span class=\"params\">rhs</span>: <span class=\"type\">Vector2D</span>) -&gt; <span class=\"type\">Vector2D</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Vector2D</span>(x: lhs.x <span class=\"operator\">+</span> rhs.x, y: lhs.y <span class=\"operator\">+</span> rhs.y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> b <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> c <span class=\"operator\">=</span> a <span class=\"operator\">+</span> b <span class=\"comment\">// (4, 6)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>让 API 更自然，提升开发效率。</li>\n<li>便于数学&#x2F;图形&#x2F;数据结构等领域建模。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>运算符重载需保证语义清晰，避免滥用导致代码难懂。</li>\n<li>Swift 不允许重载部分运算符（如 &#x3D;、.）。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ol>\n<li>Operator overloading lets you define operator behavior for custom types.</li>\n<li>Swift supports custom unary, binary, prefix, postfix operators.</li>\n</ol>\n<h2 id=\"2-2-Why-use-it\"><a href=\"#2-2-Why-use-it\" class=\"headerlink\" title=\"2.2 Why use it?\"></a>2.2 Why use it?</h2><ul>\n<li>Makes custom types more intuitive to use.</li>\n<li>Improves code readability and expressiveness.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Vector2D</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> y: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">func</span> <span class=\"title function_\">+</span>(<span class=\"params\">lhs</span>: <span class=\"type\">Vector2D</span>, <span class=\"params\">rhs</span>: <span class=\"type\">Vector2D</span>) -&gt; <span class=\"type\">Vector2D</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Vector2D</span>(x: lhs.x <span class=\"operator\">+</span> rhs.x, y: lhs.y <span class=\"operator\">+</span> rhs.y)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> b <span class=\"operator\">=</span> <span class=\"type\">Vector2D</span>(x: <span class=\"number\">3</span>, y: <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> c <span class=\"operator\">=</span> a <span class=\"operator\">+</span> b <span class=\"comment\">// (4, 6)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>More natural API, better dev efficiency.</li>\n<li>Useful for math&#x2F;graphics&#x2F;data modeling.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>Overloading should keep semantics clear, avoid abuse.</li>\n<li>Some operators (like &#x3D;, .) can’t be overloaded in Swift.</li>\n</ul>\n"},{"title":"阻止方法被子类改写","date":"2025-07-16T16:00:00.000Z","path":"iOS/阻止方法被子类改写.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与实现\n- 使用 `final` 关键字修饰类/方法，禁止被继承或重写。\n\n## 1.2 代码示例\n```swift\nclass Base {\n    final func foo() { print(\"base\") }\n}\n\nclass Sub: Base {\n    // override func foo() {} // ❌ 编译错误\n}\n```\n\n## 1.3 业务场景\n- 保证核心逻辑不被篡改，提升安全性。\n\n## 1.4 易混淆点\n- final class 禁止继承，final func 禁止重写。\n- static 方法本质也是 final。\n\n## 1.5 深挖追问\n- final 的运行时优化？可静态派发，提升性能。\n\n# 2. English Answer\n\n## 2.1 Concept & Implementation\n- Use `final` to prevent subclassing/overriding.\n\n## 2.2 Code Example\n```swift\nclass Base {\n    final func foo() { print(\"base\") }\n}\n\nclass Sub: Base {\n    // override func foo() {} // ❌ compile error\n}\n```\n\n## 2.3 Business Scenarios\n- Protect core logic, improve security.\n\n## 2.4 Common Confusions\n- final class: no subclass; final func: no override.\n- static is also final.\n\n## 2.5 Deep Dive\n- Runtime optimization: static dispatch, better performance.\n","source":"iOS/阻止方法被子类改写.md","raw":"---\ntitle: 阻止方法被子类改写\ndate: 2025-07-17\npath: source/iOS/阻止方法被子类改写.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与实现\n- 使用 `final` 关键字修饰类/方法，禁止被继承或重写。\n\n## 1.2 代码示例\n```swift\nclass Base {\n    final func foo() { print(\"base\") }\n}\n\nclass Sub: Base {\n    // override func foo() {} // ❌ 编译错误\n}\n```\n\n## 1.3 业务场景\n- 保证核心逻辑不被篡改，提升安全性。\n\n## 1.4 易混淆点\n- final class 禁止继承，final func 禁止重写。\n- static 方法本质也是 final。\n\n## 1.5 深挖追问\n- final 的运行时优化？可静态派发，提升性能。\n\n# 2. English Answer\n\n## 2.1 Concept & Implementation\n- Use `final` to prevent subclassing/overriding.\n\n## 2.2 Code Example\n```swift\nclass Base {\n    final func foo() { print(\"base\") }\n}\n\nclass Sub: Base {\n    // override func foo() {} // ❌ compile error\n}\n```\n\n## 2.3 Business Scenarios\n- Protect core logic, improve security.\n\n## 2.4 Common Confusions\n- final class: no subclass; final func: no override.\n- static is also final.\n\n## 2.5 Deep Dive\n- Runtime optimization: static dispatch, better performance.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5q001t5ek7e7anafnk","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与实现\"><a href=\"#1-1-概念与实现\" class=\"headerlink\" title=\"1.1 概念与实现\"></a>1.1 概念与实现</h2><ul>\n<li>使用 <code>final</code> 关键字修饰类&#x2F;方法，禁止被继承或重写。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override func foo() &#123;&#125; // ❌ 编译错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>保证核心逻辑不被篡改，提升安全性。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>final class 禁止继承，final func 禁止重写。</li>\n<li>static 方法本质也是 final。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>final 的运行时优化？可静态派发，提升性能。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Implementation\"><a href=\"#2-1-Concept-Implementation\" class=\"headerlink\" title=\"2.1 Concept &amp; Implementation\"></a>2.1 Concept &amp; Implementation</h2><ul>\n<li>Use <code>final</code> to prevent subclassing&#x2F;overriding.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override func foo() &#123;&#125; // ❌ compile error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Protect core logic, improve security.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>final class: no subclass; final func: no override.</li>\n<li>static is also final.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Runtime optimization: static dispatch, better performance.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与实现\"><a href=\"#1-1-概念与实现\" class=\"headerlink\" title=\"1.1 概念与实现\"></a>1.1 概念与实现</h2><ul>\n<li>使用 <code>final</code> 关键字修饰类&#x2F;方法，禁止被继承或重写。</li>\n</ul>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override func foo() &#123;&#125; // ❌ 编译错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>保证核心逻辑不被篡改，提升安全性。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>final class 禁止继承，final func 禁止重写。</li>\n<li>static 方法本质也是 final。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>final 的运行时优化？可静态派发，提升性能。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Implementation\"><a href=\"#2-1-Concept-Implementation\" class=\"headerlink\" title=\"2.1 Concept &amp; Implementation\"></a>2.1 Concept &amp; Implementation</h2><ul>\n<li>Use <code>final</code> to prevent subclassing&#x2F;overriding.</li>\n</ul>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// override func foo() &#123;&#125; // ❌ compile error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Protect core logic, improve security.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>final class: no subclass; final func: no override.</li>\n<li>static is also final.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Runtime optimization: static dispatch, better performance.</li>\n</ul>\n"},{"title":"集合操作（Set/Map/Filter/Reduce）","date":"2025-07-16T16:00:00.000Z","path":"iOS/集合操作.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念与用法\nSwift 集合类型（Array/Set/Dictionary）常用 map/filter/reduce 等高阶函数，简化数据处理。\n\n## 1.2 代码示例\n```swift\nlet arr = [1,2,3]\nlet r1 = arr.map { $0 * 2 } // [2,4,6]\nlet r2 = arr.filter { $0 > 1 } // [2,3]\nlet r3 = arr.reduce(0, +) // 6\n```\n\n## 1.3 业务场景\n- 数据清洗、聚合、转换等。\n\n## 1.4 易混淆点\n- map 返回新数组，原数组不变。\n- reduce 可自定义初始值和操作。\n\n## 1.5 深挖追问\n- 性能影响？链式调用可能产生中间数组，可用 lazy 优化。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nSwift collections (Array/Set/Dictionary) use map/filter/reduce for data processing.\n\n## 2.2 Code Example\n```swift\nlet arr = [1,2,3]\nlet r1 = arr.map { $0 * 2 } // [2,4,6]\nlet r2 = arr.filter { $0 > 1 } // [2,3]\nlet r3 = arr.reduce(0, +) // 6\n```\n\n## 2.3 Business Scenarios\n- Data cleaning, aggregation, transform, etc.\n\n## 2.4 Common Confusions\n- map returns new array, original unchanged.\n- reduce: custom initial value/op.\n\n## 2.5 Deep Dive\n- Performance? Chaining may create temp arrays, use lazy for optimization.\n","source":"iOS/集合操作.md","raw":"---\ntitle: 集合操作（Set/Map/Filter/Reduce）\ndate: 2025-07-17\npath: source/iOS/集合操作.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念与用法\nSwift 集合类型（Array/Set/Dictionary）常用 map/filter/reduce 等高阶函数，简化数据处理。\n\n## 1.2 代码示例\n```swift\nlet arr = [1,2,3]\nlet r1 = arr.map { $0 * 2 } // [2,4,6]\nlet r2 = arr.filter { $0 > 1 } // [2,3]\nlet r3 = arr.reduce(0, +) // 6\n```\n\n## 1.3 业务场景\n- 数据清洗、聚合、转换等。\n\n## 1.4 易混淆点\n- map 返回新数组，原数组不变。\n- reduce 可自定义初始值和操作。\n\n## 1.5 深挖追问\n- 性能影响？链式调用可能产生中间数组，可用 lazy 优化。\n\n# 2. English Answer\n\n## 2.1 Concept & Usage\nSwift collections (Array/Set/Dictionary) use map/filter/reduce for data processing.\n\n## 2.2 Code Example\n```swift\nlet arr = [1,2,3]\nlet r1 = arr.map { $0 * 2 } // [2,4,6]\nlet r2 = arr.filter { $0 > 1 } // [2,3]\nlet r3 = arr.reduce(0, +) // 6\n```\n\n## 2.3 Business Scenarios\n- Data cleaning, aggregation, transform, etc.\n\n## 2.4 Common Confusions\n- map returns new array, original unchanged.\n- reduce: custom initial value/op.\n\n## 2.5 Deep Dive\n- Performance? Chaining may create temp arrays, use lazy for optimization.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5q001u5ek7gfxp7iki","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><p>Swift 集合类型（Array&#x2F;Set&#x2F;Dictionary）常用 map&#x2F;filter&#x2F;reduce 等高阶函数，简化数据处理。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> r1 <span class=\"operator\">=</span> arr.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125; <span class=\"comment\">// [2,4,6]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r2 <span class=\"operator\">=</span> arr.filter &#123; <span class=\"variable\">$0</span> <span class=\"operator\">&gt;</span> <span class=\"number\">1</span> &#125; <span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r3 <span class=\"operator\">=</span> arr.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>数据清洗、聚合、转换等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>map 返回新数组，原数组不变。</li>\n<li>reduce 可自定义初始值和操作。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>性能影响？链式调用可能产生中间数组，可用 lazy 优化。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Swift collections (Array&#x2F;Set&#x2F;Dictionary) use map&#x2F;filter&#x2F;reduce for data processing.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> r1 <span class=\"operator\">=</span> arr.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125; <span class=\"comment\">// [2,4,6]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r2 <span class=\"operator\">=</span> arr.filter &#123; <span class=\"variable\">$0</span> <span class=\"operator\">&gt;</span> <span class=\"number\">1</span> &#125; <span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r3 <span class=\"operator\">=</span> arr.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Data cleaning, aggregation, transform, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>map returns new array, original unchanged.</li>\n<li>reduce: custom initial value&#x2F;op.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Performance? Chaining may create temp arrays, use lazy for optimization.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念与用法\"><a href=\"#1-1-概念与用法\" class=\"headerlink\" title=\"1.1 概念与用法\"></a>1.1 概念与用法</h2><p>Swift 集合类型（Array&#x2F;Set&#x2F;Dictionary）常用 map&#x2F;filter&#x2F;reduce 等高阶函数，简化数据处理。</p>\n<h2 id=\"1-2-代码示例\"><a href=\"#1-2-代码示例\" class=\"headerlink\" title=\"1.2 代码示例\"></a>1.2 代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> r1 <span class=\"operator\">=</span> arr.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125; <span class=\"comment\">// [2,4,6]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r2 <span class=\"operator\">=</span> arr.filter &#123; <span class=\"variable\">$0</span> <span class=\"operator\">&gt;</span> <span class=\"number\">1</span> &#125; <span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r3 <span class=\"operator\">=</span> arr.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-3-业务场景\"><a href=\"#1-3-业务场景\" class=\"headerlink\" title=\"1.3 业务场景\"></a>1.3 业务场景</h2><ul>\n<li>数据清洗、聚合、转换等。</li>\n</ul>\n<h2 id=\"1-4-易混淆点\"><a href=\"#1-4-易混淆点\" class=\"headerlink\" title=\"1.4 易混淆点\"></a>1.4 易混淆点</h2><ul>\n<li>map 返回新数组，原数组不变。</li>\n<li>reduce 可自定义初始值和操作。</li>\n</ul>\n<h2 id=\"1-5-深挖追问\"><a href=\"#1-5-深挖追问\" class=\"headerlink\" title=\"1.5 深挖追问\"></a>1.5 深挖追问</h2><ul>\n<li>性能影响？链式调用可能产生中间数组，可用 lazy 优化。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept-Usage\"><a href=\"#2-1-Concept-Usage\" class=\"headerlink\" title=\"2.1 Concept &amp; Usage\"></a>2.1 Concept &amp; Usage</h2><p>Swift collections (Array&#x2F;Set&#x2F;Dictionary) use map&#x2F;filter&#x2F;reduce for data processing.</p>\n<h2 id=\"2-2-Code-Example\"><a href=\"#2-2-Code-Example\" class=\"headerlink\" title=\"2.2 Code Example\"></a>2.2 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr <span class=\"operator\">=</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> r1 <span class=\"operator\">=</span> arr.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125; <span class=\"comment\">// [2,4,6]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r2 <span class=\"operator\">=</span> arr.filter &#123; <span class=\"variable\">$0</span> <span class=\"operator\">&gt;</span> <span class=\"number\">1</span> &#125; <span class=\"comment\">// [2,3]</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r3 <span class=\"operator\">=</span> arr.reduce(<span class=\"number\">0</span>, <span class=\"operator\">+</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3-Business-Scenarios\"><a href=\"#2-3-Business-Scenarios\" class=\"headerlink\" title=\"2.3 Business Scenarios\"></a>2.3 Business Scenarios</h2><ul>\n<li>Data cleaning, aggregation, transform, etc.</li>\n</ul>\n<h2 id=\"2-4-Common-Confusions\"><a href=\"#2-4-Common-Confusions\" class=\"headerlink\" title=\"2.4 Common Confusions\"></a>2.4 Common Confusions</h2><ul>\n<li>map returns new array, original unchanged.</li>\n<li>reduce: custom initial value&#x2F;op.</li>\n</ul>\n<h2 id=\"2-5-Deep-Dive\"><a href=\"#2-5-Deep-Dive\" class=\"headerlink\" title=\"2.5 Deep Dive\"></a>2.5 Deep Dive</h2><ul>\n<li>Performance? Chaining may create temp arrays, use lazy for optimization.</li>\n</ul>\n"},{"title":"静态派发","date":"2025-07-16T16:00:00.000Z","path":"iOS/静态派发.html","categories":["iOS"],"_content":"\n# 1. 中文答案\n\n## 1.1 概念\n1. 静态派发（Static Dispatch）指编译期确定方法调用的具体实现。\n2. Swift 默认采用静态派发（如 struct、enum、final class、private 方法等）。\n3. 动态派发（Dynamic Dispatch）则运行时确定（如 class、@objc、dynamic）。\n\n## 1.2 为什么要用静态派发？\n- 提升性能：编译期确定，省去运行时查找。\n- 增强安全性：避免运行时错误。\n\n## 1.3 实际代码示例\n```swift\nstruct Foo {\n    func bar() { print(\"bar\") }\n}\nlet f = Foo()\nf.bar() // 静态派发\n\nclass Base {\n    func foo() { print(\"base\") }\n}\nfinal class Sub: Base {\n    override func foo() { print(\"sub\") }\n}\nlet s = Sub()\ns.foo() // 静态派发（final）\n```\n\n## 1.4 业务/用户价值\n- 性能更优，适合高性能场景。\n- 代码更安全、可预测。\n\n## 1.5 易混淆点\n- class 默认动态派发，struct/enum/final class 默认静态派发。\n- @objc/dynamic 强制动态派发。\n\n# 2. English Answer\n\n## 2.1 Concept\n1. Static dispatch: method implementation is determined at compile time.\n2. Swift uses static dispatch for struct, enum, final class, private methods.\n3. Dynamic dispatch: determined at runtime (class, @objc, dynamic).\n\n## 2.2 Why use static dispatch?\n- Better performance: no runtime lookup.\n- More safety: avoids runtime errors.\n\n## 2.3 Code Example\n```swift\nstruct Foo {\n    func bar() { print(\"bar\") }\n}\nlet f = Foo()\nf.bar() // static dispatch\n\nclass Base {\n    func foo() { print(\"base\") }\n}\nfinal class Sub: Base {\n    override func foo() { print(\"sub\") }\n}\nlet s = Sub()\ns.foo() // static dispatch (final)\n```\n\n## 2.4 Business/User Value\n- Higher performance, good for critical code.\n- Safer, more predictable code.\n\n## 2.5 Common Confusion\n- class: dynamic by default; struct/enum/final class: static by default.\n- @objc/dynamic: force dynamic dispatch.\n","source":"iOS/静态派发.md","raw":"---\ntitle: 静态派发\ndate: 2025-07-17\npath: source/iOS/静态派发.md\ncategories:\n  - iOS\n---\n\n# 1. 中文答案\n\n## 1.1 概念\n1. 静态派发（Static Dispatch）指编译期确定方法调用的具体实现。\n2. Swift 默认采用静态派发（如 struct、enum、final class、private 方法等）。\n3. 动态派发（Dynamic Dispatch）则运行时确定（如 class、@objc、dynamic）。\n\n## 1.2 为什么要用静态派发？\n- 提升性能：编译期确定，省去运行时查找。\n- 增强安全性：避免运行时错误。\n\n## 1.3 实际代码示例\n```swift\nstruct Foo {\n    func bar() { print(\"bar\") }\n}\nlet f = Foo()\nf.bar() // 静态派发\n\nclass Base {\n    func foo() { print(\"base\") }\n}\nfinal class Sub: Base {\n    override func foo() { print(\"sub\") }\n}\nlet s = Sub()\ns.foo() // 静态派发（final）\n```\n\n## 1.4 业务/用户价值\n- 性能更优，适合高性能场景。\n- 代码更安全、可预测。\n\n## 1.5 易混淆点\n- class 默认动态派发，struct/enum/final class 默认静态派发。\n- @objc/dynamic 强制动态派发。\n\n# 2. English Answer\n\n## 2.1 Concept\n1. Static dispatch: method implementation is determined at compile time.\n2. Swift uses static dispatch for struct, enum, final class, private methods.\n3. Dynamic dispatch: determined at runtime (class, @objc, dynamic).\n\n## 2.2 Why use static dispatch?\n- Better performance: no runtime lookup.\n- More safety: avoids runtime errors.\n\n## 2.3 Code Example\n```swift\nstruct Foo {\n    func bar() { print(\"bar\") }\n}\nlet f = Foo()\nf.bar() // static dispatch\n\nclass Base {\n    func foo() { print(\"base\") }\n}\nfinal class Sub: Base {\n    override func foo() { print(\"sub\") }\n}\nlet s = Sub()\ns.foo() // static dispatch (final)\n```\n\n## 2.4 Business/User Value\n- Higher performance, good for critical code.\n- Safer, more predictable code.\n\n## 2.5 Common Confusion\n- class: dynamic by default; struct/enum/final class: static by default.\n- @objc/dynamic: force dynamic dispatch.\n","updated":"2025-07-17T10:11:29.161Z","comments":1,"layout":"page","_id":"cmd78fh5q001v5ek73wfq5xrq","content":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ol>\n<li>静态派发（Static Dispatch）指编译期确定方法调用的具体实现。</li>\n<li>Swift 默认采用静态派发（如 struct、enum、final class、private 方法等）。</li>\n<li>动态派发（Dynamic Dispatch）则运行时确定（如 class、@objc、dynamic）。</li>\n</ol>\n<h2 id=\"1-2-为什么要用静态派发？\"><a href=\"#1-2-为什么要用静态派发？\" class=\"headerlink\" title=\"1.2 为什么要用静态派发？\"></a>1.2 为什么要用静态派发？</h2><ul>\n<li>提升性能：编译期确定，省去运行时查找。</li>\n<li>增强安全性：避免运行时错误。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;bar&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f <span class=\"operator\">=</span> <span class=\"type\">Foo</span>()</span><br><span class=\"line\">f.bar() <span class=\"comment\">// 静态派发</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s <span class=\"operator\">=</span> <span class=\"type\">Sub</span>()</span><br><span class=\"line\">s.foo() <span class=\"comment\">// 静态派发（final）</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>性能更优，适合高性能场景。</li>\n<li>代码更安全、可预测。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>class 默认动态派发，struct&#x2F;enum&#x2F;final class 默认静态派发。</li>\n<li>@objc&#x2F;dynamic 强制动态派发。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ol>\n<li>Static dispatch: method implementation is determined at compile time.</li>\n<li>Swift uses static dispatch for struct, enum, final class, private methods.</li>\n<li>Dynamic dispatch: determined at runtime (class, @objc, dynamic).</li>\n</ol>\n<h2 id=\"2-2-Why-use-static-dispatch\"><a href=\"#2-2-Why-use-static-dispatch\" class=\"headerlink\" title=\"2.2 Why use static dispatch?\"></a>2.2 Why use static dispatch?</h2><ul>\n<li>Better performance: no runtime lookup.</li>\n<li>More safety: avoids runtime errors.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;bar&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f <span class=\"operator\">=</span> <span class=\"type\">Foo</span>()</span><br><span class=\"line\">f.bar() <span class=\"comment\">// static dispatch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s <span class=\"operator\">=</span> <span class=\"type\">Sub</span>()</span><br><span class=\"line\">s.foo() <span class=\"comment\">// static dispatch (final)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Higher performance, good for critical code.</li>\n<li>Safer, more predictable code.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>class: dynamic by default; struct&#x2F;enum&#x2F;final class: static by default.</li>\n<li>@objc&#x2F;dynamic: force dynamic dispatch.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文答案\"><a href=\"#1-中文答案\" class=\"headerlink\" title=\"1. 中文答案\"></a>1. 中文答案</h1><h2 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h2><ol>\n<li>静态派发（Static Dispatch）指编译期确定方法调用的具体实现。</li>\n<li>Swift 默认采用静态派发（如 struct、enum、final class、private 方法等）。</li>\n<li>动态派发（Dynamic Dispatch）则运行时确定（如 class、@objc、dynamic）。</li>\n</ol>\n<h2 id=\"1-2-为什么要用静态派发？\"><a href=\"#1-2-为什么要用静态派发？\" class=\"headerlink\" title=\"1.2 为什么要用静态派发？\"></a>1.2 为什么要用静态派发？</h2><ul>\n<li>提升性能：编译期确定，省去运行时查找。</li>\n<li>增强安全性：避免运行时错误。</li>\n</ul>\n<h2 id=\"1-3-实际代码示例\"><a href=\"#1-3-实际代码示例\" class=\"headerlink\" title=\"1.3 实际代码示例\"></a>1.3 实际代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;bar&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f <span class=\"operator\">=</span> <span class=\"type\">Foo</span>()</span><br><span class=\"line\">f.bar() <span class=\"comment\">// 静态派发</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s <span class=\"operator\">=</span> <span class=\"type\">Sub</span>()</span><br><span class=\"line\">s.foo() <span class=\"comment\">// 静态派发（final）</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-业务-用户价值\"><a href=\"#1-4-业务-用户价值\" class=\"headerlink\" title=\"1.4 业务&#x2F;用户价值\"></a>1.4 业务&#x2F;用户价值</h2><ul>\n<li>性能更优，适合高性能场景。</li>\n<li>代码更安全、可预测。</li>\n</ul>\n<h2 id=\"1-5-易混淆点\"><a href=\"#1-5-易混淆点\" class=\"headerlink\" title=\"1.5 易混淆点\"></a>1.5 易混淆点</h2><ul>\n<li>class 默认动态派发，struct&#x2F;enum&#x2F;final class 默认静态派发。</li>\n<li>@objc&#x2F;dynamic 强制动态派发。</li>\n</ul>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ol>\n<li>Static dispatch: method implementation is determined at compile time.</li>\n<li>Swift uses static dispatch for struct, enum, final class, private methods.</li>\n<li>Dynamic dispatch: determined at runtime (class, @objc, dynamic).</li>\n</ol>\n<h2 id=\"2-2-Why-use-static-dispatch\"><a href=\"#2-2-Why-use-static-dispatch\" class=\"headerlink\" title=\"2.2 Why use static dispatch?\"></a>2.2 Why use static dispatch?</h2><ul>\n<li>Better performance: no runtime lookup.</li>\n<li>More safety: avoids runtime errors.</li>\n</ul>\n<h2 id=\"2-3-Code-Example\"><a href=\"#2-3-Code-Example\" class=\"headerlink\" title=\"2.3 Code Example\"></a>2.3 Code Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">bar</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;bar&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> f <span class=\"operator\">=</span> <span class=\"type\">Foo</span>()</span><br><span class=\"line\">f.bar() <span class=\"comment\">// static dispatch</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;base&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span>: <span class=\"title class_ inherited__\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">foo</span>() &#123; <span class=\"built_in\">print</span>(<span class=\"string\">&quot;sub&quot;</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s <span class=\"operator\">=</span> <span class=\"type\">Sub</span>()</span><br><span class=\"line\">s.foo() <span class=\"comment\">// static dispatch (final)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-Business-User-Value\"><a href=\"#2-4-Business-User-Value\" class=\"headerlink\" title=\"2.4 Business&#x2F;User Value\"></a>2.4 Business&#x2F;User Value</h2><ul>\n<li>Higher performance, good for critical code.</li>\n<li>Safer, more predictable code.</li>\n</ul>\n<h2 id=\"2-5-Common-Confusion\"><a href=\"#2-5-Common-Confusion\" class=\"headerlink\" title=\"2.5 Common Confusion\"></a>2.5 Common Confusion</h2><ul>\n<li>class: dynamic by default; struct&#x2F;enum&#x2F;final class: static by default.</li>\n<li>@objc&#x2F;dynamic: force dynamic dispatch.</li>\n</ul>\n"}],"Post":[{"title":"Open-Public...权限修饰符详解","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\nSwift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：\n\n1. **open**\n   - 最高级别，仅适用于类和类成员。\n   - 允许在模块外被继承和重写。\n   - 典型场景：第三方库/框架对外暴露可扩展 API。\n   - 例：\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - 允许在模块外访问，但不能被继承或重写。\n   - 适合对外暴露 API，但不希望被扩展。\n   - 例：\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal**（默认）\n   - 仅在同一模块内可见，模块外不可访问。\n   - 适合项目内部逻辑，默认不写就是 internal。\n   - 例：\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - 仅在当前 Swift 文件内可见。\n   - 适合同文件内多个类型协作，隐藏实现细节。\n   - 例：\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - 仅在当前声明作用域（如类/结构体/扩展）内可见。\n   - 适合封装最细粒度的实现细节。\n   - 例：\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 1.2 为什么要这样设计？\n- 提高代码安全性，防止外部误用或依赖内部实现。\n- 明确 API 边界，便于团队协作和模块解耦。\n- 支持灵活的封装和扩展策略。\n\n## 1.3 实际项目代码示例\n```swift\n// FrameworkA\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 1.4 用户体验与业务价值\n- 合理使用访问控制，API 更安全、易用，减少误用和维护成本。\n- 便于团队分工，隐藏实现细节，提升代码可维护性。\n\n## 1.5 问题拆解与调试建议\n- 如果外部无法访问某成员，优先检查访问修饰符。\n- 框架开发时，优先用 public，需支持继承/重写时用 open。\n- 内部工具类、辅助方法建议用 internal、fileprivate 或 private。\n\n## 1.6 易混淆点与对比\n- **open vs public**：open 可被继承/重写，public 只能访问不能继承。\n- **fileprivate vs private**：fileprivate 跨类型同文件可见，private 仅限当前作用域。\n- **internal** 是默认级别，不写就是 internal。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts & Principles\nSwift provides five access control levels to manage the visibility and accessibility of entities:\n\n1. **open**\n   - Highest level, only for classes and class members.\n   - Can be subclassed/overridden outside the module.\n   - Example:\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - Accessible outside the module, but cannot be subclassed/overridden.\n   - Example:\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal** (default)\n   - Accessible only within the same module.\n   - Example:\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - Accessible only within the same Swift file.\n   - Example:\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - Accessible only within the enclosing declaration.\n   - Example:\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 2.2 Why this design?\n- Improves code safety, prevents misuse, and clarifies API boundaries.\n- Facilitates team collaboration and modularization.\n- Supports flexible encapsulation and extension strategies.\n\n## 2.3 Practical Example\n```swift\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 2.4 User Experience & Business Value\n- Proper access control makes APIs safer and easier to use, reducing maintenance costs.\n- Hides implementation details, improving maintainability and team collaboration.\n\n## 2.5 Debugging & Troubleshooting\n- If a member is inaccessible, check its access modifier first.\n- Use public for APIs, open for extensible frameworks, internal/fileprivate/private for internal logic.\n\n## 2.6 Key Distinctions\n- **open vs public**: open allows subclassing/overriding, public does not.\n- **fileprivate vs private**: fileprivate is visible within the same file, private only within the enclosing scope.\n- **internal** is the default level.\n","source":"_posts/iOS/Open-Public-Internal关键字.md","raw":"---\ntitle: Open-Public...权限修饰符详解\ndate: 2025-07-08\ncategories:\n  - iOS\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\nSwift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：\n\n1. **open**\n   - 最高级别，仅适用于类和类成员。\n   - 允许在模块外被继承和重写。\n   - 典型场景：第三方库/框架对外暴露可扩展 API。\n   - 例：\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - 允许在模块外访问，但不能被继承或重写。\n   - 适合对外暴露 API，但不希望被扩展。\n   - 例：\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal**（默认）\n   - 仅在同一模块内可见，模块外不可访问。\n   - 适合项目内部逻辑，默认不写就是 internal。\n   - 例：\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - 仅在当前 Swift 文件内可见。\n   - 适合同文件内多个类型协作，隐藏实现细节。\n   - 例：\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - 仅在当前声明作用域（如类/结构体/扩展）内可见。\n   - 适合封装最细粒度的实现细节。\n   - 例：\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 1.2 为什么要这样设计？\n- 提高代码安全性，防止外部误用或依赖内部实现。\n- 明确 API 边界，便于团队协作和模块解耦。\n- 支持灵活的封装和扩展策略。\n\n## 1.3 实际项目代码示例\n```swift\n// FrameworkA\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 1.4 用户体验与业务价值\n- 合理使用访问控制，API 更安全、易用，减少误用和维护成本。\n- 便于团队分工，隐藏实现细节，提升代码可维护性。\n\n## 1.5 问题拆解与调试建议\n- 如果外部无法访问某成员，优先检查访问修饰符。\n- 框架开发时，优先用 public，需支持继承/重写时用 open。\n- 内部工具类、辅助方法建议用 internal、fileprivate 或 private。\n\n## 1.6 易混淆点与对比\n- **open vs public**：open 可被继承/重写，public 只能访问不能继承。\n- **fileprivate vs private**：fileprivate 跨类型同文件可见，private 仅限当前作用域。\n- **internal** 是默认级别，不写就是 internal。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts & Principles\nSwift provides five access control levels to manage the visibility and accessibility of entities:\n\n1. **open**\n   - Highest level, only for classes and class members.\n   - Can be subclassed/overridden outside the module.\n   - Example:\n     ```swift\n     open class Animal {\n         open func speak() {}\n     }\n     ```\n\n2. **public**\n   - Accessible outside the module, but cannot be subclassed/overridden.\n   - Example:\n     ```swift\n     public class Dog {\n         public func bark() {}\n     }\n     ```\n\n3. **internal** (default)\n   - Accessible only within the same module.\n   - Example:\n     ```swift\n     class Cat {\n         func meow() {}\n     }\n     ```\n\n4. **fileprivate**\n   - Accessible only within the same Swift file.\n   - Example:\n     ```swift\n     fileprivate class Mouse {}\n     fileprivate func hide() {}\n     ```\n\n5. **private**\n   - Accessible only within the enclosing declaration.\n   - Example:\n     ```swift\n     class Lion {\n         private var secret: String = \"Roar\"\n         private func sleep() {}\n     }\n     ```\n\n## 2.2 Why this design?\n- Improves code safety, prevents misuse, and clarifies API boundaries.\n- Facilitates team collaboration and modularization.\n- Supports flexible encapsulation and extension strategies.\n\n## 2.3 Practical Example\n```swift\nopen class BaseViewController: UIViewController {\n    open func setupUI() {}\n}\n\npublic class APIClient {\n    public func request() {}\n}\n\nclass InternalHelper {\n    func doWork() {}\n}\n\nfileprivate class FileHelper {}\n\nclass Demo {\n    private var cache: [String: Any] = [:]\n    private func clearCache() {}\n}\n```\n\n## 2.4 User Experience & Business Value\n- Proper access control makes APIs safer and easier to use, reducing maintenance costs.\n- Hides implementation details, improving maintainability and team collaboration.\n\n## 2.5 Debugging & Troubleshooting\n- If a member is inaccessible, check its access modifier first.\n- Use public for APIs, open for extensible frameworks, internal/fileprivate/private for internal logic.\n\n## 2.6 Key Distinctions\n- **open vs public**: open allows subclassing/overriding, public does not.\n- **fileprivate vs private**: fileprivate is visible within the same file, private only within the enclosing scope.\n- **internal** is the default level.\n","slug":"iOS/Open-Public-Internal关键字","published":1,"updated":"2025-07-08T07:33:20.392Z","comments":1,"layout":"post","photos":[],"_id":"cmd78fh5h00015ek71cap6bxz","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p>Swift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>最高级别，仅适用于类和类成员。</li>\n<li>允许在模块外被继承和重写。</li>\n<li>典型场景：第三方库&#x2F;框架对外暴露可扩展 API。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>允许在模块外访问，但不能被继承或重写。</li>\n<li>适合对外暴露 API，但不希望被扩展。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong>（默认）</p>\n<ul>\n<li>仅在同一模块内可见，模块外不可访问。</li>\n<li>适合项目内部逻辑，默认不写就是 internal。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>仅在当前 Swift 文件内可见。</li>\n<li>适合同文件内多个类型协作，隐藏实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>仅在当前声明作用域（如类&#x2F;结构体&#x2F;扩展）内可见。</li>\n<li>适合封装最细粒度的实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>提高代码安全性，防止外部误用或依赖内部实现。</li>\n<li>明确 API 边界，便于团队协作和模块解耦。</li>\n<li>支持灵活的封装和扩展策略。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FrameworkA</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>合理使用访问控制，API 更安全、易用，减少误用和维护成本。</li>\n<li>便于团队分工，隐藏实现细节，提升代码可维护性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果外部无法访问某成员，优先检查访问修饰符。</li>\n<li>框架开发时，优先用 public，需支持继承&#x2F;重写时用 open。</li>\n<li>内部工具类、辅助方法建议用 internal、fileprivate 或 private。</li>\n</ul>\n<h2 id=\"1-6-易混淆点与对比\"><a href=\"#1-6-易混淆点与对比\" class=\"headerlink\" title=\"1.6 易混淆点与对比\"></a>1.6 易混淆点与对比</h2><ul>\n<li><strong>open vs public</strong>：open 可被继承&#x2F;重写，public 只能访问不能继承。</li>\n<li><strong>fileprivate vs private</strong>：fileprivate 跨类型同文件可见，private 仅限当前作用域。</li>\n<li><strong>internal</strong> 是默认级别，不写就是 internal。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts-Principles\"><a href=\"#2-1-Concepts-Principles\" class=\"headerlink\" title=\"2.1 Concepts &amp; Principles\"></a>2.1 Concepts &amp; Principles</h2><p>Swift provides five access control levels to manage the visibility and accessibility of entities:</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>Highest level, only for classes and class members.</li>\n<li>Can be subclassed&#x2F;overridden outside the module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>Accessible outside the module, but cannot be subclassed&#x2F;overridden.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong> (default)</p>\n<ul>\n<li>Accessible only within the same module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>Accessible only within the same Swift file.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>Accessible only within the enclosing declaration.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Improves code safety, prevents misuse, and clarifies API boundaries.</li>\n<li>Facilitates team collaboration and modularization.</li>\n<li>Supports flexible encapsulation and extension strategies.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Proper access control makes APIs safer and easier to use, reducing maintenance costs.</li>\n<li>Hides implementation details, improving maintainability and team collaboration.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If a member is inaccessible, check its access modifier first.</li>\n<li>Use public for APIs, open for extensible frameworks, internal&#x2F;fileprivate&#x2F;private for internal logic.</li>\n</ul>\n<h2 id=\"2-6-Key-Distinctions\"><a href=\"#2-6-Key-Distinctions\" class=\"headerlink\" title=\"2.6 Key Distinctions\"></a>2.6 Key Distinctions</h2><ul>\n<li><strong>open vs public</strong>: open allows subclassing&#x2F;overriding, public does not.</li>\n<li><strong>fileprivate vs private</strong>: fileprivate is visible within the same file, private only within the enclosing scope.</li>\n<li><strong>internal</strong> is the default level.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><p>Swift 提供五种访问控制修饰符，用于控制代码中实体（类、结构体、枚举、属性、方法等）的可见性和访问范围：</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>最高级别，仅适用于类和类成员。</li>\n<li>允许在模块外被继承和重写。</li>\n<li>典型场景：第三方库&#x2F;框架对外暴露可扩展 API。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>允许在模块外访问，但不能被继承或重写。</li>\n<li>适合对外暴露 API，但不希望被扩展。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong>（默认）</p>\n<ul>\n<li>仅在同一模块内可见，模块外不可访问。</li>\n<li>适合项目内部逻辑，默认不写就是 internal。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>仅在当前 Swift 文件内可见。</li>\n<li>适合同文件内多个类型协作，隐藏实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>仅在当前声明作用域（如类&#x2F;结构体&#x2F;扩展）内可见。</li>\n<li>适合封装最细粒度的实现细节。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要这样设计？\"><a href=\"#1-2-为什么要这样设计？\" class=\"headerlink\" title=\"1.2 为什么要这样设计？\"></a>1.2 为什么要这样设计？</h2><ul>\n<li>提高代码安全性，防止外部误用或依赖内部实现。</li>\n<li>明确 API 边界，便于团队协作和模块解耦。</li>\n<li>支持灵活的封装和扩展策略。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// FrameworkA</span></span><br><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>合理使用访问控制，API 更安全、易用，减少误用和维护成本。</li>\n<li>便于团队分工，隐藏实现细节，提升代码可维护性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果外部无法访问某成员，优先检查访问修饰符。</li>\n<li>框架开发时，优先用 public，需支持继承&#x2F;重写时用 open。</li>\n<li>内部工具类、辅助方法建议用 internal、fileprivate 或 private。</li>\n</ul>\n<h2 id=\"1-6-易混淆点与对比\"><a href=\"#1-6-易混淆点与对比\" class=\"headerlink\" title=\"1.6 易混淆点与对比\"></a>1.6 易混淆点与对比</h2><ul>\n<li><strong>open vs public</strong>：open 可被继承&#x2F;重写，public 只能访问不能继承。</li>\n<li><strong>fileprivate vs private</strong>：fileprivate 跨类型同文件可见，private 仅限当前作用域。</li>\n<li><strong>internal</strong> 是默认级别，不写就是 internal。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts-Principles\"><a href=\"#2-1-Concepts-Principles\" class=\"headerlink\" title=\"2.1 Concepts &amp; Principles\"></a>2.1 Concepts &amp; Principles</h2><p>Swift provides five access control levels to manage the visibility and accessibility of entities:</p>\n<ol>\n<li><p><strong>open</strong></p>\n<ul>\n<li>Highest level, only for classes and class members.</li>\n<li>Can be subclassed&#x2F;overridden outside the module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">speak</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>public</strong></p>\n<ul>\n<li>Accessible outside the module, but cannot be subclassed&#x2F;overridden.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">bark</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>internal</strong> (default)</p>\n<ul>\n<li>Accessible only within the same module.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Cat</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">meow</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>fileprivate</strong></p>\n<ul>\n<li>Accessible only within the same Swift file.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Mouse</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">func</span> <span class=\"title function_\">hide</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>private</strong></p>\n<ul>\n<li>Accessible only within the enclosing declaration.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Lion</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> secret: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Roar&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">sleep</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-this-design\"><a href=\"#2-2-Why-this-design\" class=\"headerlink\" title=\"2.2 Why this design?\"></a>2.2 Why this design?</h2><ul>\n<li>Improves code safety, prevents misuse, and clarifies API boundaries.</li>\n<li>Facilitates team collaboration and modularization.</li>\n<li>Supports flexible encapsulation and extension strategies.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">open</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BaseViewController</span>: <span class=\"title class_ inherited__\">UIViewController</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">open</span> <span class=\"keyword\">func</span> <span class=\"title function_\">setupUI</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">APIClient</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">func</span> <span class=\"title function_\">request</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">InternalHelper</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">doWork</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"keyword\">class</span> <span class=\"title class_\">FileHelper</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> cache: [<span class=\"type\">String</span>: <span class=\"keyword\">Any</span>] <span class=\"operator\">=</span> [:]</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">func</span> <span class=\"title function_\">clearCache</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Proper access control makes APIs safer and easier to use, reducing maintenance costs.</li>\n<li>Hides implementation details, improving maintainability and team collaboration.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If a member is inaccessible, check its access modifier first.</li>\n<li>Use public for APIs, open for extensible frameworks, internal&#x2F;fileprivate&#x2F;private for internal logic.</li>\n</ul>\n<h2 id=\"2-6-Key-Distinctions\"><a href=\"#2-6-Key-Distinctions\" class=\"headerlink\" title=\"2.6 Key Distinctions\"></a>2.6 Key Distinctions</h2><ul>\n<li><strong>open vs public</strong>: open allows subclassing&#x2F;overriding, public does not.</li>\n<li><strong>fileprivate vs private</strong>: fileprivate is visible within the same file, private only within the enclosing scope.</li>\n<li><strong>internal</strong> is the default level.</li>\n</ul>\n"},{"title":"struct 与 class","date":"2025-07-07T16:00:00.000Z","_content":"\n```markdown\n在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢\n# 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别\n\n## 使用 `class` 定义 `ListNode`\n\n```swift\npublic class ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 引用类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。\n\n• 修改一个引用的值会影响所有引用该实例的变量。\n\n\n• 链表操作：\n\n• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，并将其链接到当前节点的`next`属性上。\n\n\n使用`struct`定义`ListNode`\n\n\n```swift\npublic struct ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 值类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上会创建一个新的副本。\n\n• 修改一个副本的值不会影响其他副本。\n\n\n• 链表操作：\n\n• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，但`curr`本身是一个值类型，因此`curr`的修改不会影响原来的链表结构。\n\n\n示例对比\n\n\n使用`class`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 3\n```\n\n\n\n• `node1.next`和`node2`指向同一个实例，因此修改`node2.val`会影响`node1.next?.val`。\n\n\n使用`struct`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 2\n```\n\n\n\n• `node1.next`和`node2`是两个独立的副本，因此修改`node2.val`不会影响`node1.next?.val`。\n\n\n为什么链表通常使用`class`而不是`struct`？\n\n\n• 链表的特性：\n\n• 链表是一种动态数据结构，节点之间通过指针连接。\n\n• 引用类型（`class`）更适合这种场景，因为引用类型允许节点之间共享相同的实例。\n\n\n• 性能和内存管理：\n\n• 使用`class`时，节点的连接和操作只需要调整指针，而不需要复制整个对象。\n\n• 使用`struct`时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。\n\n\n• 链表操作的复杂性：\n\n• 在链表操作中，经常需要修改节点的`next`指针。\n\n• 使用`class`时，这些操作是直接的，因为`next`指针指向的是同一个实例。\n\n• 使用`struct`时，每次修改`next`指针都需要创建新的副本，这会使代码变得复杂且难以维护。\n\n\n总结\n\n• 使用`class`：\n\n• 适合链表这种需要通过指针连接和操作的动态数据结构。\n\n• 引用类型允许节点之间共享相同的实例，操作效率高。\n\n\n• 使用`struct`：\n\n• 适合值类型，例如简单的数据结构或不可变对象。\n\n• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。\n\n因此，在实现链表时，推荐使用`class`而不是`struct`。\n","source":"_posts/iOS/classVStruct.md","raw":"---\ntitle: struct 与 class\ndate: 2025-07-08\ncategories:\n  - iOS\n---\n\n```markdown\n在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢\n# 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别\n\n## 使用 `class` 定义 `ListNode`\n\n```swift\npublic class ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 引用类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。\n\n• 修改一个引用的值会影响所有引用该实例的变量。\n\n\n• 链表操作：\n\n• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，并将其链接到当前节点的`next`属性上。\n\n\n使用`struct`定义`ListNode`\n\n\n```swift\npublic struct ListNode {\n    public var val: Int\n    public var next: ListNode?\n    public init(_ val: Int) { self.val = val; self.next = nil }\n}\n```\n\n\n\n特点\n\n• 值类型：\n\n• 当你将一个`ListNode`实例赋值给另一个变量时，实际上会创建一个新的副本。\n\n• 修改一个副本的值不会影响其他副本。\n\n\n• 链表操作：\n\n• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。\n\n• 例如，`curr.next = ListNode(sum % 10)`会创建一个新的节点，但`curr`本身是一个值类型，因此`curr`的修改不会影响原来的链表结构。\n\n\n示例对比\n\n\n使用`class`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 3\n```\n\n\n\n• `node1.next`和`node2`指向同一个实例，因此修改`node2.val`会影响`node1.next?.val`。\n\n\n使用`struct`的链表操作\n\n\n```swift\nvar node1 = ListNode(1)\nvar node2 = ListNode(2)\nnode1.next = node2\n\nnode2.val = 3\nprint(node1.next?.val ?? 0) // 输出 2\n```\n\n\n\n• `node1.next`和`node2`是两个独立的副本，因此修改`node2.val`不会影响`node1.next?.val`。\n\n\n为什么链表通常使用`class`而不是`struct`？\n\n\n• 链表的特性：\n\n• 链表是一种动态数据结构，节点之间通过指针连接。\n\n• 引用类型（`class`）更适合这种场景，因为引用类型允许节点之间共享相同的实例。\n\n\n• 性能和内存管理：\n\n• 使用`class`时，节点的连接和操作只需要调整指针，而不需要复制整个对象。\n\n• 使用`struct`时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。\n\n\n• 链表操作的复杂性：\n\n• 在链表操作中，经常需要修改节点的`next`指针。\n\n• 使用`class`时，这些操作是直接的，因为`next`指针指向的是同一个实例。\n\n• 使用`struct`时，每次修改`next`指针都需要创建新的副本，这会使代码变得复杂且难以维护。\n\n\n总结\n\n• 使用`class`：\n\n• 适合链表这种需要通过指针连接和操作的动态数据结构。\n\n• 引用类型允许节点之间共享相同的实例，操作效率高。\n\n\n• 使用`struct`：\n\n• 适合值类型，例如简单的数据结构或不可变对象。\n\n• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。\n\n因此，在实现链表时，推荐使用`class`而不是`struct`。\n","slug":"iOS/classVStruct","published":1,"updated":"2025-07-08T07:26:39.896Z","comments":1,"layout":"post","photos":[],"_id":"cmd78fh5j00035ek7gru20pwv","content":"<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢</span><br><span class=\"line\"><span class=\"section\"># 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 使用 `class` 定义 `ListNode`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">```swift</span></span><br><span class=\"line\"><span class=\"code\">public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"code\">    public var val: Int</span></span><br><span class=\"line\"><span class=\"code\">    public var next: ListNode?</span></span><br><span class=\"line\"><span class=\"code\">    public init(_ val: Int) &#123; self.val = val; self.next = nil &#125;</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 引用类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。</p>\n<p>• 修改一个引用的值会影响所有引用该实例的变量。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，并将其链接到当前节点的<code>next</code>属性上。</p>\n<p>使用<code>struct</code>定义<code>ListNode</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> val: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> next: <span class=\"type\">ListNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> <span class=\"params\">val</span>: <span class=\"type\">Int</span>) &#123; <span class=\"keyword\">self</span>.val <span class=\"operator\">=</span> val; <span class=\"keyword\">self</span>.next <span class=\"operator\">=</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 值类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上会创建一个新的副本。</p>\n<p>• 修改一个副本的值不会影响其他副本。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，但<code>curr</code>本身是一个值类型，因此<code>curr</code>的修改不会影响原来的链表结构。</p>\n<p>示例对比</p>\n<p>使用<code>class</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>指向同一个实例，因此修改<code>node2.val</code>会影响<code>node1.next?.val</code>。</p>\n<p>使用<code>struct</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>是两个独立的副本，因此修改<code>node2.val</code>不会影响<code>node1.next?.val</code>。</p>\n<p>为什么链表通常使用<code>class</code>而不是<code>struct</code>？</p>\n<p>• 链表的特性：</p>\n<p>• 链表是一种动态数据结构，节点之间通过指针连接。</p>\n<p>• 引用类型（<code>class</code>）更适合这种场景，因为引用类型允许节点之间共享相同的实例。</p>\n<p>• 性能和内存管理：</p>\n<p>• 使用<code>class</code>时，节点的连接和操作只需要调整指针，而不需要复制整个对象。</p>\n<p>• 使用<code>struct</code>时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。</p>\n<p>• 链表操作的复杂性：</p>\n<p>• 在链表操作中，经常需要修改节点的<code>next</code>指针。</p>\n<p>• 使用<code>class</code>时，这些操作是直接的，因为<code>next</code>指针指向的是同一个实例。</p>\n<p>• 使用<code>struct</code>时，每次修改<code>next</code>指针都需要创建新的副本，这会使代码变得复杂且难以维护。</p>\n<p>总结</p>\n<p>• 使用<code>class</code>：</p>\n<p>• 适合链表这种需要通过指针连接和操作的动态数据结构。</p>\n<p>• 引用类型允许节点之间共享相同的实例，操作效率高。</p>\n<p>• 使用<code>struct</code>：</p>\n<p>• 适合值类型，例如简单的数据结构或不可变对象。</p>\n<p>• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。</p>\n<p>因此，在实现链表时，推荐使用<code>class</code>而不是<code>struct</code>。</p>\n","excerpt":"","more":"<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在 Swift 中，类（  class  ）是引用类型，这意味着当你将一个类实例赋值给一个变量时，实际上只是复制了对同一个实例的引用，而不是复制整个对象。 如果用struct 来修饰ListNode 呢</span><br><span class=\"line\"><span class=\"section\"># 在 Swift 中使用 `struct` 与 `class` 定义链表节点的区别</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## 使用 `class` 定义 `ListNode`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"code\">```swift</span></span><br><span class=\"line\"><span class=\"code\">public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"code\">    public var val: Int</span></span><br><span class=\"line\"><span class=\"code\">    public var next: ListNode?</span></span><br><span class=\"line\"><span class=\"code\">    public init(_ val: Int) &#123; self.val = val; self.next = nil &#125;</span></span><br><span class=\"line\"><span class=\"code\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 引用类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上只是复制了对同一个实例的引用。</p>\n<p>• 修改一个引用的值会影响所有引用该实例的变量。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，引用类型非常适合，因为链表的节点通常需要通过指针来连接和操作。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，并将其链接到当前节点的<code>next</code>属性上。</p>\n<p>使用<code>struct</code>定义<code>ListNode</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> val: <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> next: <span class=\"type\">ListNode</span>?</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(<span class=\"keyword\">_</span> <span class=\"params\">val</span>: <span class=\"type\">Int</span>) &#123; <span class=\"keyword\">self</span>.val <span class=\"operator\">=</span> val; <span class=\"keyword\">self</span>.next <span class=\"operator\">=</span> <span class=\"literal\">nil</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>特点</p>\n<p>• 值类型：</p>\n<p>• 当你将一个<code>ListNode</code>实例赋值给另一个变量时，实际上会创建一个新的副本。</p>\n<p>• 修改一个副本的值不会影响其他副本。</p>\n<p>• 链表操作：</p>\n<p>• 在链表操作中，值类型可能会导致一些问题，因为每次赋值都会创建一个新的副本。</p>\n<p>• 例如，<code>curr.next = ListNode(sum % 10)</code>会创建一个新的节点，但<code>curr</code>本身是一个值类型，因此<code>curr</code>的修改不会影响原来的链表结构。</p>\n<p>示例对比</p>\n<p>使用<code>class</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>指向同一个实例，因此修改<code>node2.val</code>会影响<code>node1.next?.val</code>。</p>\n<p>使用<code>struct</code>的链表操作</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> node1 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> node2 <span class=\"operator\">=</span> <span class=\"type\">ListNode</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">node1.next <span class=\"operator\">=</span> node2</span><br><span class=\"line\"></span><br><span class=\"line\">node2.val <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(node1.next<span class=\"operator\">?</span>.val <span class=\"operator\">??</span> <span class=\"number\">0</span>) <span class=\"comment\">// 输出 2</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>• <code>node1.next</code>和<code>node2</code>是两个独立的副本，因此修改<code>node2.val</code>不会影响<code>node1.next?.val</code>。</p>\n<p>为什么链表通常使用<code>class</code>而不是<code>struct</code>？</p>\n<p>• 链表的特性：</p>\n<p>• 链表是一种动态数据结构，节点之间通过指针连接。</p>\n<p>• 引用类型（<code>class</code>）更适合这种场景，因为引用类型允许节点之间共享相同的实例。</p>\n<p>• 性能和内存管理：</p>\n<p>• 使用<code>class</code>时，节点的连接和操作只需要调整指针，而不需要复制整个对象。</p>\n<p>• 使用<code>struct</code>时，每次赋值都会创建一个新的副本，这可能导致不必要的内存开销和性能问题。</p>\n<p>• 链表操作的复杂性：</p>\n<p>• 在链表操作中，经常需要修改节点的<code>next</code>指针。</p>\n<p>• 使用<code>class</code>时，这些操作是直接的，因为<code>next</code>指针指向的是同一个实例。</p>\n<p>• 使用<code>struct</code>时，每次修改<code>next</code>指针都需要创建新的副本，这会使代码变得复杂且难以维护。</p>\n<p>总结</p>\n<p>• 使用<code>class</code>：</p>\n<p>• 适合链表这种需要通过指针连接和操作的动态数据结构。</p>\n<p>• 引用类型允许节点之间共享相同的实例，操作效率高。</p>\n<p>• 使用<code>struct</code>：</p>\n<p>• 适合值类型，例如简单的数据结构或不可变对象。</p>\n<p>• 在链表操作中，值类型会导致不必要的内存开销和复杂的代码逻辑。</p>\n<p>因此，在实现链表时，推荐使用<code>class</code>而不是<code>struct</code>。</p>\n"},{"title":"closure闭包与OC中block的区别","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **闭包（Closure）定义**\n   - 闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。\n   - Swift 中的函数本质上也是特殊的闭包。\n   - 闭包可作为变量、参数、返回值传递和使用。\n\n2. **闭包的语法**\n   - 基本语法：\n     ```swift\n     let closure = { (参数) -> 返回类型 in\n         // 代码体\n     }\n     ```\n   - 支持类型推断、参数简写、尾随闭包等特性。\n\n## 1.2 为什么要用闭包？\n- 提升代码复用性和灵活性，支持函数式编程。\n- 可作为回调、异步处理、事件响应等，简化代码结构。\n- 捕获上下文变量，便于状态管理和数据流传递。\n\n## 1.3 实际项目使用场景\n1. **异步回调**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       // 网络请求结束后回调\n       completion(data)\n   }\n   ```\n2. **集合操作**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 } // 闭包作为参数\n   ```\n3. **动画、事件响应**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **自定义排序、过滤**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 1.4 与 Objective-C 中 Block 的区别\n1. **语法与类型系统**\n   - Swift 闭包语法更简洁，类型推断更强。\n   - Block 语法繁琐，需显式声明参数和返回值类型。\n2. **内存管理**\n   - Swift 闭包默认捕获变量为强引用，需用 `[weak self]`/`[unowned self]` 避免循环引用。\n   - OC Block 分为全局、栈、堆三种类型，需用 `__weak`/`__block` 修饰符管理引用。\n3. **捕获机制**\n   - Swift 闭包自动捕获上下文变量。\n   - OC Block 需用 `__block` 修饰变量才能在 Block 内修改。\n4. **语法特性**\n   - Swift 支持尾随闭包、参数简写、自动推断。\n   - OC Block 语法固定，灵活性较低。\n\n## 1.5 用户体验与业务价值\n- 闭包让 API 更加简洁、易用，提升开发效率。\n- 便于实现响应式、链式调用，提升产品交互体验。\n- 合理管理闭包内存，避免内存泄漏，保障 App 稳定性。\n\n## 1.6 问题拆解与调试建议\n- 遇到内存泄漏，优先排查闭包的循环引用，使用 `[weak self]` 或 `[unowned self]`。\n- 调试异步回调时，关注闭包是否正确捕获和释放上下文。\n- 对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。\n\n## 1.7 易混淆概念区分\n- **闭包 vs Block**：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。\n- **逃逸闭包（@escaping）**：闭包在函数返回后才被调用，需显式标记。\n- **自动闭包（@autoclosure）**：延迟求值，常用于断言、短路等场景。\n\n---\n\n# 2. English Answer\n\n## 2.1 What is a Closure?\n- A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.\n- Functions in Swift are special cases of closures.\n- Closures can be assigned to variables, passed as parameters, and returned from functions.\n\n## 2.2 Why use closures?\n- Improve code reusability and flexibility, support functional programming.\n- Used for callbacks, async handling, event response, etc.\n- Capture context for state management and data flow.\n\n## 2.3 Practical Usage Scenarios\n1. **Async Callbacks**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       completion(data)\n   }\n   ```\n2. **Collection Operations**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 }\n   ```\n3. **Animation/Event Handling**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **Custom Sorting/Filtering**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 2.4 Difference from Objective-C Block\n1. **Syntax & Type System**\n   - Swift closures are more concise, with strong type inference.\n   - Block syntax is verbose, requires explicit type declaration.\n2. **Memory Management**\n   - Swift closures capture variables strongly by default; use `[weak self]`/`[unowned self]` to avoid retain cycles.\n   - OC Blocks have global, stack, and heap types; use `__weak`/`__block` for reference management.\n3. **Capture Mechanism**\n   - Swift closures automatically capture context variables.\n   - OC Blocks require `__block` to modify captured variables.\n4. **Syntax Features**\n   - Swift supports trailing closures, shorthand arguments, and type inference.\n   - OC Block syntax is fixed and less flexible.\n\n## 2.5 User Experience & Business Value\n- Closures make APIs cleaner and easier to use, improving development efficiency.\n- Enable reactive and chainable calls, enhancing product interactivity.\n- Proper memory management avoids leaks and ensures app stability.\n\n## 2.6 Debugging & Troubleshooting\n- For memory leaks, check for retain cycles in closures and use `[weak self]` or `[unowned self]`.\n- When debugging async callbacks, ensure closures capture and release context correctly.\n- Compare Block and closure capture/release mechanisms to choose the best fit for your scenario.\n\n## 2.7 Related Concepts\n- **Closure vs Block**: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C's function object implementation.\n- **Escaping Closures (@escaping)**: Closure is called after the function returns, must be marked explicitly.\n- **Autoclosure (@autoclosure)**: Delays evaluation, often used in assertions and short-circuiting.\n","source":"_posts/iOS/closure闭包block的区别.md","raw":"---\ntitle: closure闭包与OC中block的区别\ndate: 2025-07-08\ncategories:\n  - iOS\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **闭包（Closure）定义**\n   - 闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。\n   - Swift 中的函数本质上也是特殊的闭包。\n   - 闭包可作为变量、参数、返回值传递和使用。\n\n2. **闭包的语法**\n   - 基本语法：\n     ```swift\n     let closure = { (参数) -> 返回类型 in\n         // 代码体\n     }\n     ```\n   - 支持类型推断、参数简写、尾随闭包等特性。\n\n## 1.2 为什么要用闭包？\n- 提升代码复用性和灵活性，支持函数式编程。\n- 可作为回调、异步处理、事件响应等，简化代码结构。\n- 捕获上下文变量，便于状态管理和数据流传递。\n\n## 1.3 实际项目使用场景\n1. **异步回调**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       // 网络请求结束后回调\n       completion(data)\n   }\n   ```\n2. **集合操作**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 } // 闭包作为参数\n   ```\n3. **动画、事件响应**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **自定义排序、过滤**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 1.4 与 Objective-C 中 Block 的区别\n1. **语法与类型系统**\n   - Swift 闭包语法更简洁，类型推断更强。\n   - Block 语法繁琐，需显式声明参数和返回值类型。\n2. **内存管理**\n   - Swift 闭包默认捕获变量为强引用，需用 `[weak self]`/`[unowned self]` 避免循环引用。\n   - OC Block 分为全局、栈、堆三种类型，需用 `__weak`/`__block` 修饰符管理引用。\n3. **捕获机制**\n   - Swift 闭包自动捕获上下文变量。\n   - OC Block 需用 `__block` 修饰变量才能在 Block 内修改。\n4. **语法特性**\n   - Swift 支持尾随闭包、参数简写、自动推断。\n   - OC Block 语法固定，灵活性较低。\n\n## 1.5 用户体验与业务价值\n- 闭包让 API 更加简洁、易用，提升开发效率。\n- 便于实现响应式、链式调用，提升产品交互体验。\n- 合理管理闭包内存，避免内存泄漏，保障 App 稳定性。\n\n## 1.6 问题拆解与调试建议\n- 遇到内存泄漏，优先排查闭包的循环引用，使用 `[weak self]` 或 `[unowned self]`。\n- 调试异步回调时，关注闭包是否正确捕获和释放上下文。\n- 对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。\n\n## 1.7 易混淆概念区分\n- **闭包 vs Block**：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。\n- **逃逸闭包（@escaping）**：闭包在函数返回后才被调用，需显式标记。\n- **自动闭包（@autoclosure）**：延迟求值，常用于断言、短路等场景。\n\n---\n\n# 2. English Answer\n\n## 2.1 What is a Closure?\n- A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.\n- Functions in Swift are special cases of closures.\n- Closures can be assigned to variables, passed as parameters, and returned from functions.\n\n## 2.2 Why use closures?\n- Improve code reusability and flexibility, support functional programming.\n- Used for callbacks, async handling, event response, etc.\n- Capture context for state management and data flow.\n\n## 2.3 Practical Usage Scenarios\n1. **Async Callbacks**\n   ```swift\n   func fetchData(completion: @escaping (Data?) -> Void) {\n       completion(data)\n   }\n   ```\n2. **Collection Operations**\n   ```swift\n   let numbers = [1, 2, 3]\n   let squares = numbers.map { $0 * $0 }\n   ```\n3. **Animation/Event Handling**\n   ```swift\n   UIView.animate(withDuration: 0.3) {\n       view.alpha = 0\n   }\n   ```\n4. **Custom Sorting/Filtering**\n   ```swift\n   let sorted = names.sorted { $0.count < $1.count }\n   ```\n\n## 2.4 Difference from Objective-C Block\n1. **Syntax & Type System**\n   - Swift closures are more concise, with strong type inference.\n   - Block syntax is verbose, requires explicit type declaration.\n2. **Memory Management**\n   - Swift closures capture variables strongly by default; use `[weak self]`/`[unowned self]` to avoid retain cycles.\n   - OC Blocks have global, stack, and heap types; use `__weak`/`__block` for reference management.\n3. **Capture Mechanism**\n   - Swift closures automatically capture context variables.\n   - OC Blocks require `__block` to modify captured variables.\n4. **Syntax Features**\n   - Swift supports trailing closures, shorthand arguments, and type inference.\n   - OC Block syntax is fixed and less flexible.\n\n## 2.5 User Experience & Business Value\n- Closures make APIs cleaner and easier to use, improving development efficiency.\n- Enable reactive and chainable calls, enhancing product interactivity.\n- Proper memory management avoids leaks and ensures app stability.\n\n## 2.6 Debugging & Troubleshooting\n- For memory leaks, check for retain cycles in closures and use `[weak self]` or `[unowned self]`.\n- When debugging async callbacks, ensure closures capture and release context correctly.\n- Compare Block and closure capture/release mechanisms to choose the best fit for your scenario.\n\n## 2.7 Related Concepts\n- **Closure vs Block**: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C's function object implementation.\n- **Escaping Closures (@escaping)**: Closure is called after the function returns, must be marked explicitly.\n- **Autoclosure (@autoclosure)**: Delays evaluation, often used in assertions and short-circuiting.\n","slug":"iOS/closure闭包block的区别","published":1,"updated":"2025-07-08T07:26:20.365Z","comments":1,"layout":"post","photos":[],"_id":"cmd78fh5k00065ek7emkk37fb","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>闭包（Closure）定义</strong></p>\n<ul>\n<li>闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。</li>\n<li>Swift 中的函数本质上也是特殊的闭包。</li>\n<li>闭包可作为变量、参数、返回值传递和使用。</li>\n</ul>\n</li>\n<li><p><strong>闭包的语法</strong></p>\n<ul>\n<li>基本语法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> closure <span class=\"operator\">=</span> &#123; (参数) -&gt; 返回类型 <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// 代码体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>支持类型推断、参数简写、尾随闭包等特性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要用闭包？\"><a href=\"#1-2-为什么要用闭包？\" class=\"headerlink\" title=\"1.2 为什么要用闭包？\"></a>1.2 为什么要用闭包？</h2><ul>\n<li>提升代码复用性和灵活性，支持函数式编程。</li>\n<li>可作为回调、异步处理、事件响应等，简化代码结构。</li>\n<li>捕获上下文变量，便于状态管理和数据流传递。</li>\n</ul>\n<h2 id=\"1-3-实际项目使用场景\"><a href=\"#1-3-实际项目使用场景\" class=\"headerlink\" title=\"1.3 实际项目使用场景\"></a>1.3 实际项目使用场景</h2><ol>\n<li><strong>异步回调</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求结束后回调</span></span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>集合操作</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125; <span class=\"comment\">// 闭包作为参数</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>动画、事件响应</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>自定义排序、过滤</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-4-与-Objective-C-中-Block-的区别\"><a href=\"#1-4-与-Objective-C-中-Block-的区别\" class=\"headerlink\" title=\"1.4 与 Objective-C 中 Block 的区别\"></a>1.4 与 Objective-C 中 Block 的区别</h2><ol>\n<li><strong>语法与类型系统</strong><ul>\n<li>Swift 闭包语法更简洁，类型推断更强。</li>\n<li>Block 语法繁琐，需显式声明参数和返回值类型。</li>\n</ul>\n</li>\n<li><strong>内存管理</strong><ul>\n<li>Swift 闭包默认捕获变量为强引用，需用 <code>[weak self]</code>&#x2F;<code>[unowned self]</code> 避免循环引用。</li>\n<li>OC Block 分为全局、栈、堆三种类型，需用 <code>__weak</code>&#x2F;<code>__block</code> 修饰符管理引用。</li>\n</ul>\n</li>\n<li><strong>捕获机制</strong><ul>\n<li>Swift 闭包自动捕获上下文变量。</li>\n<li>OC Block 需用 <code>__block</code> 修饰变量才能在 Block 内修改。</li>\n</ul>\n</li>\n<li><strong>语法特性</strong><ul>\n<li>Swift 支持尾随闭包、参数简写、自动推断。</li>\n<li>OC Block 语法固定，灵活性较低。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-5-用户体验与业务价值\"><a href=\"#1-5-用户体验与业务价值\" class=\"headerlink\" title=\"1.5 用户体验与业务价值\"></a>1.5 用户体验与业务价值</h2><ul>\n<li>闭包让 API 更加简洁、易用，提升开发效率。</li>\n<li>便于实现响应式、链式调用，提升产品交互体验。</li>\n<li>合理管理闭包内存，避免内存泄漏，保障 App 稳定性。</li>\n</ul>\n<h2 id=\"1-6-问题拆解与调试建议\"><a href=\"#1-6-问题拆解与调试建议\" class=\"headerlink\" title=\"1.6 问题拆解与调试建议\"></a>1.6 问题拆解与调试建议</h2><ul>\n<li>遇到内存泄漏，优先排查闭包的循环引用，使用 <code>[weak self]</code> 或 <code>[unowned self]</code>。</li>\n<li>调试异步回调时，关注闭包是否正确捕获和释放上下文。</li>\n<li>对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。</li>\n</ul>\n<h2 id=\"1-7-易混淆概念区分\"><a href=\"#1-7-易混淆概念区分\" class=\"headerlink\" title=\"1.7 易混淆概念区分\"></a>1.7 易混淆概念区分</h2><ul>\n<li><strong>闭包 vs Block</strong>：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。</li>\n<li><strong>逃逸闭包（@escaping）</strong>：闭包在函数返回后才被调用，需显式标记。</li>\n<li><strong>自动闭包（@autoclosure）</strong>：延迟求值，常用于断言、短路等场景。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-What-is-a-Closure\"><a href=\"#2-1-What-is-a-Closure\" class=\"headerlink\" title=\"2.1 What is a Closure?\"></a>2.1 What is a Closure?</h2><ul>\n<li>A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.</li>\n<li>Functions in Swift are special cases of closures.</li>\n<li>Closures can be assigned to variables, passed as parameters, and returned from functions.</li>\n</ul>\n<h2 id=\"2-2-Why-use-closures\"><a href=\"#2-2-Why-use-closures\" class=\"headerlink\" title=\"2.2 Why use closures?\"></a>2.2 Why use closures?</h2><ul>\n<li>Improve code reusability and flexibility, support functional programming.</li>\n<li>Used for callbacks, async handling, event response, etc.</li>\n<li>Capture context for state management and data flow.</li>\n</ul>\n<h2 id=\"2-3-Practical-Usage-Scenarios\"><a href=\"#2-3-Practical-Usage-Scenarios\" class=\"headerlink\" title=\"2.3 Practical Usage Scenarios\"></a>2.3 Practical Usage Scenarios</h2><ol>\n<li><strong>Async Callbacks</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Collection Operations</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Animation&#x2F;Event Handling</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Custom Sorting&#x2F;Filtering</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-4-Difference-from-Objective-C-Block\"><a href=\"#2-4-Difference-from-Objective-C-Block\" class=\"headerlink\" title=\"2.4 Difference from Objective-C Block\"></a>2.4 Difference from Objective-C Block</h2><ol>\n<li><strong>Syntax &amp; Type System</strong><ul>\n<li>Swift closures are more concise, with strong type inference.</li>\n<li>Block syntax is verbose, requires explicit type declaration.</li>\n</ul>\n</li>\n<li><strong>Memory Management</strong><ul>\n<li>Swift closures capture variables strongly by default; use <code>[weak self]</code>&#x2F;<code>[unowned self]</code> to avoid retain cycles.</li>\n<li>OC Blocks have global, stack, and heap types; use <code>__weak</code>&#x2F;<code>__block</code> for reference management.</li>\n</ul>\n</li>\n<li><strong>Capture Mechanism</strong><ul>\n<li>Swift closures automatically capture context variables.</li>\n<li>OC Blocks require <code>__block</code> to modify captured variables.</li>\n</ul>\n</li>\n<li><strong>Syntax Features</strong><ul>\n<li>Swift supports trailing closures, shorthand arguments, and type inference.</li>\n<li>OC Block syntax is fixed and less flexible.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-5-User-Experience-Business-Value\"><a href=\"#2-5-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.5 User Experience &amp; Business Value\"></a>2.5 User Experience &amp; Business Value</h2><ul>\n<li>Closures make APIs cleaner and easier to use, improving development efficiency.</li>\n<li>Enable reactive and chainable calls, enhancing product interactivity.</li>\n<li>Proper memory management avoids leaks and ensures app stability.</li>\n</ul>\n<h2 id=\"2-6-Debugging-Troubleshooting\"><a href=\"#2-6-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.6 Debugging &amp; Troubleshooting\"></a>2.6 Debugging &amp; Troubleshooting</h2><ul>\n<li>For memory leaks, check for retain cycles in closures and use <code>[weak self]</code> or <code>[unowned self]</code>.</li>\n<li>When debugging async callbacks, ensure closures capture and release context correctly.</li>\n<li>Compare Block and closure capture&#x2F;release mechanisms to choose the best fit for your scenario.</li>\n</ul>\n<h2 id=\"2-7-Related-Concepts\"><a href=\"#2-7-Related-Concepts\" class=\"headerlink\" title=\"2.7 Related Concepts\"></a>2.7 Related Concepts</h2><ul>\n<li><strong>Closure vs Block</strong>: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C’s function object implementation.</li>\n<li><strong>Escaping Closures (@escaping)</strong>: Closure is called after the function returns, must be marked explicitly.</li>\n<li><strong>Autoclosure (@autoclosure)</strong>: Delays evaluation, often used in assertions and short-circuiting.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>闭包（Closure）定义</strong></p>\n<ul>\n<li>闭包是可以捕获和存储其所在作用域内变量和常量的自包含代码块。</li>\n<li>Swift 中的函数本质上也是特殊的闭包。</li>\n<li>闭包可作为变量、参数、返回值传递和使用。</li>\n</ul>\n</li>\n<li><p><strong>闭包的语法</strong></p>\n<ul>\n<li>基本语法：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> closure <span class=\"operator\">=</span> &#123; (参数) -&gt; 返回类型 <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"comment\">// 代码体</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>支持类型推断、参数简写、尾随闭包等特性。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要用闭包？\"><a href=\"#1-2-为什么要用闭包？\" class=\"headerlink\" title=\"1.2 为什么要用闭包？\"></a>1.2 为什么要用闭包？</h2><ul>\n<li>提升代码复用性和灵活性，支持函数式编程。</li>\n<li>可作为回调、异步处理、事件响应等，简化代码结构。</li>\n<li>捕获上下文变量，便于状态管理和数据流传递。</li>\n</ul>\n<h2 id=\"1-3-实际项目使用场景\"><a href=\"#1-3-实际项目使用场景\" class=\"headerlink\" title=\"1.3 实际项目使用场景\"></a>1.3 实际项目使用场景</h2><ol>\n<li><strong>异步回调</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求结束后回调</span></span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>集合操作</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125; <span class=\"comment\">// 闭包作为参数</span></span><br></pre></td></tr></table></figure></li>\n<li><strong>动画、事件响应</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>自定义排序、过滤</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"1-4-与-Objective-C-中-Block-的区别\"><a href=\"#1-4-与-Objective-C-中-Block-的区别\" class=\"headerlink\" title=\"1.4 与 Objective-C 中 Block 的区别\"></a>1.4 与 Objective-C 中 Block 的区别</h2><ol>\n<li><strong>语法与类型系统</strong><ul>\n<li>Swift 闭包语法更简洁，类型推断更强。</li>\n<li>Block 语法繁琐，需显式声明参数和返回值类型。</li>\n</ul>\n</li>\n<li><strong>内存管理</strong><ul>\n<li>Swift 闭包默认捕获变量为强引用，需用 <code>[weak self]</code>&#x2F;<code>[unowned self]</code> 避免循环引用。</li>\n<li>OC Block 分为全局、栈、堆三种类型，需用 <code>__weak</code>&#x2F;<code>__block</code> 修饰符管理引用。</li>\n</ul>\n</li>\n<li><strong>捕获机制</strong><ul>\n<li>Swift 闭包自动捕获上下文变量。</li>\n<li>OC Block 需用 <code>__block</code> 修饰变量才能在 Block 内修改。</li>\n</ul>\n</li>\n<li><strong>语法特性</strong><ul>\n<li>Swift 支持尾随闭包、参数简写、自动推断。</li>\n<li>OC Block 语法固定，灵活性较低。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-5-用户体验与业务价值\"><a href=\"#1-5-用户体验与业务价值\" class=\"headerlink\" title=\"1.5 用户体验与业务价值\"></a>1.5 用户体验与业务价值</h2><ul>\n<li>闭包让 API 更加简洁、易用，提升开发效率。</li>\n<li>便于实现响应式、链式调用，提升产品交互体验。</li>\n<li>合理管理闭包内存，避免内存泄漏，保障 App 稳定性。</li>\n</ul>\n<h2 id=\"1-6-问题拆解与调试建议\"><a href=\"#1-6-问题拆解与调试建议\" class=\"headerlink\" title=\"1.6 问题拆解与调试建议\"></a>1.6 问题拆解与调试建议</h2><ul>\n<li>遇到内存泄漏，优先排查闭包的循环引用，使用 <code>[weak self]</code> 或 <code>[unowned self]</code>。</li>\n<li>调试异步回调时，关注闭包是否正确捕获和释放上下文。</li>\n<li>对比 Block 和闭包的捕获、释放机制，选择最适合业务场景的实现。</li>\n</ul>\n<h2 id=\"1-7-易混淆概念区分\"><a href=\"#1-7-易混淆概念区分\" class=\"headerlink\" title=\"1.7 易混淆概念区分\"></a>1.7 易混淆概念区分</h2><ul>\n<li><strong>闭包 vs Block</strong>：闭包是 Swift 的一等公民，语法更现代，Block 是 OC 的函数对象实现。</li>\n<li><strong>逃逸闭包（@escaping）</strong>：闭包在函数返回后才被调用，需显式标记。</li>\n<li><strong>自动闭包（@autoclosure）</strong>：延迟求值，常用于断言、短路等场景。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-What-is-a-Closure\"><a href=\"#2-1-What-is-a-Closure\" class=\"headerlink\" title=\"2.1 What is a Closure?\"></a>2.1 What is a Closure?</h2><ul>\n<li>A closure is a self-contained block of code that can capture and store references to variables and constants from its surrounding context.</li>\n<li>Functions in Swift are special cases of closures.</li>\n<li>Closures can be assigned to variables, passed as parameters, and returned from functions.</li>\n</ul>\n<h2 id=\"2-2-Why-use-closures\"><a href=\"#2-2-Why-use-closures\" class=\"headerlink\" title=\"2.2 Why use closures?\"></a>2.2 Why use closures?</h2><ul>\n<li>Improve code reusability and flexibility, support functional programming.</li>\n<li>Used for callbacks, async handling, event response, etc.</li>\n<li>Capture context for state management and data flow.</li>\n</ul>\n<h2 id=\"2-3-Practical-Usage-Scenarios\"><a href=\"#2-3-Practical-Usage-Scenarios\" class=\"headerlink\" title=\"2.3 Practical Usage Scenarios\"></a>2.3 Practical Usage Scenarios</h2><ol>\n<li><strong>Async Callbacks</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>(<span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Data</span>?) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    completion(data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Collection Operations</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares <span class=\"operator\">=</span> numbers.map &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"variable\">$0</span> &#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Animation&#x2F;Event Handling</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">    view.alpha <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><strong>Custom Sorting&#x2F;Filtering</strong><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sorted <span class=\"operator\">=</span> names.sorted &#123; <span class=\"variable\">$0</span>.count <span class=\"operator\">&lt;</span> <span class=\"variable\">$1</span>.count &#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"2-4-Difference-from-Objective-C-Block\"><a href=\"#2-4-Difference-from-Objective-C-Block\" class=\"headerlink\" title=\"2.4 Difference from Objective-C Block\"></a>2.4 Difference from Objective-C Block</h2><ol>\n<li><strong>Syntax &amp; Type System</strong><ul>\n<li>Swift closures are more concise, with strong type inference.</li>\n<li>Block syntax is verbose, requires explicit type declaration.</li>\n</ul>\n</li>\n<li><strong>Memory Management</strong><ul>\n<li>Swift closures capture variables strongly by default; use <code>[weak self]</code>&#x2F;<code>[unowned self]</code> to avoid retain cycles.</li>\n<li>OC Blocks have global, stack, and heap types; use <code>__weak</code>&#x2F;<code>__block</code> for reference management.</li>\n</ul>\n</li>\n<li><strong>Capture Mechanism</strong><ul>\n<li>Swift closures automatically capture context variables.</li>\n<li>OC Blocks require <code>__block</code> to modify captured variables.</li>\n</ul>\n</li>\n<li><strong>Syntax Features</strong><ul>\n<li>Swift supports trailing closures, shorthand arguments, and type inference.</li>\n<li>OC Block syntax is fixed and less flexible.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-5-User-Experience-Business-Value\"><a href=\"#2-5-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.5 User Experience &amp; Business Value\"></a>2.5 User Experience &amp; Business Value</h2><ul>\n<li>Closures make APIs cleaner and easier to use, improving development efficiency.</li>\n<li>Enable reactive and chainable calls, enhancing product interactivity.</li>\n<li>Proper memory management avoids leaks and ensures app stability.</li>\n</ul>\n<h2 id=\"2-6-Debugging-Troubleshooting\"><a href=\"#2-6-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.6 Debugging &amp; Troubleshooting\"></a>2.6 Debugging &amp; Troubleshooting</h2><ul>\n<li>For memory leaks, check for retain cycles in closures and use <code>[weak self]</code> or <code>[unowned self]</code>.</li>\n<li>When debugging async callbacks, ensure closures capture and release context correctly.</li>\n<li>Compare Block and closure capture&#x2F;release mechanisms to choose the best fit for your scenario.</li>\n</ul>\n<h2 id=\"2-7-Related-Concepts\"><a href=\"#2-7-Related-Concepts\" class=\"headerlink\" title=\"2.7 Related Concepts\"></a>2.7 Related Concepts</h2><ul>\n<li><strong>Closure vs Block</strong>: Closures are first-class citizens in Swift, more modern; Blocks are Objective-C’s function object implementation.</li>\n<li><strong>Escaping Closures (@escaping)</strong>: Closure is called after the function returns, must be marked explicitly.</li>\n<li><strong>Autoclosure (@autoclosure)</strong>: Delays evaluation, often used in assertions and short-circuiting.</li>\n</ul>\n"},{"title":"mutating关键字的作用","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **mutating 关键字**\n   - 用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。\n   - 表示该方法内部可以修改实例自身的属性或自身（即 self ）。\n   - 结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。\n\n## 1.2 为什么需要 mutating？\n- Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。\n- 只有明确声明 mutating，才允许方法内部修改属性或赋值 self。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1 // 允许修改属性\n    }\n    mutating func reset() {\n        self = Counter() // 允许重新赋值 self\n    }\n}\n\nvar c = Counter()\nc.increment() // value 变为 1\nc.reset()     // value 变为 0\n```\n\n## 1.4 用户体验与业务价值\n- 明确哪些方法会修改数据，便于团队协作和代码维护。\n- 避免无意副作用，提升代码健壮性。\n\n## 1.5 问题拆解与调试建议\n- 如果 struct 方法需要修改属性但未加 mutating，编译器会报错。\n- 调试时优先检查 mutating 关键字是否遗漏。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concept\n- The `mutating` keyword in Swift is used in methods of structs and enums.\n- It allows the method to modify properties of `self` or assign a new value to `self`.\n- By default, value types (struct/enum) methods cannot modify their own properties unless marked as `mutating`.\n\n## 2.2 Why is it needed?\n- Swift enforces immutability for value types by default for safety.\n- Only methods explicitly marked as `mutating` can change the instance's state.\n\n## 2.3 Practical Example\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1\n    }\n    mutating func reset() {\n        self = Counter()\n    }\n}\n\nvar c = Counter()\nc.increment() // value becomes 1\nc.reset()     // value becomes 0\n```\n\n## 2.4 User Experience & Business Value\n- Makes code intent clear, improves team collaboration and maintainability.\n- Prevents unintended side effects, increasing code robustness.\n\n## 2.5 Debugging & Troubleshooting\n- If you need to modify a property in a struct method but forget `mutating`, the compiler will throw an error.\n- Always check for missing `mutating` if you see such errors.\n","source":"_posts/iOS/mutating关键字的作用.md","raw":"---\ntitle: mutating关键字的作用\ndate: 2025-07-08\ncategories:\n  - iOS\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **mutating 关键字**\n   - 用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。\n   - 表示该方法内部可以修改实例自身的属性或自身（即 self ）。\n   - 结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。\n\n## 1.2 为什么需要 mutating？\n- Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。\n- 只有明确声明 mutating，才允许方法内部修改属性或赋值 self。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1 // 允许修改属性\n    }\n    mutating func reset() {\n        self = Counter() // 允许重新赋值 self\n    }\n}\n\nvar c = Counter()\nc.increment() // value 变为 1\nc.reset()     // value 变为 0\n```\n\n## 1.4 用户体验与业务价值\n- 明确哪些方法会修改数据，便于团队协作和代码维护。\n- 避免无意副作用，提升代码健壮性。\n\n## 1.5 问题拆解与调试建议\n- 如果 struct 方法需要修改属性但未加 mutating，编译器会报错。\n- 调试时优先检查 mutating 关键字是否遗漏。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concept\n- The `mutating` keyword in Swift is used in methods of structs and enums.\n- It allows the method to modify properties of `self` or assign a new value to `self`.\n- By default, value types (struct/enum) methods cannot modify their own properties unless marked as `mutating`.\n\n## 2.2 Why is it needed?\n- Swift enforces immutability for value types by default for safety.\n- Only methods explicitly marked as `mutating` can change the instance's state.\n\n## 2.3 Practical Example\n```swift\nstruct Counter {\n    var value: Int = 0\n    mutating func increment() {\n        value += 1\n    }\n    mutating func reset() {\n        self = Counter()\n    }\n}\n\nvar c = Counter()\nc.increment() // value becomes 1\nc.reset()     // value becomes 0\n```\n\n## 2.4 User Experience & Business Value\n- Makes code intent clear, improves team collaboration and maintainability.\n- Prevents unintended side effects, increasing code robustness.\n\n## 2.5 Debugging & Troubleshooting\n- If you need to modify a property in a struct method but forget `mutating`, the compiler will throw an error.\n- Always check for missing `mutating` if you see such errors.\n","slug":"iOS/mutating关键字的作用","published":1,"updated":"2025-07-08T07:33:20.392Z","comments":1,"layout":"post","photos":[],"_id":"cmd78fh5l00085ek706c52g8g","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><strong>mutating 关键字</strong><ul>\n<li>用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。</li>\n<li>表示该方法内部可以修改实例自身的属性或自身（即 self ）。</li>\n<li>结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么需要-mutating？\"><a href=\"#1-2-为什么需要-mutating？\" class=\"headerlink\" title=\"1.2 为什么需要 mutating？\"></a>1.2 为什么需要 mutating？</h2><ul>\n<li>Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。</li>\n<li>只有明确声明 mutating，才允许方法内部修改属性或赋值 self。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span> <span class=\"comment\">// 允许修改属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>() <span class=\"comment\">// 允许重新赋值 self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value 变为 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value 变为 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>明确哪些方法会修改数据，便于团队协作和代码维护。</li>\n<li>避免无意副作用，提升代码健壮性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果 struct 方法需要修改属性但未加 mutating，编译器会报错。</li>\n<li>调试时优先检查 mutating 关键字是否遗漏。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ul>\n<li>The <code>mutating</code> keyword in Swift is used in methods of structs and enums.</li>\n<li>It allows the method to modify properties of <code>self</code> or assign a new value to <code>self</code>.</li>\n<li>By default, value types (struct&#x2F;enum) methods cannot modify their own properties unless marked as <code>mutating</code>.</li>\n</ul>\n<h2 id=\"2-2-Why-is-it-needed\"><a href=\"#2-2-Why-is-it-needed\" class=\"headerlink\" title=\"2.2 Why is it needed?\"></a>2.2 Why is it needed?</h2><ul>\n<li>Swift enforces immutability for value types by default for safety.</li>\n<li>Only methods explicitly marked as <code>mutating</code> can change the instance’s state.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value becomes 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value becomes 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Makes code intent clear, improves team collaboration and maintainability.</li>\n<li>Prevents unintended side effects, increasing code robustness.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If you need to modify a property in a struct method but forget <code>mutating</code>, the compiler will throw an error.</li>\n<li>Always check for missing <code>mutating</code> if you see such errors.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><strong>mutating 关键字</strong><ul>\n<li>用于 Swift 的 struct（结构体）和 enum（枚举）的方法声明。</li>\n<li>表示该方法内部可以修改实例自身的属性或自身（即 self ）。</li>\n<li>结构体和枚举是值类型，默认方法不能修改自身属性，除非加 mutating。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么需要-mutating？\"><a href=\"#1-2-为什么需要-mutating？\" class=\"headerlink\" title=\"1.2 为什么需要 mutating？\"></a>1.2 为什么需要 mutating？</h2><ul>\n<li>Swift 设计为值类型默认不可变，防止无意修改数据，提升安全性。</li>\n<li>只有明确声明 mutating，才允许方法内部修改属性或赋值 self。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span> <span class=\"comment\">// 允许修改属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>() <span class=\"comment\">// 允许重新赋值 self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value 变为 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value 变为 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>明确哪些方法会修改数据，便于团队协作和代码维护。</li>\n<li>避免无意副作用，提升代码健壮性。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果 struct 方法需要修改属性但未加 mutating，编译器会报错。</li>\n<li>调试时优先检查 mutating 关键字是否遗漏。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concept\"><a href=\"#2-1-Concept\" class=\"headerlink\" title=\"2.1 Concept\"></a>2.1 Concept</h2><ul>\n<li>The <code>mutating</code> keyword in Swift is used in methods of structs and enums.</li>\n<li>It allows the method to modify properties of <code>self</code> or assign a new value to <code>self</code>.</li>\n<li>By default, value types (struct&#x2F;enum) methods cannot modify their own properties unless marked as <code>mutating</code>.</li>\n</ul>\n<h2 id=\"2-2-Why-is-it-needed\"><a href=\"#2-2-Why-is-it-needed\" class=\"headerlink\" title=\"2.2 Why is it needed?\"></a>2.2 Why is it needed?</h2><ul>\n<li>Swift enforces immutability for value types by default for safety.</li>\n<li>Only methods explicitly marked as <code>mutating</code> can change the instance’s state.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">increment</span>() &#123;</span><br><span class=\"line\">        value <span class=\"operator\">+=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">reset</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c <span class=\"operator\">=</span> <span class=\"type\">Counter</span>()</span><br><span class=\"line\">c.increment() <span class=\"comment\">// value becomes 1</span></span><br><span class=\"line\">c.reset()     <span class=\"comment\">// value becomes 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Makes code intent clear, improves team collaboration and maintainability.</li>\n<li>Prevents unintended side effects, increasing code robustness.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Troubleshooting\"><a href=\"#2-5-Debugging-Troubleshooting\" class=\"headerlink\" title=\"2.5 Debugging &amp; Troubleshooting\"></a>2.5 Debugging &amp; Troubleshooting</h2><ul>\n<li>If you need to modify a property in a struct method but forget <code>mutating</code>, the compiler will throw an error.</li>\n<li>Always check for missing <code>mutating</code> if you see such errors.</li>\n</ul>\n"},{"title":"存储属性和计算属性的区别","date":"2025-07-07T16:00:00.000Z","_content":"\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **存储属性（Stored Property）**\n   - 直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。\n   - 语法：`var` 或 `let` 声明，系统自动分配内存。\n   - 例：\n     ```swift\n     struct User {\n         var name: String // 存储属性\n         let id: Int      // 存储属性\n     }\n     ```\n\n2. **计算属性（Computed Property）**\n   - 不直接存储值，而是通过 getter（和可选的 setter）动态计算。\n   - 每次访问时都会执行代码逻辑，通常依赖其他属性。\n   - 语法：必须有 `get`，可选 `set`。\n   - 例：\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // 计算属性\n             get { width * height }\n         }\n     }\n     ```\n\n## 1.2 为什么要区分？\n- 存储属性用于保存实际数据，适合需要持久化的状态。\n- 计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Product {\n    var price: Double      // 存储属性\n    var quantity: Int      // 存储属性\n    var total: Double {    // 计算属性\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // 输出 30\n```\n\n## 1.4 用户体验与业务价值\n- 存储属性保证数据一致性和性能，适合频繁读写。\n- 计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。\n\n## 1.5 问题拆解与调试建议\n- 如果属性只依赖其他属性且无需持久化，优先用计算属性。\n- 若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。\n- 调试时关注 getter/setter 是否有副作用，避免死循环或性能问题。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts\n1. **Stored Property**\n   - Stores actual data in memory for each instance.\n   - Declared with `var` or `let`.\n   - Example:\n     ```swift\n     struct User {\n         var name: String // stored property\n         let id: Int      // stored property\n     }\n     ```\n\n2. **Computed Property**\n   - Does not store a value; computes it on access via `get` (and optionally `set`).\n   - Example:\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // computed property\n             get { width * height }\n         }\n     }\n     ```\n\n## 2.2 Why distinguish?\n- Stored properties are for persistent state.\n- Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.\n\n## 2.3 Practical Example\n```swift\nstruct Product {\n    var price: Double      // stored property\n    var quantity: Int      // stored property\n    var total: Double {    // computed property\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // prints 30\n```\n\n## 2.4 User Experience & Business Value\n- Stored properties ensure data consistency and performance.\n- Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.\n\n## 2.5 Debugging & Optimization\n- Use computed properties for logic based on other properties.\n- Cache computed values as stored properties if performance is critical.\n- Watch for side effects in getters/setters to avoid infinite loops or performance issues.\n","source":"_posts/iOS/存储属性和计算属性的区别.md","raw":"---\ntitle: 存储属性和计算属性的区别\ndate: 2025-07-08\ncategories:\n  - iOS\n---\n\n# 1. 中文解答\n\n## 1.1 概念与原理\n1. **存储属性（Stored Property）**\n   - 直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。\n   - 语法：`var` 或 `let` 声明，系统自动分配内存。\n   - 例：\n     ```swift\n     struct User {\n         var name: String // 存储属性\n         let id: Int      // 存储属性\n     }\n     ```\n\n2. **计算属性（Computed Property）**\n   - 不直接存储值，而是通过 getter（和可选的 setter）动态计算。\n   - 每次访问时都会执行代码逻辑，通常依赖其他属性。\n   - 语法：必须有 `get`，可选 `set`。\n   - 例：\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // 计算属性\n             get { width * height }\n         }\n     }\n     ```\n\n## 1.2 为什么要区分？\n- 存储属性用于保存实际数据，适合需要持久化的状态。\n- 计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。\n\n## 1.3 实际项目代码示例\n```swift\nstruct Product {\n    var price: Double      // 存储属性\n    var quantity: Int      // 存储属性\n    var total: Double {    // 计算属性\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // 输出 30\n```\n\n## 1.4 用户体验与业务价值\n- 存储属性保证数据一致性和性能，适合频繁读写。\n- 计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。\n\n## 1.5 问题拆解与调试建议\n- 如果属性只依赖其他属性且无需持久化，优先用计算属性。\n- 若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。\n- 调试时关注 getter/setter 是否有副作用，避免死循环或性能问题。\n\n---\n\n# 2. English Answer\n\n## 2.1 Concepts\n1. **Stored Property**\n   - Stores actual data in memory for each instance.\n   - Declared with `var` or `let`.\n   - Example:\n     ```swift\n     struct User {\n         var name: String // stored property\n         let id: Int      // stored property\n     }\n     ```\n\n2. **Computed Property**\n   - Does not store a value; computes it on access via `get` (and optionally `set`).\n   - Example:\n     ```swift\n     struct Rectangle {\n         var width: Double\n         var height: Double\n         var area: Double { // computed property\n             get { width * height }\n         }\n     }\n     ```\n\n## 2.2 Why distinguish?\n- Stored properties are for persistent state.\n- Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.\n\n## 2.3 Practical Example\n```swift\nstruct Product {\n    var price: Double      // stored property\n    var quantity: Int      // stored property\n    var total: Double {    // computed property\n        get { price * Double(quantity) }\n    }\n}\n\nvar p = Product(price: 10, quantity: 3)\nprint(p.total) // prints 30\n```\n\n## 2.4 User Experience & Business Value\n- Stored properties ensure data consistency and performance.\n- Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.\n\n## 2.5 Debugging & Optimization\n- Use computed properties for logic based on other properties.\n- Cache computed values as stored properties if performance is critical.\n- Watch for side effects in getters/setters to avoid infinite loops or performance issues.\n","slug":"iOS/存储属性和计算属性的区别","published":1,"updated":"2025-07-08T07:33:20.392Z","comments":1,"layout":"post","photos":[],"_id":"cmd78fh5l000a5ek78mx45qr5","content":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>存储属性（Stored Property）</strong></p>\n<ul>\n<li>直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。</li>\n<li>语法：<code>var</code> 或 <code>let</code> 声明，系统自动分配内存。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>计算属性（Computed Property）</strong></p>\n<ul>\n<li>不直接存储值，而是通过 getter（和可选的 setter）动态计算。</li>\n<li>每次访问时都会执行代码逻辑，通常依赖其他属性。</li>\n<li>语法：必须有 <code>get</code>，可选 <code>set</code>。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要区分？\"><a href=\"#1-2-为什么要区分？\" class=\"headerlink\" title=\"1.2 为什么要区分？\"></a>1.2 为什么要区分？</h2><ul>\n<li>存储属性用于保存实际数据，适合需要持久化的状态。</li>\n<li>计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// 输出 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>存储属性保证数据一致性和性能，适合频繁读写。</li>\n<li>计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果属性只依赖其他属性且无需持久化，优先用计算属性。</li>\n<li>若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。</li>\n<li>调试时关注 getter&#x2F;setter 是否有副作用，避免死循环或性能问题。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts\"><a href=\"#2-1-Concepts\" class=\"headerlink\" title=\"2.1 Concepts\"></a>2.1 Concepts</h2><ol>\n<li><p><strong>Stored Property</strong></p>\n<ul>\n<li>Stores actual data in memory for each instance.</li>\n<li>Declared with <code>var</code> or <code>let</code>.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>Computed Property</strong></p>\n<ul>\n<li>Does not store a value; computes it on access via <code>get</code> (and optionally <code>set</code>).</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-distinguish\"><a href=\"#2-2-Why-distinguish\" class=\"headerlink\" title=\"2.2 Why distinguish?\"></a>2.2 Why distinguish?</h2><ul>\n<li>Stored properties are for persistent state.</li>\n<li>Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// prints 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Stored properties ensure data consistency and performance.</li>\n<li>Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Optimization\"><a href=\"#2-5-Debugging-Optimization\" class=\"headerlink\" title=\"2.5 Debugging &amp; Optimization\"></a>2.5 Debugging &amp; Optimization</h2><ul>\n<li>Use computed properties for logic based on other properties.</li>\n<li>Cache computed values as stored properties if performance is critical.</li>\n<li>Watch for side effects in getters&#x2F;setters to avoid infinite loops or performance issues.</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"1-中文解答\"><a href=\"#1-中文解答\" class=\"headerlink\" title=\"1. 中文解答\"></a>1. 中文解答</h1><h2 id=\"1-1-概念与原理\"><a href=\"#1-1-概念与原理\" class=\"headerlink\" title=\"1.1 概念与原理\"></a>1.1 概念与原理</h2><ol>\n<li><p><strong>存储属性（Stored Property）</strong></p>\n<ul>\n<li>直接存储在实例内存中的变量或常量，每个实例都有独立的存储空间。</li>\n<li>语法：<code>var</code> 或 <code>let</code> 声明，系统自动分配内存。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>计算属性（Computed Property）</strong></p>\n<ul>\n<li>不直接存储值，而是通过 getter（和可选的 setter）动态计算。</li>\n<li>每次访问时都会执行代码逻辑，通常依赖其他属性。</li>\n<li>语法：必须有 <code>get</code>，可选 <code>set</code>。</li>\n<li>例：<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"1-2-为什么要区分？\"><a href=\"#1-2-为什么要区分？\" class=\"headerlink\" title=\"1.2 为什么要区分？\"></a>1.2 为什么要区分？</h2><ul>\n<li>存储属性用于保存实际数据，适合需要持久化的状态。</li>\n<li>计算属性用于动态逻辑，节省内存、提升灵活性，避免冗余数据。</li>\n</ul>\n<h2 id=\"1-3-实际项目代码示例\"><a href=\"#1-3-实际项目代码示例\" class=\"headerlink\" title=\"1.3 实际项目代码示例\"></a>1.3 实际项目代码示例</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// 存储属性</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// 计算属性</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// 输出 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-4-用户体验与业务价值\"><a href=\"#1-4-用户体验与业务价值\" class=\"headerlink\" title=\"1.4 用户体验与业务价值\"></a>1.4 用户体验与业务价值</h2><ul>\n<li>存储属性保证数据一致性和性能，适合频繁读写。</li>\n<li>计算属性让 API 更简洁，自动响应数据变化，减少手动同步和 bug。</li>\n</ul>\n<h2 id=\"1-5-问题拆解与调试建议\"><a href=\"#1-5-问题拆解与调试建议\" class=\"headerlink\" title=\"1.5 问题拆解与调试建议\"></a>1.5 问题拆解与调试建议</h2><ul>\n<li>如果属性只依赖其他属性且无需持久化，优先用计算属性。</li>\n<li>若遇到性能瓶颈，可将频繁访问的计算属性缓存为存储属性。</li>\n<li>调试时关注 getter&#x2F;setter 是否有副作用，避免死循环或性能问题。</li>\n</ul>\n<hr>\n<h1 id=\"2-English-Answer\"><a href=\"#2-English-Answer\" class=\"headerlink\" title=\"2. English Answer\"></a>2. English Answer</h1><h2 id=\"2-1-Concepts\"><a href=\"#2-1-Concepts\" class=\"headerlink\" title=\"2.1 Concepts\"></a>2.1 Concepts</h2><ol>\n<li><p><strong>Stored Property</strong></p>\n<ul>\n<li>Stores actual data in memory for each instance.</li>\n<li>Declared with <code>var</code> or <code>let</code>.</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> id: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>Computed Property</strong></p>\n<ul>\n<li>Does not store a value; computes it on access via <code>get</code> (and optionally <code>set</code>).</li>\n<li>Example:<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rectangle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> width: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> height: <span class=\"type\">Double</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; width <span class=\"operator\">*</span> height &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-2-Why-distinguish\"><a href=\"#2-2-Why-distinguish\" class=\"headerlink\" title=\"2.2 Why distinguish?\"></a>2.2 Why distinguish?</h2><ul>\n<li>Stored properties are for persistent state.</li>\n<li>Computed properties provide dynamic logic, reduce redundancy, and improve flexibility.</li>\n</ul>\n<h2 id=\"2-3-Practical-Example\"><a href=\"#2-3-Practical-Example\" class=\"headerlink\" title=\"2.3 Practical Example\"></a>2.3 Practical Example</h2><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Product</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Double</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span>      <span class=\"comment\">// stored property</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> &#123;    <span class=\"comment\">// computed property</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; price <span class=\"operator\">*</span> <span class=\"type\">Double</span>(quantity) &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p <span class=\"operator\">=</span> <span class=\"type\">Product</span>(price: <span class=\"number\">10</span>, quantity: <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(p.total) <span class=\"comment\">// prints 30</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4-User-Experience-Business-Value\"><a href=\"#2-4-User-Experience-Business-Value\" class=\"headerlink\" title=\"2.4 User Experience &amp; Business Value\"></a>2.4 User Experience &amp; Business Value</h2><ul>\n<li>Stored properties ensure data consistency and performance.</li>\n<li>Computed properties make APIs cleaner and automatically reflect changes, reducing bugs.</li>\n</ul>\n<h2 id=\"2-5-Debugging-Optimization\"><a href=\"#2-5-Debugging-Optimization\" class=\"headerlink\" title=\"2.5 Debugging &amp; Optimization\"></a>2.5 Debugging &amp; Optimization</h2><ul>\n<li>Use computed properties for logic based on other properties.</li>\n<li>Cache computed values as stored properties if performance is critical.</li>\n<li>Watch for side effects in getters&#x2F;setters to avoid infinite loops or performance issues.</li>\n</ul>\n"},{"title":"泛型（Generics）","date":"2025-07-01T16:00:00.000Z","_content":"\n# 在 Swift 中，什么是泛型（Generics）？\n\n## 1. 概念与原理\n\n1.1 定义  \n泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。\n\n1.2 为什么需要泛型  \n- **代码复用**：避免重复实现相似逻辑。\n- **类型安全**：在编译期检查类型，减少运行时错误。\n- **灵活性**：支持多种数据类型，提升 API 设计的通用性。\n\n1.3 原理简述  \nSwift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。\n\n## 2. 语法与实现\n\n2.1 基本语法\n```swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temp = a\n    a = b\n    b = temp\n}\n```\n- `T` 是类型占位符，调用时由编译器推断。\n\n2.2 泛型类型\n```swift\nstruct Stack<Element> {\n    private var items = [Element]()\n    mutating func push(_ item: Element) { items.append(item) }\n    mutating func pop() -> Element? { items.popLast() }\n}\n```\n- `Element` 可为任意类型，提升了数据结构的通用性。\n\n2.3 泛型约束\n```swift\nfunc findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {\n    for (index, item) in array.enumerated() {\n        if item == value { return index }\n    }\n    return nil\n}\n```\n- 通过 `T: Equatable` 限定泛型类型必须实现等值比较。\n\n## 3. 实际项目中的应用场景\n\n3.1 网络层数据解析\n- 利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。\n```swift\nprotocol DecodableModel: Decodable {}\n\nfunc fetchData<T: DecodableModel>(from url: URL, completion: @escaping (Result<T, Error>) -> Void) {\n    // 网络请求与解析逻辑\n}\n```\n\n3.2 组件化 UI 设计\n- 通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。\n\n## 4. 用户体验与业务需求的结合\n- 泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。\n- 便于团队维护和扩展，降低后期 bug 率。\n- 通过类型安全，减少因类型不匹配导致的用户端崩溃。\n\n## 5. Debug 与排查能力\n\n5.1 常见问题\n- 泛型类型推断失败：需显式指定类型或增加约束。\n- 复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。\n\n5.2 排查流程\n- 检查泛型约束是否合理。\n- 利用 Xcode 的类型推断提示，定位类型不匹配点。\n- 通过单元测试覆盖泛型逻辑，及时发现边界问题。\n\n## 6. 总结\n泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。\n","source":"_posts/iOS/泛型Generics.md","raw":"---\ntitle: 泛型（Generics）\ndate: 2025-07-02\ncategories:\n  - iOS\n---\n\n# 在 Swift 中，什么是泛型（Generics）？\n\n## 1. 概念与原理\n\n1.1 定义  \n泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。\n\n1.2 为什么需要泛型  \n- **代码复用**：避免重复实现相似逻辑。\n- **类型安全**：在编译期检查类型，减少运行时错误。\n- **灵活性**：支持多种数据类型，提升 API 设计的通用性。\n\n1.3 原理简述  \nSwift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。\n\n## 2. 语法与实现\n\n2.1 基本语法\n```swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temp = a\n    a = b\n    b = temp\n}\n```\n- `T` 是类型占位符，调用时由编译器推断。\n\n2.2 泛型类型\n```swift\nstruct Stack<Element> {\n    private var items = [Element]()\n    mutating func push(_ item: Element) { items.append(item) }\n    mutating func pop() -> Element? { items.popLast() }\n}\n```\n- `Element` 可为任意类型，提升了数据结构的通用性。\n\n2.3 泛型约束\n```swift\nfunc findIndex<T: Equatable>(of value: T, in array: [T]) -> Int? {\n    for (index, item) in array.enumerated() {\n        if item == value { return index }\n    }\n    return nil\n}\n```\n- 通过 `T: Equatable` 限定泛型类型必须实现等值比较。\n\n## 3. 实际项目中的应用场景\n\n3.1 网络层数据解析\n- 利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。\n```swift\nprotocol DecodableModel: Decodable {}\n\nfunc fetchData<T: DecodableModel>(from url: URL, completion: @escaping (Result<T, Error>) -> Void) {\n    // 网络请求与解析逻辑\n}\n```\n\n3.2 组件化 UI 设计\n- 通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。\n\n## 4. 用户体验与业务需求的结合\n- 泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。\n- 便于团队维护和扩展，降低后期 bug 率。\n- 通过类型安全，减少因类型不匹配导致的用户端崩溃。\n\n## 5. Debug 与排查能力\n\n5.1 常见问题\n- 泛型类型推断失败：需显式指定类型或增加约束。\n- 复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。\n\n5.2 排查流程\n- 检查泛型约束是否合理。\n- 利用 Xcode 的类型推断提示，定位类型不匹配点。\n- 通过单元测试覆盖泛型逻辑，及时发现边界问题。\n\n## 6. 总结\n泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。\n","slug":"iOS/泛型Generics","published":1,"updated":"2025-07-08T07:33:20.392Z","comments":1,"layout":"post","photos":[],"_id":"cmd78fh5q001w5ek7f26kb2e9","content":"<h1 id=\"在-Swift-中，什么是泛型（Generics）？\"><a href=\"#在-Swift-中，什么是泛型（Generics）？\" class=\"headerlink\" title=\"在 Swift 中，什么是泛型（Generics）？\"></a>在 Swift 中，什么是泛型（Generics）？</h1><h2 id=\"1-概念与原理\"><a href=\"#1-概念与原理\" class=\"headerlink\" title=\"1. 概念与原理\"></a>1. 概念与原理</h2><p>1.1 定义<br>泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。</p>\n<p>1.2 为什么需要泛型  </p>\n<ul>\n<li><strong>代码复用</strong>：避免重复实现相似逻辑。</li>\n<li><strong>类型安全</strong>：在编译期检查类型，减少运行时错误。</li>\n<li><strong>灵活性</strong>：支持多种数据类型，提升 API 设计的通用性。</li>\n</ul>\n<p>1.3 原理简述<br>Swift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。</p>\n<h2 id=\"2-语法与实现\"><a href=\"#2-语法与实现\" class=\"headerlink\" title=\"2. 语法与实现\"></a>2. 语法与实现</h2><p>2.1 基本语法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">swapTwoValues</span>&lt;<span class=\"type\">T</span>&gt;(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>, <span class=\"keyword\">_</span> <span class=\"params\">b</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp <span class=\"operator\">=</span> a</span><br><span class=\"line\">    a <span class=\"operator\">=</span> b</span><br><span class=\"line\">    b <span class=\"operator\">=</span> temp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>T</code> 是类型占位符，调用时由编译器推断。</li>\n</ul>\n<p>2.2 泛型类型</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Stack</span>&lt;<span class=\"type\">Element</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> items <span class=\"operator\">=</span> [<span class=\"type\">Element</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">push</span>(<span class=\"keyword\">_</span> <span class=\"params\">item</span>: <span class=\"type\">Element</span>) &#123; items.append(item) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">pop</span>() -&gt; <span class=\"type\">Element</span>? &#123; items.popLast() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Element</code> 可为任意类型，提升了数据结构的通用性。</li>\n</ul>\n<p>2.3 泛型约束</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">findIndex</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">Equatable</span>&gt;(<span class=\"params\">of</span> <span class=\"params\">value</span>: <span class=\"type\">T</span>, <span class=\"params\">in</span> <span class=\"params\">array</span>: [<span class=\"type\">T</span>]) -&gt; <span class=\"type\">Int</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index, item) <span class=\"keyword\">in</span> array.enumerated() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> item <span class=\"operator\">==</span> value &#123; <span class=\"keyword\">return</span> index &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 <code>T: Equatable</code> 限定泛型类型必须实现等值比较。</li>\n</ul>\n<h2 id=\"3-实际项目中的应用场景\"><a href=\"#3-实际项目中的应用场景\" class=\"headerlink\" title=\"3. 实际项目中的应用场景\"></a>3. 实际项目中的应用场景</h2><p>3.1 网络层数据解析</p>\n<ul>\n<li>利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">DecodableModel</span>: <span class=\"title class_ inherited__\">Decodable</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">DecodableModel</span>&gt;(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">Error</span>&gt;) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求与解析逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.2 组件化 UI 设计</p>\n<ul>\n<li>通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。</li>\n</ul>\n<h2 id=\"4-用户体验与业务需求的结合\"><a href=\"#4-用户体验与业务需求的结合\" class=\"headerlink\" title=\"4. 用户体验与业务需求的结合\"></a>4. 用户体验与业务需求的结合</h2><ul>\n<li>泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。</li>\n<li>便于团队维护和扩展，降低后期 bug 率。</li>\n<li>通过类型安全，减少因类型不匹配导致的用户端崩溃。</li>\n</ul>\n<h2 id=\"5-Debug-与排查能力\"><a href=\"#5-Debug-与排查能力\" class=\"headerlink\" title=\"5. Debug 与排查能力\"></a>5. Debug 与排查能力</h2><p>5.1 常见问题</p>\n<ul>\n<li>泛型类型推断失败：需显式指定类型或增加约束。</li>\n<li>复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。</li>\n</ul>\n<p>5.2 排查流程</p>\n<ul>\n<li>检查泛型约束是否合理。</li>\n<li>利用 Xcode 的类型推断提示，定位类型不匹配点。</li>\n<li>通过单元测试覆盖泛型逻辑，及时发现边界问题。</li>\n</ul>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。</p>\n","excerpt":"","more":"<h1 id=\"在-Swift-中，什么是泛型（Generics）？\"><a href=\"#在-Swift-中，什么是泛型（Generics）？\" class=\"headerlink\" title=\"在 Swift 中，什么是泛型（Generics）？\"></a>在 Swift 中，什么是泛型（Generics）？</h1><h2 id=\"1-概念与原理\"><a href=\"#1-概念与原理\" class=\"headerlink\" title=\"1. 概念与原理\"></a>1. 概念与原理</h2><p>1.1 定义<br>泛型（Generics）是 Swift 提供的一种强大特性，允许你编写可复用、类型安全的代码。通过泛型，函数、结构体、类和枚举可以适用于任意类型，而无需为每种类型分别实现。</p>\n<p>1.2 为什么需要泛型  </p>\n<ul>\n<li><strong>代码复用</strong>：避免重复实现相似逻辑。</li>\n<li><strong>类型安全</strong>：在编译期检查类型，减少运行时错误。</li>\n<li><strong>灵活性</strong>：支持多种数据类型，提升 API 设计的通用性。</li>\n</ul>\n<p>1.3 原理简述<br>Swift 编译器在编译时会根据实际传入的类型生成对应的代码（类型擦除与特化），保证类型安全和高效执行。</p>\n<h2 id=\"2-语法与实现\"><a href=\"#2-语法与实现\" class=\"headerlink\" title=\"2. 语法与实现\"></a>2. 语法与实现</h2><p>2.1 基本语法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">swapTwoValues</span>&lt;<span class=\"type\">T</span>&gt;(<span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>, <span class=\"keyword\">_</span> <span class=\"params\">b</span>: <span class=\"keyword\">inout</span> <span class=\"type\">T</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp <span class=\"operator\">=</span> a</span><br><span class=\"line\">    a <span class=\"operator\">=</span> b</span><br><span class=\"line\">    b <span class=\"operator\">=</span> temp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>T</code> 是类型占位符，调用时由编译器推断。</li>\n</ul>\n<p>2.2 泛型类型</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Stack</span>&lt;<span class=\"type\">Element</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> items <span class=\"operator\">=</span> [<span class=\"type\">Element</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">push</span>(<span class=\"keyword\">_</span> <span class=\"params\">item</span>: <span class=\"type\">Element</span>) &#123; items.append(item) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">pop</span>() -&gt; <span class=\"type\">Element</span>? &#123; items.popLast() &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Element</code> 可为任意类型，提升了数据结构的通用性。</li>\n</ul>\n<p>2.3 泛型约束</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">findIndex</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">Equatable</span>&gt;(<span class=\"params\">of</span> <span class=\"params\">value</span>: <span class=\"type\">T</span>, <span class=\"params\">in</span> <span class=\"params\">array</span>: [<span class=\"type\">T</span>]) -&gt; <span class=\"type\">Int</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (index, item) <span class=\"keyword\">in</span> array.enumerated() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> item <span class=\"operator\">==</span> value &#123; <span class=\"keyword\">return</span> index &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过 <code>T: Equatable</code> 限定泛型类型必须实现等值比较。</li>\n</ul>\n<h2 id=\"3-实际项目中的应用场景\"><a href=\"#3-实际项目中的应用场景\" class=\"headerlink\" title=\"3. 实际项目中的应用场景\"></a>3. 实际项目中的应用场景</h2><p>3.1 网络层数据解析</p>\n<ul>\n<li>利用泛型和协议组合，实现通用的网络请求和 JSON 解析，提升代码复用率。<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">DecodableModel</span>: <span class=\"title class_ inherited__\">Decodable</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">fetchData</span>&lt;<span class=\"type\">T</span>: <span class=\"type\">DecodableModel</span>&gt;(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">completion</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Result</span>&lt;<span class=\"type\">T</span>, <span class=\"type\">Error</span>&gt;) -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 网络请求与解析逻辑</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.2 组件化 UI 设计</p>\n<ul>\n<li>通过泛型自定义通用的 UI 组件（如 TableView、CollectionView 的数据源），提升团队协作效率。</li>\n</ul>\n<h2 id=\"4-用户体验与业务需求的结合\"><a href=\"#4-用户体验与业务需求的结合\" class=\"headerlink\" title=\"4. 用户体验与业务需求的结合\"></a>4. 用户体验与业务需求的结合</h2><ul>\n<li>泛型让 API 更加简洁、易用，减少冗余代码，提升开发效率。</li>\n<li>便于团队维护和扩展，降低后期 bug 率。</li>\n<li>通过类型安全，减少因类型不匹配导致的用户端崩溃。</li>\n</ul>\n<h2 id=\"5-Debug-与排查能力\"><a href=\"#5-Debug-与排查能力\" class=\"headerlink\" title=\"5. Debug 与排查能力\"></a>5. Debug 与排查能力</h2><p>5.1 常见问题</p>\n<ul>\n<li>泛型类型推断失败：需显式指定类型或增加约束。</li>\n<li>复杂嵌套泛型导致编译错误：逐步拆解，简化泛型表达式。</li>\n</ul>\n<p>5.2 排查流程</p>\n<ul>\n<li>检查泛型约束是否合理。</li>\n<li>利用 Xcode 的类型推断提示，定位类型不匹配点。</li>\n<li>通过单元测试覆盖泛型逻辑，及时发现边界问题。</li>\n</ul>\n<h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2><p>泛型是 Swift 现代化编程的基石，既提升了代码的复用性和安全性，也为团队协作和业务扩展提供了坚实基础。实际开发中，合理运用泛型能极大提升项目的健壮性和用户体验。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmd78fh5l00085ek706c52g8g","category_id":"cmd78fh5k00045ek70tef3yin","_id":"cmd78fh5m000e5ek7dxom8ks3"},{"post_id":"cmd78fh5h00015ek71cap6bxz","category_id":"cmd78fh5k00045ek70tef3yin","_id":"cmd78fh5m000h5ek777t7g9ga"},{"post_id":"cmd78fh5l000a5ek78mx45qr5","category_id":"cmd78fh5k00045ek70tef3yin","_id":"cmd78fh5m000j5ek78gfa0773"},{"post_id":"cmd78fh5j00035ek7gru20pwv","category_id":"cmd78fh5k00045ek70tef3yin","_id":"cmd78fh5m000l5ek7bppzf1g2"},{"post_id":"cmd78fh5k00065ek7emkk37fb","category_id":"cmd78fh5k00045ek70tef3yin","_id":"cmd78fh5m000n5ek7gjp7fbru"},{"post_id":"cmd78fh5q001w5ek7f26kb2e9","category_id":"cmd78fh5k00045ek70tef3yin","_id":"cmd78fh5q001x5ek7cu58hoce"}],"PostTag":[],"Tag":[]}}